# 9.2 필드 이름 바꾸기(Rename Field)
``` diff
class Organization {
- get name() {...}
+ get title() {...}
}
```
## 배경
이름은 중요하다. 그리고 프로그램 곳곳에서 쓰이는 레코드 구조체의 필드 이름들은 특히 더 중요하다. 데이터 구조는 프로그램을 이해하는 데 큰 역할을 한다. 수년 전 프레드 브룩스(Fred Brooks)는 이런 말을 했다. "데이터 테이블 없이 흐름도(flowchart)만 보여줘서는 나는 여전히 혼란스러울 것이다. 하지만 데이터 테이블을 보여준다면 흐름도는 웬만해선 필요조차 없을 것이다. 테이블만으로도 명확하기 때문이다." 요즘은 흐름도를 그리는 사람을 찾기 어렵지만 이 격언은 여전히 유효하다. 데이터 구조는 무슨 일이 벌어지는지를 이해하는 열쇠다.

데이터 구조가 중요한 만큼 반드시 깔끔하게 관리해야 한다. 다른 요소와 마찬가지로 개발을 진행할수록 데이터를 더 잘 이해하게 된다. 따라서 그 깊어진 이해를 프로그램에 반드시 반영해야 한다.

이 과정에서 레코드의 필드 이름을 바꾸고 싶을 수 있는데, 클래스에서도 마찬가지다. 게터와 세터 메서드는 클래스 사용자 입장에서는 필드와 다를 바 없다. 따라서 게터와 세터 이름을 바꾸기도 레코드 구조체의 필드 이름 바꾸기와 똑같이 중요하다
## 절차
### (1)
레코드의 유효 범위가 제한적이라면 필드에 접근하는 모든 코드를 수정한 후 테스트한다. 이후 단계는 필요없다.
### (2)
레코드가 캡슐화되지 않았다면 우선 [7.1 레코드 캡슐화하기(Encapsulate Record)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-1.md) 한다.
### (3)
캡슐화된 객체 안의 `private` 필드명을 변경하고, 그에 맞게 내부 메서드들을 수정한다.
### (4)
테스트한다.
### (5)
생성자의 매개변수 중 필드와 이름이 겹치는 게 있다면 [6.5 함수 선언 바꾸기(Change Function Declaration)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-5.md)로 변경한다.
### (6)
접근자들의 이름도 [6.5 함수 선언 바꾸기(Change Function Declaration)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-5.md)로 바꿔준다.

## 예시
다음의 상수가 하나 있다.
``` javascript
const organization = { name: '애크미 구스베리', country: 'GB' };
```
여기서 `name`을 `title`로 바꾸고 싶다고 해보자. 이 객체는 코드베이스 곳곳에서 사용되며, 그 중 이 제목(`title`)을 변경하는 곳도 있다.[(2)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter09/9-2.md#2) 그래서 우선 `organization` 레코드를 클래스로 [7.1 레코드 캡슐화하기(Encapsulate Record)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-1.md) 한다.
``` diff
+class Organization {
+ constructor(data) {
+   this._name = data.name;
+   this._country = data.country;
+ }
+ get name() { return this._name; }
+ set name(aString) { this._name = aString; }
+ get country() { return this._country; }
+ set country(aCountryCode) { this._country = aCountryCode; }
+}

const organization = { name: '애크미 구스베리', country: 'GB' };
```
자, 레코드를 클래스로 캡슐화하자 이름을 변경할 곳이 네 곳이 되었다. 게터 함수, 세터 함수, 생성자, 내부 데이터 구조다. 일을 더 키워버린 게 아닌가 싶겠지만, 실제로는 더 쉬워진 것이다. 모든 변경을 한 번에 수행하는 대신 작은 단계들로 나눠 독립적으로 수행할 수 있게 됐으니 말이다. 여기서 '작은 단계'라 함은 각 단계에서 잘못될 일이 적어졌고, 그래서 할 일도 줄었다는 뜻이다. 물론 실수를 저지르지 않는다면 줄어들 일도 없지만, '실수 없이'란 내가 아주 예전에 포기한 판타지일 뿐이다.

입력 데이터 구조를 내부 데이터 구조로 복제했으므로 둘을 구분해야 독립적으로 작업할 수 있다.[(3)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter09/9-2.md#3) 별도의 필드를 정의하고 생성자와 접근자에서 둘을 구분해서 사용하도록 하자.

``` diff
class Organization {
  constructor(data) {
-   this._name = data.name;
+   this._title = data.name;
    this._country = data.country;
  }
- get name() { return this._name; }
+ get name() { return this._title; }
- set name(aString) { this._name = aString; }
+ set name(aString) { this._title = aString; }
  get country() { return this._country; }
  set country(aCountryCode) { this._country = aCountryCode; }
}

const organization = { name: '애크미 구스베리', country: 'GB' };
```
다음으로 생성자에서 `title`도 받아들일 수 있도록 조치한다.
``` diff
class Organization {
  constructor(data) {
-   this._title = data.name;
+   this._title = (data.title !== undefined) ? data.title : data.name;
    this._country = data.country;
  }
  get name() { return this._title; }
  set name(aString) { this._title = aString; }
  get country() { return this._country; }
  set country(aCountryCode) { this._country = aCountryCode; }
}

const organization = { name: '애크미 구스베리', country: 'GB' };
```
이상으로 생성자를 호출하는 쪽에서는 `name`과 `title`을 모두 사용할 수 있게 되었다(둘 다 등장할 시 `title`이 우선한다). 이제 이 생성자를 호출하는 곳을 모두 찾아서 새로운 이름인 `title`을 사용하도록 하나씩 수정한다.
``` diff
class Organization {
  constructor(data) {
    this._title = (data.title !== undefined) ? data.title : data.name;
    this._country = data.country;
  }
  get name() { return this._title; }
  set name(aString) { this._title = aString; }
  get country() { return this._country; }
  set country(aCountryCode) { this._country = aCountryCode; }
}

-const organization = { name: '애크미 구스베리', country: 'GB' };
+const organization = new Organization({ title: '애크미 구스베리', country: 'GB' });
```
모두 수정했다면 생성자에서 `name`을 사용할 수 있게 하던 코드를 제거한다.
``` diff
class Organization {
  constructor(data) {
-   this._title = (data.title !== undefined) ? data.title : data.name;
+   this._title = data.title;
    this._country = data.country;
  }
  get name() { return this._title; }
  set name(aString) { this._title = aString; }
  get country() { return this._country; }
  set country(aCountryCode) { this._country = aCountryCode; }
}

const organization = new Organization({ title: '애크미 구스베리', country: 'GB' });
```
[(6)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter09/9-2.md#6) 이제 생성자와 데이터가 새로운 이름을 사용하게 되었으니 접근자도 수정할 수 있게 되었다. 쉬운 작업이다. 단순히 접근자 각각의 이름을 바꿔주면 된다.([6.5 함수 선언 바꾸기(Change Function Declaration)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-5.md))
``` diff
class Organization {
  constructor(data) {
    this._title = data.title;
    this._country = data.country;
  }
- get name() { return this._title; }
+ get title() { return this._title; }
- set name(aString) { this._title = aString; }
+ set title(aString) { this._title = aString; }
  get country() { return this._country; }
  set country(aCountryCode) { this._country = aCountryCode; }
}

const organization = new Organization({ title: '애크미 구스베리', country: 'GB' });
```
지금까지 보여준 과정은 널리 참조되는 데이터 구조일 때 적용되는 가장 복잡한 형태다. 한 함수의 안에서만 쓰였다면 캡슐화할 필요 없이 그저 원하는 속성들의 이름을 바꿔주는 것으로 끝났을 일이다. 전체 과정을 적용할지는 상황에 맞게 잘 판단하기 바란다. 단, 리팩터링 도중 테스트에 실패한다면 더 작은 단계로 나눠 진행해야 한다는 신호임을 잊지 말자.

데이터 구조를 불변으로 만들 수 있는 프로그래밍 언어도 있다. 그런 언어를 사용한다면 캡슐화하는 대신 데이터 구조의 값을 복제해 새로운 이름으로 선언한다. 그런 다음 사용하는 곳을 찾아 하나씩 새 데이터를 사용하도록 수정하고, 마지막으로 원래의 데이터 구조를 제거하면 된다. 가변 데이터 구조를 이용한다면 데이터를 복제하는 행위가 재앙으로 이어질 수 있다. 불변 데이터 구조가 널리 쓰이게 된 이유는 바로 이 재앙을 막기 위해서다.

- [9.1 변수 쪼개기(Split Variable)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter09/9-1.md)
- [9.3 파생 변수를 질의 함수로 바꾸기(Replace Derived Variable with Query)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter09/9-3.md)