# 9.6 매직 리터럴 바꾸기(Replace Magic Literal)
``` diff
+STANDARD_GRAVITY = 9.81;
function potentialEnergy(mass, height) {
- return mass * 9.81 * height;
+ return mass * STANDARD_GRAVITY * height;
}
```
## 배경
매직 리터럴(`magic literal`)이란 소스 코드에 (보통은 여러 곳에) 등장하는 일반적인 리터럴 값을 말한다. 예컨대 움직임을 계산하는 코드에서라면 9.80665라는 숫자가 여기저기 있는 모습을 볼 수 있다. 내가 물리 수업을 들은 게 언제인지 까마득하지만 이 숫자가 표준중력을 뜻한다는 건 기억이 난다. 하지만 코드를 읽는 사람이 이 값의 의미를 모른다면 숫자 자체로는 의미를 명확히 알려주지 못하므로 매직 리터럴이라 할 수 있다. 의미를 알고 있다고 해도 결국 각자의 머리에서 해석해낸 것일 뿐이라서, 이보다는 코드 자체가 뜻을 분명하게 드러내는 게 좋다. 상수를 정의하고 숫자 대신 상수를 사용하도록 바꾸면 될 것이다.

매직 리터럴은 대체로 숫자가 많지만 다른 타입의 리터럴도 특별한 의미를 지닐 수 있다. 예컨데 `1월 1일`은 새로운 해의 시작을, `M`은 남성을, `서울`은 본사를 뜻할 수도 있다.

일반적으로는 해당 값이 쓰이는 모든 곳을 적절한 이름의 상수로 바꿔주는 방법이 가장 좋다. 다른 선택지도 있는데, 그 상수가 특별한 비교 로직에 주로 쓰이는 경우에 고려해볼 수 있는 방법이다. 예컨데 나는 `aValue === "M"`을 `aValue === MALE_GENDER`로 바꾸기보다 `isMale(aValue)`라는 함수 호출로 바꾸는 쪽을 선호한다.

상수를 과용하는 모습도 종종 본다. `const ONE = 1` 같은 선언은 의미가 없다. 의미 전달 면에서 값을 바로 쓰는 것보다 나을 게 없기 때문이다(값이 달라질 가능성도 없다). 또한 리터럴이 함수 하나에서만 쓰이고 그 함수가 맥락 정보를 충분히 제공하여 헷갈릴 일이 없다면 상수로 바꿔 얻는 이득이 줄어든다.
## 절차
### (1)
상수를 선언하고 매직 리터럴을 대입한다.
### (2)
해당 리터럴이 사용되는 곳을 모두 찾는다.
### (3)
찾은 곳 각각에서 리터럴이 새 상수와 똑같은 의미로 쓰였는지 확인하여, 같은 의미라면 상수로 대체한 후 테스트한다.

> 이 리팩터링이 제대로 되었는지는 어떻게 테스트할까? 좋은 방법을 하나 소개하겠다. 상수의 값을 바꾸고, 관련 테스트 모두가 바뀐 값에 해당하는 결과를 내는지 확인하는 것이다. 항상 적용할 수 있는 방법은 아니지만, 가능한 경우라면 아주 편리하다.

- [목차](https://github.com/wonder13662/refactoring-v2/blob/writing)
- [9 데이터 조직화](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter09)
- [9.5 값을 참조로 바꾸기(Change Value to Reference)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter09/9-5.md)
- [10 조건부 로직 간소화](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10)
- [10.1 조건문 분해하기(Decompose Conditional)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-1.md)
