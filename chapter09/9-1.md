# 9.1 변수 쪼개기(Split Variable)
``` diff
-let temp = 2 * (height * width);
+let perimeter = 2 * (height * width);
-console.log(temp);
+console.log(perimeter);
-temp = height * width;
+area = height * width;
-console.log(temp);
+console.log(area);
```
## 배경
변수는 다양한 용도로 쓰인다. 그 중 변수에 값을 여러 번 대입할 수 밖에 없는 경우도 있다. 예컨데 루프 변수(`loop variable`)는 반복문을 한 번 돌 때마다 값이 바뀐다.
``` javascript
for (let i = 0; i < 10; i++)
// 여기서 i 변수가 루프 변수(loop variable)이다.
```
수집 변수(`collecting variable`)는 메서드가 동작하는 중간중간 값을 저장한다.

그 외에도 변수는 긴 코드의 결과를 저장했다가 나중에 쉽게 참조하려는 목적으로 흔히 쓰인다. 이런 변수는 값을 단 한 번만 대입해야 한다. 대입이 두 번 이상 이뤄진다면 여러 가지 역할을 수행한다는 신호다. 역할이 둘 이상인 변수가 있다면 쪼개야 한다. 예외는 없다. 역할 하나당 변수 하나다. 여러 용도로 쓰인 변수는 코드를 읽는 이에게 커다란 혼란을 주기 때문이다.
## 절차
### (1)
변수를 선언한 곳과 값을 처음 대입하는 곳에서 변수 이름을 바꾼다.
> 이후의 대입이 항상 `i = i + <무언가>` 형태라면 수집 변수이므로 쪼개면 안 된다. 수집 변수는 총합 계산, 문자열 연결, 스트림에 쓰기, 컬렉션에 추가히기 등의 용도로 흔히 쓰인다.
### (2)
가능하면 이때 불변(`immutable`)으로 선언한다.
### (3)
이 변수에 두 번째로 값을 대입하는 곳 앞까지의 모든 참조(이 변수가 쓰인 곳)를 새로운 변수 이름으로 바꾼다.
### (4)
두 번째 대입 시 변수를 원래 이름으로 다시 선언한다.
### (5)
테스트한다.
### (6)
반복한다. 매 반복에서 변수를 새로운 이름으로 선언하고 다음 번 대입 때까지의 모든 참조를 새 변수명으로 바꾼다. 이 과정을 마지막 대입까지 반복한다.
## 예시
이번 예에서는 해기스(`haggis`:양의 내장으로 만든 스코틀랜드 음식으로 순대와 비슷하다)라는 음식이 다른 지역으로 전파된 거리를 구하는 코드를 살펴볼 것이다. 해기스가 발상지에서 초기 힘을 받아 일정한 가속도로 전파되다가, 시간이 흐른 후 어떠한 계기로 두 번째 힘을 받아 전파 속도가 빨라진다고 가정해보자. 이를 일반적인 물리 법칙을 적용해 전파 거리를 다음과 같이 계산했다.
``` javascript
function distanceTravelled (scenario, time) {
  let result;
  let acc = scenario.primaryForce / scenario.mass; // 가속도(a) = 힘(F) / 질량(m)
  let primaryTime = Math.min(time, scenario.delay);
  result = 0.5 * acc * primaryTime * primaryTime; // 전파된 거리
  let secondaryTime = time - scenario.delay;
  if (secondaryTime > 0) { // 두 번째 힘을 반영해 다시 계산
    let primaryVelocity = acc * scenario.delay;
    acc = (scenario.primaryForce + scenario.secondaryForce) / scenario.mass;
    result += primaryVelocity * secondaryTime + 0.5 * acc * secondaryTime * secondaryTime;
  }
  return result;
}
```
괜찮아 보이는 작은 함수가 만들어졌다. 이 예시에서 흥미로운 부분은 `acc` 변수에 값이 두 번 대입된다는 점이다. 역할이 두 개라는 신호다. 하나는 첫 번째 힘이 유발한 초기 가속도를 저장하는 역할이고, 다른 하나는 두 번째 힘까지 반영된 후의 가속도를 저장하는 역할이다. 쪼개야 할 변수다.
> 함수나 파일에서 특정 심벌이 쓰인 위치를 시각적으로 강조해주는 코드 편집기를 사용하면 변수의 쓰임을 분석하는데 도움이 된다. 물론 요즘 편집기들은 대부분 지원한다.

첫 단계로 [(1)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter09/9-1.md#1) 변수에 새로운 이름을 지어주고, [(2)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter09/9-1.md#2) 선언 시 `const`를 붙여 불변으로 만든다. [(3)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter09/9-1.md#3) 그런 다음 두 번째 대입 전까지 모든 참조를 새로운 이름으로 바꾼다. [(4)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter09/9-1.md#4) 그리고 두 번째로 대입할 때 변수를 다시 선언한다.

``` diff
function distanceTravelled (scenario, time) {
  let result;
- let acc = scenario.primaryForce / scenario.mass; // 가속도(a) = 힘(F) / 질량(m)
+ const primaryAcceleration = scenario.primaryForce / scenario.mass; // (1)(2)
  let primaryTime = Math.min(time, scenario.delay);
- result = 0.5 * acc * primaryTime * primaryTime; // 전파된 거리
+ result = 0.5 * primaryAcceleration * primaryTime * primaryTime; // (3)
  let secondaryTime = time - scenario.delay;
  if (secondaryTime > 0) { // 두 번째 힘을 반영해 다시 계산
-   let primaryVelocity = acc * scenario.delay;
+   let primaryVelocity = primaryAcceleration * scenario.delay; // (3)
-   acc = (scenario.primaryForce + scenario.secondaryForce) / scenario.mass;
+   let acc = (scenario.primaryForce + scenario.secondaryForce) / scenario.mass;
    result += primaryVelocity * secondaryTime + 0.5 * acc * secondaryTime * secondaryTime;
  }
  return result;
}
```
수정한 코드를 보면 [(1)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter09/9-1.md#1)에서 변수의 첫 번째 용도만을 대표하는 이름을 선택했음을 알 수 있다. 그리고 `const`로 선언해서 값을 다시 대입하지 못하도록 했다. 그리고 두 번째 대입하는 곳 [(4)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter09/9-1.md#4)에서 변수를 원래 이름으로 다시 선언했다. [(5)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter09/9-1.md#5) 이제 컴파일하여 테스트해보자. 잘 동작해야 한다.

[(6)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter09/9-1.md#6) 두 번째 대입을 처리할 차례다. 이번에는 두 번째 용도에 적합한 이름으로 수정하므로 이 변수의 원래 이름은 완전히 사라지게 된다,
``` diff
function distanceTravelled (scenario, time) {
  let result;
  const primaryAcceleration = scenario.primaryForce / scenario.mass; // (1)(2)
  let primaryTime = Math.min(time, scenario.delay);
  result = 0.5 * primaryAcceleration * primaryTime * primaryTime; // (3)
  let secondaryTime = time - scenario.delay;
  if (secondaryTime > 0) { // 두 번째 힘을 반영해 다시 계산
    let primaryVelocity = primaryAcceleration * scenario.delay; // (3)
-   let acc = (scenario.primaryForce + scenario.secondaryForce) / scenario.mass;
+   const secondAcceleration = (scenario.primaryForce + scenario.secondaryForce) / scenario.mass;
-   result += primaryVelocity * secondaryTime + 0.5 * acc * secondaryTime * secondaryTime;
+   result += primaryVelocity * secondaryTime + 0.5 * secondAcceleration * secondaryTime * secondaryTime;
  }
  return result;
}
```
이 외에도 리팩터링할 만한 곳이 많이 보일 것이다. 한번 해보기 바란다. 해기스 시식보다는 분명 재미난 도전일 것이다.
## 예시: 입력 매개변수의 값을 수정할 때
변수 쪼개기의 또 다른 예로 입력 매개변수를 생각해 볼 수 있다(매개변수도 변수다). 다음 코드를 보자.
``` javascript
function discount(inputValue, quantity) {
  if (inputValue > 50) inputValue = inputValue - 2;
  if (quantity > 100) inputValue = inputValue - 2;
  return inputValue;
}
```
여기서 `inputValue`은 함수에 데이터를 전달하는 용도와 결과를 호출자에게 반환하는 용도로 쓰였다.(자바스크립트의 매개변수는 값에 의한 호출(`call-by-value`) 방식으로 전달되므로 `inputValue`를 수정해도 호출자에 영향을 주지 않는다).

이 상황이라면 먼저 다음과 같이 `inputValue`를 쪼개야 한다.
``` diff
-function discount(inputValue, quantity) {
+function discount(originalInputValue, quantity) {
+ let inputValue = originalINputValue;
  if (inputValue > 50) inputValue = inputValue - 2;
  if (quantity > 100) inputValue = inputValue - 2;
  return inputValue;
}
```
그런 다음 [6.7 변수 이름 바꾸기(Rename Variable)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-7.md)를 두 번 수행해서 각각의 쓰임에 어울리는 이름을 지어준다.
``` diff
-function discount(originalInputValue, quantity) {
+function discount(inputValue, quantity) {  
- let inputValue = originalINputValue;
+ let result = inputValue;
- if (inputValue > 50) inputValue = inputValue - 2;
+ if (inputValue > 50) result = result - 2;
- if (quantity > 100) inputValue = inputValue - 2;
+ if (quantity > 100) result = result - 2;
- return inputValue;
+ return result;
}
```
첫 번째 if문에서 (`result`가 아닌) `inputValue`와 비교하도록 수정한 게 보일 것이다. 사실 어떤 변수를 써도 똑같이 동작하지만, 이 코드가 입력 값에 기초하여 결과값을 누적해 계산한다는 사실을 더 명확히 드러낸 것이다.

- [목차](https://github.com/wonder13662/refactoring-v2/blob/writing)
- [8 기능이동](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08)
- [8.9 죽은 코드 제거하기(Remove Dead Code)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-9.md)
- [9 데이터 조직화](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter09)
- [9.2 필드 이름 바꾸기(Rename Field)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter09/9-2.md)
