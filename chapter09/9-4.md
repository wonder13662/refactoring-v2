### 9.4 참조를 값으로 바꾸기(Change Reference to Value)
``` diff
class Product {
  applyDiscount(arg) { 
-   this._price.amount -= arg;
+   this._price = new Money(this._price.amount - arg, this._price.currency);
  }
}
```

#### 배경
객체(데이터 구조)를 다른 객체(데이터 구조)에 중첩하면 내부 객체를 참조 혹은 값으로 취급할 수 있다. 참조냐 값이냐의 차이는 내부 객체의 속성을 갱신하는 방식에서 가장 극명하게 드러난다. 
1. 참조로 다루는 경우에는 내부 객체는 그대로 둔 채 그 객체의 속성만 갱신한다.
2. 값으로 다루는 경우에는 새로운 속성을 담은 객체로 기존 내부 객체를 통째로 대체한다.

필드를 값으로 다룬다면 내부 객체의 클래스를 수정하여 값 객체(`Value Object`)로 만들 수 있다. 값 객체는 대체로 자유롭게 활용하기 좋은데, 특히 불변이기 때문이다. 일반적으로 불변 데이터 구조는 다루기 더 쉽다. 불변 데이터 값은 프로그램 외부로 건네줘도 나중에 그 값이 나 몰래 바뀌어서 내부에 영향을 줄까 염려하지 않아도 된다. 값을 복제헤 이곳저곳에서 사용하더라도 서로 간의 참조를 관리하지 않아도 된다. 그래서 값 객체는 분산 시스템과 동시성 시스템에서 특히 유용하다.

한편 값 객체의 이런 특성 때문에 이번 리팩터링을 적용하면 안 되는 상황도 있다. 예컨대 특정 객체를 여러 객체에서 공유하고자 한다면, 그래서 공유 객체의 값을 변경했을 때 이를 관련 객체 모두에 알려줘야 한다면 공유 객체를 참조로 다뤄야 한다.
#### 절차
##### (1)
후보 클래스가 불변인지, 혹은 불변이 될 수 있는지 확인한다.
##### (2)
각각의 세터를 하나씩 [11.7 세터 제거하기(Remove Setting Method)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-7.md) 한다.
##### (3)
이 값 객체의 필드들을 사용하는 동치성(`equality`) 비교 메서드를 만든다.
> 대부분의 언어는 이런 상황에 사용할 수 있도록 오버라이딩 가능한 동치성 비교 메서드를 제공한다. 동치성 비교 메서드를 오버라이드할 때는 보통 해시코드 생성 메서드도 함께 오버라이드한다.

#### 예시
사람(`person`) 객체가 있고, 이 객체는 다음 코드처럼 생성 시점에는 전화번호가 올바로 설정되지 못하게 짜여 있다고 해보자.
``` javascript
class Person {
  constructor() {
    this._telephoneNumber = new TelephoneNumber();
  }

  get officeAreaCode() {
    return this._telephoneNumber.areaCode;
  }
  set officeAreaCode() {
    this._telephoneNumber.areaCode = arg;
  }
  get officeNumber() {
    return this._telephoneNumber.number;
  }
  set officeNumber() {
    this._telephoneNumber.number = arg;
  }
}

class TelephoneNumber {
  get areaCode() {
    return this._areaCode;
  }
  set areaCode(arg) {
    this._areaCode = arg;
  }
  get number() {
    return this._number;
  }
  set number(arg) {
    this._number = arg;
  }
}
```
[7.5 클래스 추출하기(Extract Class)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-5.md)를 하다보면 종종 이런 상황이 벌어지곤 한다. 추출해서 새로 만들어진 객체(이 예에서는 `TelephoneNumber`)를 갱신하는 메서드들은 여전히 추출 전 클래스(이 예에서는 `Person`)에 존재할 것이다. 어쨌든 새 클래스를 가리키는 참조가 하나뿐이므로 참조를 값으로 바꾸기 좋은 상황이다.

[(1)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter09/9-4.md#1) 가장 먼저 할 일은 전화번호를 불변으로 만들기다. [(2)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter09/9-4.md#2) 필드들의 세터들만 [11.7 세터 제거하기(Remove Setting Method)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-7.md) 하면 된다. 세터 제거의 첫 단계로, 세터로 설정하던 두 필드를 생성자에서 입력받아 설정하도록 한다([6.5 함수 선언 바꾸기(Change Function Declaration)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-5.md))
``` diff
class Person {
  constructor() {
    this._telephoneNumber = new TelephoneNumber();
  }

  get officeAreaCode() {
    return this._telephoneNumber.areaCode;
  }
  set officeAreaCode() {
    this._telephoneNumber.areaCode = arg;
  }
  get officeNumber() {
    return this._telephoneNumber.number;
  }
  set officeNumber() {
    this._telephoneNumber.number = arg;
  }
}

class TelephoneNumber {
+ constructor(areaCode, number) {
+   this._areaCode = areaCode;
+   this._number = number;
+ }
  get areaCode() {
    return this._areaCode;
  }
  set areaCode(arg) {
    this._areaCode = arg;
  }
  get number() {
    return this._number;
  }
  set number(arg) {
    this._number = arg;
  }
}
```
이제 세터를 호출하는 쪽을 살펴서 전화번호를 매번 다시 대입하도록 바꿔야 한다. 지역 코드(`area code`)부터 바꿔보자.
``` diff
class Person {
  constructor() {
    this._telephoneNumber = new TelephoneNumber();
  }

  get officeAreaCode() {
    return this._telephoneNumber.areaCode;
  }
- set officeAreaCode() {
+ set officeAreaCode(arg) {  
-   this._telephoneNumber.areaCode = arg;
+   this._telephoneNumber = new TelephoneNumber(arg, this.officeNumber);
  }
  get officeNumber() {
    return this._telephoneNumber.number;
  }
  set officeNumber() {
    this._telephoneNumber.number = arg;
  }
}

class TelephoneNumber {
  constructor(areaCode, number) {
    this._areaCode = areaCode;
    this._number = number;
  }
  get areaCode() {
    return this._areaCode;
  }
  set areaCode(arg) {
    this._areaCode = arg;
  }
  get number() {
    return this._number;
  }
  set number(arg) {
    this._number = arg;
  }
}
```
나머지 필드에도 같은 작업을 해준다.
``` diff
class Person {
  constructor() {
    this._telephoneNumber = new TelephoneNumber();
  }

  get officeAreaCode() {
    return this._telephoneNumber.areaCode;
  }
  set officeAreaCode(arg) {  
    this._telephoneNumber = new TelephoneNumber(arg, this.officeNumber);
  }
  get officeNumber() {
    return this._telephoneNumber.number;
  }
- set officeNumber() {
+ set officeNumber(arg) {
-   this._telephoneNumber.number = arg;
+   this._telephoneNumber = new TelephoneNumber(this.officeAreaCode, arg);
  }
}

class TelephoneNumber {
  constructor(areaCode, number) {
    this._areaCode = areaCode;
    this._number = number;
  }
  get areaCode() {
    return this._areaCode;
  }
  set areaCode(arg) {
    this._areaCode = arg;
  }
  get number() {
    return this._number;
  }
  set number(arg) {
    this._number = arg;
  }
}
```
[(3)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter09/9-4.md#3) 이제 전화번호는 불변이 되었으니, 진짜 값이 될 준비가 끝났다. 값 객체로 인정받으려면 동치성을 값 기반으로 평가해야 한다. 이 점에서 자바스크립트는 살짝 아쉬운데, 자바스크립트는 참조 기반 동치성을 값 기반 동치성으로 대체하는 일과 관련하여 언어나 핵심 라이브러리 차원에서 지원해주는 게 없다. 내가 생각해낸 최선의 방법은 `equals` 메서드를 직접 작성하는 것이다. 다음과 같이 테스트해주는 것도 잊으면 안된다.
``` diff
class Person {
  constructor() {
    this._telephoneNumber = new TelephoneNumber();
  }

  get officeAreaCode() {
    return this._telephoneNumber.areaCode;
  }
  set officeAreaCode(arg) {  
    this._telephoneNumber = new TelephoneNumber(arg, this.officeNumber);
  }
  get officeNumber() {
    return this._telephoneNumber.number;
  }
  set officeNumber(arg) {
    this._telephoneNumber = new TelephoneNumber(this.officeAreaCode, arg);
  }
}

class TelephoneNumber {
  constructor(areaCode, number) {
    this._areaCode = areaCode;
    this._number = number;
  }
  get areaCode() {
    return this._areaCode;
  }
  set areaCode(arg) {
    this._areaCode = arg;
  }
  get number() {
    return this._number;
  }
  set number(arg) {
    this._number = arg;
  }
+ equals(other) {
+   if (!(other instanceof TelephoneNumber)) return false;
+   return this.areaCode === other.areaCode && this.number === other.number;
+ }
}

+it('telephone equals', function() {
+ assert(new TelephoneNumber('312', '555-0142').equals(new TelephoneNumber('312', '555-0142')));
+})
```
코드 포맷팅이 좀 독특한데, 똑같은 생성자를 호출했음을 보여주고자 일부러 이렇게 했다. 이 테스트의 핵심은 독립된 객체를 두 개 생성하여 동치성 검사를 수행했다는 점이다.
> 대부분의 객체 지향 언어는 값 기반 동치성 비교를 할 수 있도록 오버라이드 가능한 동치성 검사 수단을 기본으로 제공한다. 루비에서는 == 연산자를 오버라이드하면 되고, 자바에서는 Object.equals() 메서드를 오버라이드하면 된다. 그리고 동치성 검사 메서드를 오버라이드할 때는 해시코드 생성 메서드도 함께 오버라이드해야 하는 게 보통이다(자바에서는 Object.hashCode() 메서드). 그래야 해시 기반으로 동작하는 컬렉션이 새로 만든 값도 문제없이 다룰 수 있다.

전화번호를 사용하는 곳이 둘 이상이라도 절차는 똑같다. [11.7 세터 제거하기(Remove Setting Method)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-7.md) 할 때 해당 사용처 모두를 수정하면 된다. 번호가 다른 전화번호들로 비교해보고, 유효하지 않은 번호나 `null`값과도 비교해보면 좋다.