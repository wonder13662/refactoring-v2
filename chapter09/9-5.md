# 9.5 값을 참조로 바꾸기(Change Value to Reference)
``` diff
-let customer = new Customer(customerData);
+let customer = customerRepository.get(customerData.id);
```
## 배경
하나의 데이터 구조 안에 논리적으로 똑같은 제 3의 데이터 구조를 참조하는 레코드가 여러 개 있을 때가 있다. 예컨대 주문 목록을 읽다 보면 같은 고객이 요청한 주문이 여러 개 섞여 있을 수 있다. 이때 고객을 값으로도, 혹은 참조로도 다룰 수 있다. 값으로 다룬다면, 고객 데이터가 각 주문에 복사되고, 참조로 다룬다면 여러 주문이 단 하나의 데이터 구조를 참조하게 된다.

고객 데이터를 갱신할 일이 없다면 어느 방식이든 상관없다. 같은 데이터를 여러 벌 복사하는게 조금 꺼림칙할지 모르지만, 별달리 문제되는 경우는 많지 않아서 흔히 사용하는 방식이다. 복사본이 많이 생겨서 가끔은 메모리가 부족할 수도 있지만, 다른 성능 이슈와 마찬가지로 아주 드문 일이다.

논리적으로 같은 데이터를 물리적으로 복제해 사용할 때 가장 크게 문제되는 상황은 그 데이터를 갱신해야 할 때다. 모든 복제본을 찾아서 빠짐없이 갱신해야 하며, 하나라도 놓치면 데이터 일관성이 깨져버린다. 이런 상황이라면 복제된 데이터들을 모두 참조로 바꿔주는 게 좋다. 데이터가 하나면 갱신된 내용이 해당 고객의 주문 모두에 곧바로 반영되기 때문이다.

값을 참조로 바꾸면 엔티티(`entity`) 하나당 객체도 단 하나만 존재하게 되는데, 그러면 보통 이런 객체들을 한데 모아놓고 클라이언트들의 접근을 관리해주는 일종의 저장소가 필요해진다. 각 엔티티를 표현하는 객체를 한번만 만들고, 객체가 필요한 곳에는 모두 이 저장소로부터 얻어 쓰는 방식이 된다.
## 절차
### (1)
같은 부류에 속하는 객체들을 보관할 저장소를 만든다(이미 있다면 생략).
### (2)
생성자에서 이 부류의 객체들 중 특정 객체를 정확히 찾아내는 방법이 있는지 확인한다.
### (3)
호스트 객체의 생성자들을 수정하여 필요한 객체를 이 저장소에서 찾도록 한다. 하나 수정할 때마다 테스트한다.
## 예시
주문(`order`) 클래스를 준비했다. 이 클래스는 주문 데이터를 생성자에서 JSON 문서로 입력받아 필드들을 채운다. 이 과정에서 주문 데이터에 포함된 고객 ID를 사용해 고객(`customer`) 객체를 생성한다.
``` javascript
class Order {
  constructor(data) {
    this._number = data.number;
    this._customer = new Customer(data.customer); // data.customer가 고객 ID
    // 다른 데이터를 읽어 들인다.
  }

  get customer() { return this._customer; }
}

class Customer {
  constructor(id) {
    this._id = id;
  }

  get id() { return this._id; }
}
```

이런 방식으로 생성한 고객 객체는 값이다. 고객 ID가 123인 주문을 다섯 개 생성한다면 독립된 고객 객체가 다섯 개 만들어진다. 이 중 하나를 수정하더라도 나머지 네 개에는 반영되지 않는다. 이 상황에서, 예컨대 고객 서비스에서 얻어온 데이터를 고객 객체에 추가해야 한다면 다섯 객체 모두를 같은 값으로 갱신해야 한다. 이처럼 객체가 중복해서 만들어지는 상황은 항상 내 신경을 곤두세운다. 이번 예처럼 같은 엔티티를 표현하는 객체가 여러 개 만들어지면 혼란이 생긴다. 설상가상으로 이 객체가 불변이 아니라면 일관성이 깨질 수 있어서 다루기가 더욱 까다로운 문제로 돌변한다.[(1)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter09/9-5.md#1) 항상 물리적으로 똑같은 고객 객체를 사용하고 싶다면 먼저 이 유일한 객체를 저장해둘 곳이 있어야 한다. 객체를 어디에 저장해야 할 지는 애플리케이션에 따라 다르겠지만, 간단한 상황이라면 나는 저장소 객체(`repository object`)를 사용하는 편이다.
``` javascript
let _repositoryData;

export function initialize() {
  _repositoryData = {};
  _repositoryData.customers = new Map();
}

export function registerCustomer(id) {
  if (!_repositoryData.customers.has(id))
    _repositoryData.customers.set(id, new Customer(id));
  return findCustomer(id);
}

export function findCustomer(id) {
  return _repositoryData.customer.get(id);
}
```
이 저장소는 고객 객체를 ID와 함께 등록할 수 있으며, ID 하나당 오직 하나의 고객 객체만 생성됨을 보장한다. 저장소가 준비되었으니, 이제 주문 클래스의 생성자가 이 저장소를 사용하도록 수정할 수 있다.

쓸만한 저장소가 이미 존재할 때도 왕왕 있는데, 그렇다면 그저 그 저장소를 사용하기만 하면 된다.[(2)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter09/9-5.md#2)다음 단계로는 주문의 생성자에서 올바른 고객 객체를 얻어오는 방법을 강구해야 한다. 이번 예에서는 고객 ID가 입력 데이터 스트림으로 전달되니 쉽게 해결할 수 있다.[(3)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter09/9-5.md#2) 수정해보자.
``` diff
class Order {
  constructor(data) {
    this._number = data.number;
-   this._customer = new Customer(data.customer);
+   this._customer = registerCustomer(data.customer);
    // 다른 데이터를 읽어 들인다.
  }

  get customer() { return this._customer; }
}

class Customer {
  constructor(id) {
    this._id = id;
  }

  get id() { return this._id; }
}
```
이제 특정 주문과 관련된 고객 정보를 갱신하면 같은 고객을 공유하는 주문 모두에서 갱신된 데이터를 사용하게 된다.

이 예에서는 특정 고객 객체를 참조하는 첫 번째 주문에서 해당 고객 객체를 생성했다. 또 다른 방법으로, 고객 목록을 미리 다 만들어서 저장소에 저장해놓고 주문 정보를 읽을 때 연결해주는 방법도 자주 사용한다. 이 방식에서는 저장소에 없는 고객 ID를 사용하는 주문에서는 오류가 난다. 

이 예시 코드는 생성자 본문이 전역 저장소와 결합된다는 문제가 있다. 전역 객체는 독한 약처럼 신중히 다뤄야 한다. 소량만 사용하면 이로울 수도 있지만 과용하면 독이 된다. 이 점이 염려된다면 저장소를 생성자 매개변수로 전달하도록 수정하자 - 의존성 주입(dependency injection) 중 생성자 주입을 말한다.

- [목차](https://github.com/wonder13662/refactoring-v2/blob/writing)
- [9 데이터 조직화](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter09)
- [9.4 참조를 값으로 바꾸기(Change Reference to Value)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter09/9-4.md)
- [9.6 매직 리터럴 바꾸기(Replace Magic Literal)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter09/9-6.md)