## Chapter 07 캡슐화

모듈을 분리하는 가장 중요한 기준은 아마도 시스템에서 각 모듈이 자신을 제외한 다른 부분에 드러내지 않아야 할 비밀을 얼마나 잘 숨기느냐에 있을 것이다. [On the criteria to be used in decomposing systems into modules](https://dl.acm.org/doi/10.1145/361598.361623) 이러한 비밀 중 대표적인 형태인 데이터 구조는 [7.1 레코드 캡슐화하기(Encapsulate Record)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-1.md)와 [7.2 컬렉션 캡슐화하기(Encapsulate Collection)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-2.md)로 캡슐화해서 숨길 수 있다. 심지어 기본형 데이터도 [7.3 기본형을 객체로 바꾸기(Replace Primitive with Object)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-3.md)로 캡슐화할 수 있다(이때 얻는 부차적인 효과는 왕왕 사람들을 놀라게 한다). 리팩터링할 때 임시 변수가 자주 걸리적거리는데, 정확한 순서로 계산해야 하고 리팩터링 후에도 그 값을 사용하는 코드에서 접근할 수 있어야 하기 때문이다. 이럴 때는 [7.4 임시 변수를 질의 함수로 바꾸기(Replace Temp with Query)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-4.md)가 상당히 도움이 된다. 특히 길이가 너무 긴 함수를 쪼개는 데 유용하다.

클래스는 본래 정보를 숨기는 용도로 설계되었다. 앞 장에서는 [6.9 여러 함수를 클래스로 묶기(Combine Functions into Class)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-9.md)로 클래스를 만드는 방법을 소개했다. 이 외에도 흔히 사용하는 추출하기/인라인하기 리팩터링의 클래스 버전인 [7.5 클래스 추출하기(Extract Class)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-5.md)와 [7.6 클래스 인라인하기(Inline Class)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-6.md)도 활용할 수 있다.

클래스는 내부 정보뿐 아니라 클래스 사이의 연결 관계를 숨기는 데도 유용하다. 이 용도로는 [7.7 위임 숨기기(Hide Delegate)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-7.md)가 있다. 하지만 너무 많이 숨기려다 보면 인터페이스가 비대해질 수 있으니 반대 기법인 [7.8 중개자 제거하기(Remove Middle Man)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-8.md)도 필요하다.

가장 큰 캡슐화 단위는 클래스와 모듈이지만 함수도 구현을 캡슐화한다. 때로는 알고리즘을 통째로 바꿔야 할 때가 있는데, [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md)로 알고리즘 전체를 함수 하나에 담은 뒤 [7.9 알고리즘 교체하기(Subtitute Algorithm)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-9.md)를 적용하면 된다.
