### 7.8 중개자 제거하기(Remove Middle Man)
반대 리팩터링: [7.7 위임 숨기기(Hide Delegate)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-7.md)
``` diff
-manager = aPerson.manager;
+manager = aPerson.department.manager;
class Person {
- get manager() { return this.department.manager; }
  get department() { return this.department; }
}
```
#### 배경
[7.7 위임 숨기기(Hide Delegate)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-7.md)의 [배경](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-7.md#%EB%B0%B0%EA%B2%BD) 절에서 위임 객체를 캡슐화하는 이점을 설명했다. 하지만 그 이점이 거저 주어지는 것은 아니다. 클라이언트가 위임 객체의 또 다른 기능을 사용하고 싶을 때마다 서버에 위임 에서드를 추가해야 하는데, 이렇게 기능을 추가하다 보면 단순히 전달만 하는 위임 메서드들이 점점 성가셔진다. 그러면 서버 클래스는 그저 중개자([middle man]()) 역할로 전락하여, 차라리 클라이언트가 위임 객체를 직접 호출하는 게 나을 수 있다. 어느 정도까지 숨겨야 적절한지를 판단하기란 쉽지 않지만, 우리에게는 다행히 [7.7 위임 숨기기(Hide Delegate)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-7.md)와 중개자 제거하기 리팩터링이 있으니, 크게 문제되지 않는다. 필요하면 언제든 균형점을 옮길 수 있으니 말이다. 시스템이 바뀌면 '적절하다'의 기준도 바뀌기 마련이다. 6개월 전에는 바람직했던 캡슐화가 이제는 어색할 수 있다.

#### 절차
##### 1. 위임 객체를 얻는 getter를 만든다.
##### 2. 위임 메서드를 호출하는 클라이언트가 모두 이 getter를 거치도록 수정한다. 하나씩 바꿀때마다 테스트한다.
##### 3. 모두 수정했다면 위임 메서드를 삭제한다.
- 자동 리팩터링 도구를 사용할 때는 위임 필드를 [6.6 변수 캡슐화하기(Encapsulate Variable)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-6.md)한 다음, 이를 사용하는 모든 메서드를 [6.2 함수 인라인하기(Inline Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-2.md)한다.

#### 예시
##### STEP 0
자신이 속한 부서(department) 객체를 통해 관리자(manager)를 찾는 사람(person) 클래스를 살펴보자
``` javascript
// 클라이언트
manager = aPerson.manager;
// Person 클래스
class Person {
  get manager() { return this._department.manager; }
}
// Department 클래스
class Department {
  get manager() { return this._manager; }
}
```
사용하기 쉽고 부서는 캡슐화되어 있다. 하지만 이런 위임 메서드가 많아지면 사람 클래스의 상당 부분이 그저 위임하는 데만 쓰일 것이다. 그럴 때는 중개자를 제거하는 편이 낫다.
##### STEP 1
[(1)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-8.md#1-%EC%9C%84%EC%9E%84-%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EC%96%BB%EB%8A%94-getter%EB%A5%BC-%EB%A7%8C%EB%93%A0%EB%8B%A4) 먼저 위임 객체(부서)를 얻는 getter를 만들자.
``` diff
// 클라이언트
manager = aPerson.manager;
// Person 클래스
class Person {
  get manager() { return this._department.manager; }
+ get department() { return this._department; }  
}
// Department 클래스
class Department {
  get manager() { return this._manager; }
}
```
##### STEP 2
[(2)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-8.md#2-%EC%9C%84%EC%9E%84-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A5%BC-%ED%98%B8%EC%B6%9C%ED%95%98%EB%8A%94-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EA%B0%80-%EB%AA%A8%EB%91%90-%EC%9D%B4-getter%EB%A5%BC-%EA%B1%B0%EC%B9%98%EB%8F%84%EB%A1%9D-%EC%88%98%EC%A0%95%ED%95%9C%EB%8B%A4-%ED%95%98%EB%82%98%EC%94%A9-%EB%B0%94%EA%BF%80%EB%95%8C%EB%A7%88%EB%8B%A4-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%9C%EB%8B%A4) 이제 각 클라이언트가 부서 객체를 직접 사용하도록 고친다. 
``` diff
// 클라이언트
-manager = aPerson.manager;
+manager = aPerson.department.manager;
// Person 클래스
class Person {
  get manager() { return this._department.manager; }
  get department() { return this._department; }  
}
// Department 클래스
class Department {
  get manager() { return this._manager; }
}
```
##### STEP 3
[(3)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-8.md#3-%EB%AA%A8%EB%91%90-%EC%88%98%EC%A0%95%ED%96%88%EB%8B%A4%EB%A9%B4-%EC%9C%84%EC%9E%84-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A5%BC-%EC%82%AD%EC%A0%9C%ED%95%9C%EB%8B%A4) 클라이언트를 모두 고쳤다면 `Person`의 `manager()` 메서드를 삭제한다. `Person`에 단순한 위임 메서드가 더는 남지 않을 때까지 이 작업을 반복한다.
``` diff
// 클라이언트
manager = aPerson.department.manager;
// Person 클래스
class Person {
- get manager() { return this._department.manager; }
  get department() { return this._department; }  
}
// Department 클래스
class Department {
  get manager() { return this._manager; }
}
```
[7.7 위임 숨기기(Hide Delegate)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-7.md)나 [7.8 중개자 제거하기(Remove Middle Man)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-8.md)를 적당히 섞어도 된다. 자주 쓰는 위임은 그대로 두는 편이 클라이언트 입장에서는 편하다. 둘 중 하나를 반드시 해야 한다는 법은 없다. 상황에 맞게 처리하면 되고, 합리적인 사람이라면 어떻게 해야 가장 효과적인지 판단할 수 있을 것이다.