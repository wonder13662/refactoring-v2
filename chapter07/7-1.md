### 7.1 레코드 캡슐화하기(Encapsulate Record)
``` diff
-organization = { name: "애크미 구스베리", country: "GB" }
+class Organization {
+ constructor() {
+   this._name = data.name;
+   this._country = data.country;
+ }
+ get name() { return this._name; }
+ set name() { this._name = arg; }
+ get country() { return this._country; }
+ set country() { this._country = arg; }
+}
```

#### 배경
대부분의 프로그래밍 언어는 데이터 레코드를 표현하는 구조를 제공한다. 레코드는 연관된 여러 데이터를 직관적인 방식으로 묶을 수 있어서 각각을 따로 취급할 때보다 훨씬 의미 있는 단위로 전달할 수 있게 해준다. 하지만 단순한 레코드에는 단점이 있다. 특히, 계산해서 얻을 수 있는 값과 그렇지 않은 값을 명확히 구분해 저장해야 하는 점이 번거롭다. 가령 값의 범위(range)를 표현하려면 `{ start: 1, end: 5 }`나 `{ start: 1, legnth: 5 }` (또는 필자의 스타일을 고집한다면 `{ end: 5, length: 5 }`)등의 방식으로 저장할 수 있다. 어떤 식으로 저장하든 '시작'과 '끝'과 '길이'를 알 수 있어야 한다.

바로 이 때문에 필자는 가변 데이터를 저장하는 용도로는 레코드보다 객체를 선호하는 편이다. 객체를 이용하면 어떻게 저장했는지를 숨긴 채 세 가지 값을 각각의 메서드로 제공할 수 있다. 사용자는 무엇이 저장된 값이고 무엇이 계산된 값인지 알 필요가 없다. 캡슐화하면 이름을 바꿀 때도 좋다. 필드 이름을 바꿔도 기존 이름과 새 이름 모두를 각각의 메서드로 제공할 수 있어서 사용자 모두가 새로운 메서드로 옮겨갈 때까지 점진적으로 수정할 수 있다.

나는 '가변' 데이터일 때 객체를 선호한다고 했다. 값이 불변이면 단순히 '시작'과 '끝'과 '길이'를 모두 구해서 레코드에 저장한다. 이름을 바꿀 때는 그저 필드를 복제한다. 그러면 앞서 객체를 활용해 수정 전후의 두 메서드를 동시에 제공한 방식과 비슷하게 점진적으로 수정할 수 있다.

레코드 구조는 두 가지로 구분할 수 있다. 하나는 필드 이름을 노출하는 형태고, 다른 하나는 (필드를 외부로부터 숨겨서) 내가 원하는 이름을 쓸 수 있는 형태다. 후자는 주로 라이브러리에서 해시(Hash), 맵(Map), 해시맵(Hashmap), 딕셔너리(Dictionary - 사전), 연관 배열(Association array)등의 이름으로 제공한다. 많은 프로그래밍 언어가 해시맵을 쉽게 만드는 문법을 제공한다. 해시맵은 다양한 프로그래밍 작업에 유용하지만, 필드를 명확히 알려주지 않는다는 게 단점이 될 수 있다. 범위를 { 시작, 끝 } 혹은 { 시작, 길이 } 중 어떤 방식으로 표현하는지 알아내는 유일한 길은 해시맵을 생성하고 사용하는 코드를 직접 확인하는 방법 뿐이다. 프로그램에서 해시맵을 쓰는 부분이 적다면 문제되지 않지만 사용하는 곳이 많을수록 불분명함으로 인해 발생하는 문제가 커진다. 이러한 불투명한 레코드를 명시적인 레코드로 리팩터링해도 되지만, 그럴 바에는 레코드 대신 클래스를 사용하는 편이 낫다.

코드를 작성하다 보면 중첩된 리스트나 해시맵을 받아서 JSON이나 XML 같은 포맷으로 직렬화(serialize)할 때가 많다. 이런 구조 역시 캡슐화할 수 있는데, 그러면 나중에 포맷을 바꾸거나 추적하기 어려운 데이터를 수정하기가 수월해진다.

#### 절차
##### (1) 레코드를 담은 변수를 [6.6 변수 캡슐화하기(Encapsulate Variable)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-6.md) 한다.
- 레코드를 캡슐화하는 함수의 이름은 검색하기 쉽게 지어준다.
##### (2) 레코드를 감싼 단순한 클래스로 해당 변수의 내용을 교체한다. 이 클래스에 원본 레코드를 반환하는 접근자도 정의하고, 변수를 캡슐화하는 함수들이 이 접근자를 사용하도록 수정한다.
##### (3) 테스트한다.
##### (4) 원본 레코드 대신 새로 정의한 클래스 타입의 객체를 반환하는 함수들을 새로 만든다.
##### (5) 레코드를 반환하는 예전 함수를 사용하는 코드를 [4]()에서 만든 함수를 사용하도록 바꾼다. 필드에 접근할 때는 객체의 접근자를 사용한다. 적절한 접근자가 없다면 추가한다. 한 부분을 바꿀 때마다 테스트한다.
- 중첩된 구조처럼 복잡한 레코드라면, 먼저 데이터를 갱신하는 클라이언트들에 주의해서 살펴본다.
##### (6) 클래스에서 원본 데이터를 반환하는 접근자와 ([1]()에서 검색하기 쉬운 이름을 붙여둔) 원본 레코드를 반환하는 함수들을 제거한다.
##### (7) 테스트한다.
##### (8) 레코드의 필드도 데이터 구조인 중첩 구조라면 [7.1 레코드 캡슐화하기(Encapsulate Record)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-1.md)와 [7.2 컬렉션 캡슐화하기(Encapsulate Collection)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-2.md)를 재귀적으로 적용한다.
#### 예시: 간단한 레코드 캡슐화하기
##### STEP 0
프로그램 전체에서 널리 사용되는 상수를 예로 살펴보자
``` javascript
const organization = { name: "애크미 구스베리", country: "GB" };
```
이 상수는 프로그램 곳곳에서 레코드 구조로 사용하는 자바스크립트 객체로서, 다음과 같이 읽고 쓴다.
``` javascript
// 클라이언트
result += `<h1>${organization.name}</h1>`; // 읽기 예
organization.name = newName; // 쓰기 예
```
##### STEP 1
[(1)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-1.md#1-%EB%A0%88%EC%BD%94%EB%93%9C%EB%A5%BC-%EB%8B%B4%EC%9D%80-%EB%B3%80%EC%88%98%EB%A5%BC-66-%EB%B3%80%EC%88%98-%EC%BA%A1%EC%8A%90%ED%99%94%ED%95%98%EA%B8%B0encapsulate-variable-%ED%95%9C%EB%8B%A4)가장 먼저 이 상수를 [6.6 변수 캡슐화하기(Encapsulate Variable)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-6.md) 해보자
``` diff
+function getRawDataOfOrganization() { return organization; }
```
그러면 읽고 쓰는 코드는 다음처럼 바뀐다.
``` diff
// 클라이언트
-result += `<h1>${organization.name}</h1>`; // 읽기 예
+result += `<h1>${getRawDataOfOrganization().name}</h1>`; // 읽기 예
-organization.name = newName; // 쓰기 예
+getRawDataOfOrganization().name = newName; // 쓰기 예
```
##### STEP 2
레코드를 캡슐화하는 목적은 변수 자체는 물론 그 내용을 조작하는 방식도 통제하기 위해서다. [(2)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-1.md#2-%EB%A0%88%EC%BD%94%EB%93%9C%EB%A5%BC-%EA%B0%90%EC%8B%BC-%EB%8B%A8%EC%88%9C%ED%95%9C-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A1%9C-%ED%95%B4%EB%8B%B9-%EB%B3%80%EC%88%98%EC%9D%98-%EB%82%B4%EC%9A%A9%EC%9D%84-%EA%B5%90%EC%B2%B4%ED%95%9C%EB%8B%A4-%EC%9D%B4-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%97%90-%EC%9B%90%EB%B3%B8-%EB%A0%88%EC%BD%94%EB%93%9C%EB%A5%BC-%EB%B0%98%ED%99%98%ED%95%98%EB%8A%94-%EC%A0%91%EA%B7%BC%EC%9E%90%EB%8F%84-%EC%A0%95%EC%9D%98%ED%95%98%EA%B3%A0-%EB%B3%80%EC%88%98%EB%A5%BC-%EC%BA%A1%EC%8A%90%ED%99%94%ED%95%98%EB%8A%94-%ED%95%A8%EC%88%98%EB%93%A4%EC%9D%B4-%EC%9D%B4-%EC%A0%91%EA%B7%BC%EC%9E%90%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8F%84%EB%A1%9D-%EC%88%98%EC%A0%95%ED%95%9C%EB%8B%A4)이렇게 하려면 레코드를 클래스로 바꾸고, [(4)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-1.md#4-%EC%9B%90%EB%B3%B8-%EB%A0%88%EC%BD%94%EB%93%9C-%EB%8C%80%EC%8B%A0-%EC%83%88%EB%A1%9C-%EC%A0%95%EC%9D%98%ED%95%9C-%ED%81%B4%EB%9E%98%EC%8A%A4-%ED%83%80%EC%9E%85%EC%9D%98-%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EB%B0%98%ED%99%98%ED%95%98%EB%8A%94-%ED%95%A8%EC%88%98%EB%93%A4%EC%9D%84-%EC%83%88%EB%A1%9C-%EB%A7%8C%EB%93%A0%EB%8B%A4)새 클래스의 인스턴스를 반환하는 함수를 새로 만든다.
``` diff
// Organization 클래스
+class Organization {
+ constructor(data) {
+   this._data = data;
+ }
+}
// 최상위
-const organization = { name: "애크미 구스베리", country: "GB" };
+const organization = new Organization({ name: "애크미 구스베리", country: "GB" });
-function getRawDataOfOrganization() { return organization; }
+function getRawDataOfOrganization() { return organization._data; }
+function getOrganization() { return organization; }
```
##### STEP 3
객체로 만드는 작업이 끝났으니 [(5)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-1.md#5-%EB%A0%88%EC%BD%94%EB%93%9C%EB%A5%BC-%EB%B0%98%ED%99%98%ED%95%98%EB%8A%94-%EC%98%88%EC%A0%84-%ED%95%A8%EC%88%98%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%BD%94%EB%93%9C%EB%A5%BC-4%EC%97%90%EC%84%9C-%EB%A7%8C%EB%93%A0-%ED%95%A8%EC%88%98%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8F%84%EB%A1%9D-%EB%B0%94%EA%BE%BC%EB%8B%A4-%ED%95%84%EB%93%9C%EC%97%90-%EC%A0%91%EA%B7%BC%ED%95%A0-%EB%95%8C%EB%8A%94-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EC%A0%91%EA%B7%BC%EC%9E%90%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C%EB%8B%A4-%EC%A0%81%EC%A0%88%ED%95%9C-%EC%A0%91%EA%B7%BC%EC%9E%90%EA%B0%80-%EC%97%86%EB%8B%A4%EB%A9%B4-%EC%B6%94%EA%B0%80%ED%95%9C%EB%8B%A4-%ED%95%9C-%EB%B6%80%EB%B6%84%EC%9D%84-%EB%B0%94%EA%BF%80-%EB%95%8C%EB%A7%88%EB%8B%A4-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%9C%EB%8B%A4)레코드를 사용하던 코드를 살펴보자. 레코드를 생긴하던 코드는 모두 세터를 사용하도록 고친다. 마찬가지로, 레코드를 읽는 코드는 모두 게터를 사용하게 바꾼다.
``` diff
// Organization 클래스
class Organization {
  constructor(data) {
    this._data = data;
  }
+ get name()   { return this._data.name; }
+ set name(aString)   { this._data.name = aString; }
}
// 클라이언트
const organization = new Organization({ name: "애크미 구스베리", country: "GB" });
function getRawDataOfOrganization() { return organization._data; }
function getOrganization() { return organization; }

-result += `<h1>${getRawDataOfOrganization().name}</h1>`; // 읽기 예
+result += `<h1>${getOrganization().name}</h1>`; // 읽기 예
-getRawDataOfOrganization().name = newName; // 쓰기 예
+getOrganization().name = newName; // 쓰기 예
```
##### STEP 4
[(6)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-1.md#6-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%97%90%EC%84%9C-%EC%9B%90%EB%B3%B8-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EB%B0%98%ED%99%98%ED%95%98%EB%8A%94-%EC%A0%91%EA%B7%BC%EC%9E%90%EC%99%80-1%EC%97%90%EC%84%9C-%EA%B2%80%EC%83%89%ED%95%98%EA%B8%B0-%EC%89%AC%EC%9A%B4-%EC%9D%B4%EB%A6%84%EC%9D%84-%EB%B6%99%EC%97%AC%EB%91%94-%EC%9B%90%EB%B3%B8-%EB%A0%88%EC%BD%94%EB%93%9C%EB%A5%BC-%EB%B0%98%ED%99%98%ED%95%98%EB%8A%94-%ED%95%A8%EC%88%98%EB%93%A4%EC%9D%84-%EC%A0%9C%EA%B1%B0%ED%95%9C%EB%8B%A4) 다 바꿨다면 앞에서 이상한 이름으로 지었던 임시 함수를 제거한다.
``` diff
// Organization 클래스
class Organization {
  constructor(data) {
    this._data = data;
  }
get name()   { return this._data.name; }
set name(aString)   { this._data.name = aString; }
}
// 클라이언트
const organization = new Organization({ name: "애크미 구스베리", country: "GB" });
-function getRawDataOfOrganization() { return organization._data; }
function getOrganization() { return organization; }

result += `<h1>${getOrganization().name}</h1>`; // 읽기 예
getOrganization().name = newName; // 쓰기 예
```

##### STEP 5
마지막으로 _data의 필드들을 객체 안에 바로 펼쳐놓으면 더 깔끔할 것 같다.
``` diff
// Organization 클래스
class Organization {
  constructor(data) {
-   this._data = data;
+   this._name = data.name;
+   this._country = data.country;
  }
-get name()   { return this._data.name; }
+get name()   { return this._name; }
-set name(aString)   { this._data.name = aString; }
+set name(aString)   { this._name = aString; }
+get country()   { return this._country; }
+set country(aCountryCode)   { return this._country = aCountryCode; }
}
// 클라이언트
const organization = new Organization({ name: "애크미 구스베리", country: "GB" });
function getOrganization() { return organization; }

result += `<h1>${getOrganization().name}</h1>`; // 읽기 예
getOrganization().name = newName; // 쓰기 예
```
이렇게 하면 입력 데이터 레코드와의 연결을 끊어준다는 이점이 생긴다. 특히 이 레코드를 참조하여 캡슐화를 깰 우려가 있는 코드가 많을 때 좋다. 데이터를 개별 필드로 펼치지 않았다면 `_data`를 대입할 때 복제하는 식으로 처리했을 것이다.