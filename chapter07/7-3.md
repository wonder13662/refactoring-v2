### 7.3 기본형을 객체로 바꾸기(Replace Primitive with Object)
``` diff
-orders.filter(o => "high" === o.priority || "rush" === o.priority);
+orders.filter(o => o.priority.higherThan(new Priority("normal")));
```
#### 배경
개발 초기에는 단순한 정보를 숫자나 문자열 같은 간단한 데이터 항목으로 표현할 때가 많다. 그러다 개발이 진행되면서 간단했던 이 정보들이 더 이상 간단하지 않게 변한다. 예컨대 처음에는 전화번호를 문자열로 표현했는데 나중에 포매팅이나 지역 코드 추출 같은 특별한 동작이 필요해질 수 있다. 이런 로직들로 금세 중복 코드가 늘어나서 사용할 때마다 드는 노력도 늘어나게 된다.

필자는 단순한 출력 이상의 기능이 필요해지는 순간 그 데이터를 표현하는 전용 클래스를 정의하는 편이다. 시작은 기본형 데이터를 단순히 감싼 것과 큰 차이가 없을 것이라 효과가 미미하다. 하지만 나중에 특별한 동작이 필요해지면 이 클래스에 추가하면 되니 프로그램이 커질수록 점점 유용한 도구가 된다. 그리 대단해 보이지 않을지 모르겠지만 코드베이스에 미치는 효과는 놀라울 만큼 크다. 초보 프로그래머에게는 직관에 어긋나 보일 수 있다. 하지만 경험 많은 개발자들은 여러 가지 리팩터링 중에서도 가장 유용한 것으로 손꼽는다.
#### 절차
##### (1) 아직 변수를 캡슐화하지 않았다면 [6.6 변수 캡슐화하기(Encapsulate Variable)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-6.md) 한다.
##### (2) 단순한 값 클래스(value class)를 만든다. 생성자는 기존 값을 인수로 받아서 저장하고, 이 값을 반환하는 getter를 추가한다.
##### (3) 정적 검사를 수행한다.
##### (4) 값 클래스의 인스턴스를 새로 만들어서 필드에 저장하도록 setter를 수정한다. 이미 있다면 필드의 타입을 적절히 변경한다.
##### (5) 새로 만든 클래스의 getter를 호출한 결과를 반환하도록 getter를 수정한다.
##### (6) 테스트한다.
##### (7) 함수 이름을 바꾸면([6.5 함수 선언 바꾸기(Change Function Declaration)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-5.md)) 원본 접근자의 동작을 더 잘 드러낼 수 있는지 검토한다.
- 참조를 값으로 바꾸거나([9.4 참조를 값으로 바꾸기(Change Reference to Value)](https://github.com/wonder13662/refactoring-v2/blob/writing/) 값을 참조로 바꾸면([9.5 값을 참조로 바꾸기(Change Value to Reference)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter09/9-5.md)) 새로 만든 객체의 역할(값 또는 참조 객체)이 더 잘 드러나는지 검토한다.
#### 예시
##### STEP 0
레코드 구조에서 데이터를 읽어 들이는 단순한 주문(order) 클래스를 살펴보자. 이 클래스의 우선 순위(priority) 속성은 값을 간단히 문자열로 표현한다. 클라이언트에서는 이 코드를 다음처럼 사용한다.
``` javascript
// Order 클래스
class Order {
  constructor(data) {
    this.priority = data.priority;
    // 나머지 초기화 코드 생략
  }
}
// 클라이언트
const highPriorityCount = orders.filter(o => "high" === o.priority || "rush" === o.priority).length;
```
##### STEP 1
[(1)]() 필자는 데이터 값을 다루기 전에 항상 [6.6 변수 캡슐화하기(Encapsulate Variable)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-6.md)를 한다.
``` diff
// Order 클래스
class Order {
  constructor(data) {
    this.priority = data.priority;
    // 나머지 초기화 코드 생략
  }
+ get priority() { return this._priority; }  
+ set priority(aString) { this._priority = aString; }
}
// 클라이언트
const highPriorityCount = orders.filter(o => "high" === o.priority || "rush" === o.priority).length;
```
이제 우선순위 속성을 초기화하는 생성자에서 방금 정의한 setter를 사용할 수 있다. 이렇게 필드를 자가 캡슐화(self-encapsulation)하면 필드 이름을 바꿔도 클라이언트 코드는 유지할 수 있다.
##### STEP 2
[(2)]() 다음으로 우선순위 속성을 표현하는 값 클래스 `Priority`를 만든다. 이 클래스는 표현할 값을 받는 생성자와 그 값을 문자열로 반환하는 변환 함수로 구성된다.
``` diff
// Order 클래스
class Order {
  constructor(data) {
    this.priority = data.priority;
    // 나머지 초기화 코드 생략
  }
  get priority() { return this._priority; }  
  set priority(aString) { this._priority = aString; }
}
// Priority 클래스
+class Priority {
+ constructor(value) { this._value = value }
+ toString() { return this._value; }
+}
// 클라이언트
const highPriorityCount = orders.filter(o => "high" === o.priority || "rush" === o.priority).length;
```
이 상황에서는 개인적으로 getter(`value()`)보다는 변환 함수)(`toString()`)를 선호한다. 클라이언트 입장에서 보면 속성 자체를 받은 게 아니라 해당 속성을 문자열로 표현한 값을 요청한 게 되기 때문이다.
##### STEP 3
[(4)]()[(5)]() 그런 다음 방금 만든 `Priority` 클래스를 사용하도록 접근자들을 수정한다.
``` diff
// Order 클래스
class Order {
  constructor(data) {
    this.priority = data.priority;
    // 나머지 초기화 코드 생략
  }
- get priority() { return this._priority; }
+ get priority() { return this._priority.toString(); }
- set priority(aString) { this._priority = aString; }
+ set priority(aString) { this._priority = new Priority(aString); }
}
// Priority 클래스
class Priority {
  constructor(value) { this._value = value }
  toString() { return this._value; }
}
// 클라이언트
const highPriorityCount = orders.filter(o => "high" === o.priority || "rush" === o.priority).length;
```
##### STEP 4
[(7)] 이렇게 `Priority` 클래스를 만들고 나면 `Order` 클래스의 getter가 이상해진다. 이 게터가 반환하는 값은 우선순위 자체가 아니라 우선순위를 표현하는 문자열이다. 그러니 즉시 함수 이름을 바꿔준다.([6.5 함수 선언 바꾸기(Change Function Declaration)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-5.md))
``` diff
// Order 클래스
class Order {
  constructor(data) {
    this.priority = data.priority;
    // 나머지 초기화 코드 생략
  }
- get priority() { return this._priority.toString(); }
+ get priorityString() { return this._priority.toString(); }
  set priority(aString) { this._priority = new Priority(aString); }
}
// Priority 클래스
class Priority {
  constructor(value) { this._value = value }
  toString() { return this._value; }
}
// 클라이언트
-const highPriorityCount = orders.filter(o => "high" === o.priority || "rush" === o.priority).length;
+const highPriorityCount = orders.filter(o => "high" === o.priorityString || "rush" === o.priorityString).length;
```
지금처럼 매개변수 이름만으로 setter가 받는 데이터의 유형을 쉽게 알 수 있다면 setter의 이름은 그대로 둬도 좋다.
##### STEP 5
공식적인 리팩터링은 여기까지다. 그런데 `Priority` 클래스를 사용하는 코드를 살펴보면서 이 클래스를 직접 사용하는 것이 과연 좋을지 고민해봤다. 그 결과 `Priority` 객체를 제공하는 getter를 `Order` 클래스에 만드는 편이 낫겠다고 판단했다.
``` diff
// Order 클래스
class Order {
  constructor(data) {
    this.priority = data.priority;
    // 나머지 초기화 코드 생략
  }
+ get priority() { return this._priority; }
  get priorityString() { return this._priority.toString(); }
  set priority(aString) { this._priority = new Priority(aString); }
}
// Priority 클래스
class Priority {
  constructor(value) { this._value = value }
  toString() { return this._value; }
}
// 클라이언트
-const highPriorityCount = orders.filter(o => "high" === o.priorityString || "rush" === o.priorityString).length;
+const highPriorityCount = orders.filter(o => "high" === o.priority.toString() || "rush" === o.priority.toString()).length;
```
##### STEP 6
`Priority` 클래스는 다른 곳에서도 유용할 수 있으니 `Order`의 setter가 `Priority` 인스턴스를 받도록 해주면 좋다. 이를 위해 `Priority`의 생성자를 다음과 같이 변경한다.
``` diff
// Order 클래스
class Order {
  constructor(data) {
    this.priority = data.priority;
    // 나머지 초기화 코드 생략
  }
  get priority() { return this._priority; }
  get priorityString() { return this._priority.toString(); }
  set priority(aString) { this._priority = new Priority(aString); }
}
// Priority 클래스
class Priority {
- constructor(value) { this._value = value }
+ constructor(value) {
+   if(value instanceOf Priority) return value;
+   this._value = value;
+ }
  toString() { return this._value; }
}
// 클라이언트
const highPriorityCount = orders.filter(o => "high" === o.priority.toString() || "rush" === o.priority.toString()).length;
```
이렇게 하는 목적은 어디까지나 `Priority` 클래스를 새로운 동작을 담는 장소로 활용하기 위해서다. 여기서 새로운 동작이란 새로 구현한 것일 수도, 다른 곳에서 옮겨온 것일 수도 있다. 
##### STEP 7
우선순위 값을 검증하고 비교하는 로직을 추가한 예를 준비했다.
``` diff
// Order 클래스
class Order {
  constructor(data) {
    this.priority = data.priority;
    // 나머지 초기화 코드 생략
  }
  get priority() { return this._priority; }
  get priorityString() { return this._priority.toString(); }
  set priority(aString) { this._priority = new Priority(aString); }
}
// Priority 클래스
class Priority {
  constructor(value) {
    if(value instanceOf Priority) return value;
-   this._value = value;    
+   if(Priority.legalValues().includes(value))
+     this._value = value;
+   else
+     throw new Error(`<${value}>는 유효하지 않은 우선순위입니다.`);
  }
  toString() { return this._value; }
+ get _index() { return Priority.legalValues().findIndex(s => s === this._value); }
+ static legalValues() { return ['low', 'normal', 'high', 'rush']; }
+ equals(other) { return this._index === other._index; }
+ higherThan(other) { return this._index > other._index; }
+ lowerThan(other) { return this._index < other._index; }
}
// 클라이언트
const highPriorityCount = orders.filter(o => "high" === o.priority.toString() || "rush" === o.priority.toString()).length;
```
이렇게 수정하면서 우선순위를 값 객체로 만들어야겠다고 판단했다. 따라서 `equals()`메서드를 추가하고 불변이 되도록 만들었다.
##### STEP 8
이처럼 동작을 추가하면 클라이언트 코드를 더 의미있게 작성할 수 있다.
``` diff
// Order 클래스
class Order {
  constructor(data) {
    this.priority = data.priority;
    // 나머지 초기화 코드 생략
  }
  get priority() { return this._priority; }
  get priorityString() { return this._priority.toString(); }
  set priority(aString) { this._priority = new Priority(aString); }
}
// Priority 클래스
class Priority {
  constructor(value) {
    if(value instanceOf Priority) return value;
    if(Priority.legalValues().includes(value))
      this._value = value;
    else
      throw new Error(`<${value}>는 유효하지 않은 우선순위입니다.`);
  }
  toString() { return this._value; }
  get _index() { return Priority.legalValues().findIndex(s => s === this._value); }
  static legalValues() { return ['low', 'normal', 'high', 'rush']; }
  equals(other) { return this._index === other._index; }
  higherThan(other) { return this._index > other._index; }
  lowerThan(other) { return this._index < other._index; }
}
// 클라이언트
-const highPriorityCount = orders.filter(o => "high" === o.priority.toString() || "rush" === o.priority.toString()).length;
+const highPriorityCount = orders.filter(o => o.priority.higherThan(new Priority("normal"))).length;
```