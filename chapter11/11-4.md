# 11.4 객체 통째로 넘기기(Preserve Whole Object)
``` diff
-const low = aRoom.daysTempRange.low;
-const high = aRoom.daysTempRange.high;
-if (aPlan.withinRange(low, high))
+if (aPlan.withinRange(aRoom.daysTempRange))
```

## 배경
하나의 레코드에서 값 두어 개를 가져와 인수로 넘기는 코드를 보면, 나는 그 값들 대신 레코드를 통째로 넘기고 함수 본문에서 필요한 값들을 꺼내 쓰도록 수정하곤 한다.

레코드를 통째로 넘기면 변화에 대응하기 쉽다. 예컨대 그 함수가 더 다양한 데이터를 사용하도록 바뀌어도 매개변수 목록은 수정할 필요가 없다. 그리고 매개변수 목록이 짧아져서 일반적으로는 함수 사용법을 이해하기 쉬워진다. 한편, 레코드에 담긴 데이터 중 일부를 받는 함수가 여러 개라면 그 함수들끼리는 같은 데이터를 사용하는 부분이 있을 것이고, 그 부분의 로직이 중복될 가능성이 커진다. 레코드를 통째로 넘긴다면 이런 중복도 없앨 수 있다.

하지만 함수가 레코드 자체에 의존하기를 원치 않을 때는 이 리팩터링을 수행하지 않는데, 레코드와 함수가 서로 다른 모듈에 속한 상황이면 특히 더 그렇다.

어떤 객체로부터 값 몇개를 얻은 후 그 값들만으로 무언가를 하는 로직이 있다면, 그 로직을 객체 안으로 집어넣어야 함을 알려주는 악취로 봐야 한다. 그래서 객체 통째로 넘기기는 특히 [6.8 매개변수 객체 만들기(Introduce Parameter Object)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-8.md) 후, 즉 산재한 수많은 데이터 더미를 새로운 객체로 묶은 후 적용하곤 한다.

한편, 한 객체가 제공하는 기능 중 항상 똑같은 일부만을 사용하는 코드가 많다면, 그 기능만 따로 묶어서 [7.5 클래스 추출하기(Extract Class)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-5.md)하라는 신호일 수 있다.

많은 사람이 놓치는 사례가 하나 더 있다. 다른 객체의 메서드를 호출하면서 호출하는 객체 자신이 가지고 있는 데이터 여러 개를 건네는 경우다. 이런 상황이면 여러 개 대신 객체 자신의 참조만 건네도록 수정할 수 있다(자바스크립트라면 `this`를 건넬 것이다).
## 절차
### (1)
매개변수들을 원하는 형태로 받는 빈 함수를 만든다.
- 마지막 단계에서 이 함수의 이름을 변경해야 하니 검색하기 쉬운 이름으로 지어준다.
### (2)
새 함수의 본문에서는 원래 함수를 호출하도록 하며, 새 매개변수와 원래 함수의 매개변수를 매핑한다.
### (3)
정적 검사를 수행한다.
### (4)
모든 호출자가 새 함수를 사용하게 수정한다. 하나씩 수정하며 테스트하자.
- 수정 후에는 원래의 매개변수를 만들어내는 코드 일부가 필요 없어질 수 있다. 따라서 [8.9 죽은 코드 제거하기(Remove Dead Code)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-9.md)로 없앨 수 있을 것이다.
### (5)
호출자를 모두 수정했다면 원래 함수를 [6.2 함수 인라인하기(Inline Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-2.md)한다.
### (6)
새 함수의 이름을 적절히 수정하고 모든 호출자에 반영한다.
## 예시
실내온도 모니터링 시스템을 생각해보자. 이 시스템은 일일 최저,최고 기온이 난방 계획(heating plan)에서 정한 범위를 벗어나는지 확인한다.
``` javascript
// 호출자
const low = aRoom.daysTempRange.low;
const high = aRoom.daysTempRange.high;
if (!aPlan.withinRange(low, high))
  alert.push("방 온도가 지정 범위를 벗어났습니다.")

class HeatingPlan {
  withinRange(bottom, top) {
    return (bottom >= this._temperatureRange.low) && (top <= this._temperatureRange.high);
  }
}
```
그런데 최저,최고 기온을 뽑아내어 인수로 건네는 대신 범위 객체를 통째로 건넬 수도 있다.
### STEP 1-1
[(1)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-4.md#1) 가장 먼저 원하는 인터페이스를 갖춘 빈 메서드를 만든다.
``` diff
// 호출자
const low = aRoom.daysTempRange.low;
const high = aRoom.daysTempRange.high;
if (!aPlan.withinRange(low, high))
  alert.push("방 온도가 지정 범위를 벗어났습니다.")

class HeatingPlan {
  withinRange(bottom, top) {
    return (bottom >= this._temperatureRange.low) && (top <= this._temperatureRange.high);
  }

+ xxNewwithinRange(aNumberRange) {
+ }
}

```
이 메서드로 기존 `withinRange()` 메서드를 대체할 생각이다. 그래서 똑같은 이름을 쓰되, 나중에 찾아 바꾸기 쉽도록 적당한 접두어만 붙여뒀다.
### STEP 1-2
[(2)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-4.md#2) 그런 다음 새 메서드의 본문은 기존 `withinRange()`를 호출하는 코드로 채운다. 자연스럽게 새 매개변수를 기존 매개변수와 매핑하는 로직이 만들어진다.
``` diff
// 호출자
const low = aRoom.daysTempRange.low;
const high = aRoom.daysTempRange.high;
if (!aPlan.withinRange(low, high))
  alert.push("방 온도가 지정 범위를 벗어났습니다.")

class HeatingPlan {
  withinRange(bottom, top) {
    return (bottom >= this._temperatureRange.low) && (top <= this._temperatureRange.high);
  }

  xxNewwithinRange(aNumberRange) {
+   return this.withinRange(aNumberRange.low, aNumberRange.high);    
  }
}
```
### STEP 1-3
이제 본격적인 작업을 시작할 준비가 되었다. [(3)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-4.md#3) 기존 함수를 호출하는 코드를 찾아서 새 함수를 호출하게 수정하자.
``` diff
// 호출자
const low = aRoom.daysTempRange.low;
const high = aRoom.daysTempRange.high;
-if (!aPlan.withinRange(low, high))
+if (!aPlan.xxNewwithinRange(aRoom.daysTempRange))
  alert.push("방 온도가 지정 범위를 벗어났습니다.")

class HeatingPlan {
  withinRange(bottom, top) {
    return (bottom >= this._temperatureRange.low) && (top <= this._temperatureRange.high);
  }

  xxNewwithinRange(aNumberRange) {
    return this.withinRange(aNumberRange.low, aNumberRange.high);    
  }
}
```
### STEP 1-4
[(4)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-4.md#4)이렇게 다 수정하고 나면 기존 코드 중 더는 필요 없는 부분이 생길 수 있다. 죽은 코드이니 [8.9 죽은 코드 제거하기(Remove Dead Code)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-9.md) 한다.
``` diff
// 호출자
-const low = aRoom.daysTempRange.low;
-const high = aRoom.daysTempRange.high;
if (!aPlan.xxNewwithinRange(aRoom.daysTempRange))
  alert.push("방 온도가 지정 범위를 벗어났습니다.")

class HeatingPlan {
  withinRange(bottom, top) {
    return (bottom >= this._temperatureRange.low) && (top <= this._temperatureRange.high);
  }

  xxNewwithinRange(aNumberRange) {
    return this.withinRange(aNumberRange.low, aNumberRange.high);    
  }
}
```
### STEP 1-5
[(5)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-4.md#5) 모두 새 함수로 대체했다면 원래 함수를 [6.2 함수 인라인하기(Inline Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-2.md) 해준다.
``` diff
// 호출자
if (!aPlan.xxNewwithinRange(aRoom.daysTempRange))
  alert.push("방 온도가 지정 범위를 벗어났습니다.")

class HeatingPlan {
  withinRange(bottom, top) {
    return (bottom >= this._temperatureRange.low) && (top <= this._temperatureRange.high);
  }

  xxNewwithinRange(aNumberRange) {
-   return this.withinRange(aNumberRange.low, aNumberRange.high);
+   return (bottom >= this._temperatureRange.low) && (top <= this._temperatureRange.high);
  }
}
```
### STEP 1-6
[(6)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-4.md#6) 마지막으로 새 함수에서 보기 흉한 접두어를 제거하고 호출자들에도 모두 반영한다. 접두어를 활용하면 이름 변경 기능을 제공하지 않는 코드 편집기를 사용하더라도 전체 바꾸기를 간단히 수행할 수 있다.
``` diff
// 호출자
-if (!aPlan.xxNewwithinRange(aRoom.daysTempRange))
+if (!aPlan.withinRange(aRoom.daysTempRange))
  alert.push("방 온도가 지정 범위를 벗어났습니다.")

class HeatingPlan {
- withinRange(bottom, top) {
-   return (bottom >= this._temperatureRange.low) && (top <= this._temperatureRange.high);
- }

- xxNewwithinRange(aNumberRange) {
+ withinRange(aNumberRange) {  
    return (bottom >= this._temperatureRange.low) && (top <= this._temperatureRange.high);
  }
}
```
## 예시: 새 함수를 다른 방식으로 만들기
앞 예시에서는 새 메서드(함수)의 코드를 직접 작성했는데, 대부분 상황에서 꽤나 간단하고 가장 쉽게 적용할 수 있는 방법이다. 그런데 다른 상황에서 유용하게 쓰이는 변형된 방법도 있다. 코드 작성 없이 순전히 다른 리팩터링들을 연달아 수행하여 새 메서드를 만들어내는 방법이다.

기존 메서드의 호출자부터 살펴보자.
``` javascript
// 호출자
const low = aRoom.daysTempRange.low;
const high = aRoom.daysTempRange.high;
if (!aPlan.withinRange(low, high))
  alert.push("방 온도가 지정 범위를 벗어났습니다.")

class HeatingPlan {
}
```
이번에는 코드를 재정렬해서 기조 코드 일부를 메서드로 추출하는 방식으로 새 메서드를 만들려 한다. 지금의 호출자 코드는 이에 적합하지 않지만, [6.3 변수 추출하기(Extract Variable)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-3.md)를 몇 번 적용하면 원하는 모습으로 둔갑한다. 
### STEP 2-1
먼저, 조건문에서 기존 메서드를 호출하는 코드들을 해방시켜 보자.
``` diff
// 호출자
const low = aRoom.daysTempRange.low;
const high = aRoom.daysTempRange.high;
+const isWithinRange = aPlan.withinRange(low, high);
-if (!aPlan.withinRange(low, high))
+if (isWithinRange)
  alert.push("방 온도가 지정 범위를 벗어났습니다.")

class HeatingPlan {
}
```
### STEP 2-2
그런 다음 입력 매개변수를 추출한다.
``` diff
// 호출자
+const tempRange = aRoom.daysTempRange;
-const low = aRoom.daysTempRange.low;
+const low = tempRange.low;
-const high = aRoom.daysTempRange.high;
+const high = tempRange.high;
const isWithinRange = aPlan.withinRange(low, high);
if (isWithinRange)
  alert.push("방 온도가 지정 범위를 벗어났습니다.")

class HeatingPlan {
}
```
### STEP 2-3
다 끝났으면 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md)로 새 메서드를 만들 수 있다.
``` diff
// 호출자
const tempRange = aRoom.daysTempRange;
-const low = tempRange.low;
-const high = tempRange.high;
-const isWithinRange = aPlan.withinRange(low, high);
+const isWithinRange = xxNEWwithinRange(aPlan, tempRange);
if (isWithinRange)
  alert.push("방 온도가 지정 범위를 벗어났습니다.")
// 최상위
+function xxNEWwithinRange(aPlan, tempRange) {
+ const low = tempRange.low;
+ const high = tempRange.high;
+ const isWithinRange = aPlan.withinRange(low, high);
+ return isWithinRange;
+}

class HeatingPlan {
}
```
### STEP 2-4
원래 메서드는 다른 컨텍스트(`HeatingPlan` 클래스 안)에 있으니 [8.1 함수 옮기기(Move Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-1.md)를 수행해야 한다.
``` diff
// 호출자
const tempRange = aRoom.daysTempRange;
-const isWithinRange = xxNEWwithinRange(aPlan, tempRange);
+const isWithinRange = aPlan.xxNEWwithinRange(tempRange);
if (isWithinRange)
  alert.push("방 온도가 지정 범위를 벗어났습니다.")
// 최상위
-function xxNEWwithinRange(aPlan, tempRange) {
- const low = tempRange.low;
- const high = tempRange.high;
- const isWithinRange = aPlan.withinRange(low, high);
- return isWithinRange;
-}

class HeatingPlan {
+ xxNEWwithinRange(tempRange) {
+   const low = tempRange.low;
+   const high = tempRange.high;
+   const isWithinRange = this.withinRange(low, high);
+   return isWithinRange;
+ }
}
```
그 다음은 앞 예시와 같다. 다른 호출자들을 수정한 다음 옛 메서드를 새 메서드 안으로 인라인한다. 추출한 변수들도 인라인해주면 새로 추출한 메서드를 깔끔히 분리할 수 있다. 

이 변형 방식은 순전히 리팩터링으로만 구성되므로 추출과 인라인 리팩터링을 지원하는 편집기를 이용하면 아주 손쉽게 수행할 수 있다.

- [목차](https://github.com/wonder13662/refactoring-v2/blob/writing)
- [11 API 리팩터링](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11)
- [11.3 플래그 인수 제거하기(Remove Flag Argument)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-3.md)
- [11.5 매개변수를 질의 함수로 바꾸기(Replace Parameter with Query)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-5.md)
