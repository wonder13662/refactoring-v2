### 11.9 함수를 명령으로 바꾸기(Replace Function with Command)
- 반대 리팩터링: [11.10 명령을 함수로 바꾸기(Replace Command with Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-10.md)
``` diff
-function score(candidate, medicalExam, scoringGuide) {
- let result = 0;
- let healthLevel = 0;
- // 긴 코드 생략
-}
+class Scorer {
+ constructor(candidate, medicalExam, scoringGuide) {
+   this._candidate = candidate;
+   this._medicalExam = medicalExam;
+   this._scoringGuide = scoringGuide;
+ }

+ execute() {
+   this._result = 0;
+   this._healthLevel = 0;
+   // 긴 코드 생략
+ }
+}
```

#### 배경
함수(독립된 함수든 객체에 소속된 메서드든)는 프로그래밍의 기본적인 빌딩 블록 중 하나다. 그런데 함수를 그 함수만을 위한 객체 안으로 캡슐화하면 더 유용해지는 상황이 있다. 이런 객체를 가리켜 '명령 객체' 혹은 단순히 '명령(command)'이라 한다. 명령 객체 대부분은 메서드 하나로 구성되며, 이 메서드를 요청해 실행하는 것이 이 객체의 목적이다.

명령은 평범한 함수 매커니즘보다 훨씬 유연하게 함수를 제어하고 표현할 수 있다. 명령은 되돌리기(undo) 같은 보조 연산을 제공할 수 있으며, 수명주기를 더 정밀하게 제어하는 데 필요한 매개변수를 만들어주는 메서드도 제공할 수 있다. 상속과 훅(hook)을 이용해 사용자 맞춤형으로 만들 수도 있다. 객체는 지원하지만 일급 함수(first-class function)를 지원하지 않는 프로그래밍 언어를 사용할 때는 명령을 이용해 일급 함수의 기능 대부분을 흉내 낼 수 있다. 비슷하게, 중첩 함수를 지원하지 않는 언어에서도 메서드와 필드를 이용해 복잡한 함수를 잘게 쪼갤 수 있고, 이렇게 쪼갠 메서드들을 테스트와 디버깅에 직접 이용할 수 있다.

이처럼 명령을 사용해 얻는 이점이 많으므로 함수를 명령으로 리팩터링할 채비를 갖춰야 할 것이다. 하지만 유연성은 (언제나 그렇듯) 복잡성을 키우고 얻는 대가임을 잊지 말아야 한다. 그래서 일급 함수와 명령 중 선택해야 한다면, 나라면 95%는 일급 함수의 손을 들어준다. 내가 명령을 선택할 때는 명령보다 더 간단한 방식으로는 얻을 수 없는 기능이 필요할 때 뿐이다.

> 소프트웨어 개발 용어 중에는 여러 가지 의미로 사용되는 게 많은데, '명령'도 마찬가지다. 지금 맥락에서의 명령은 요청을 캡슐화한 객체로, 디자인 패턴 중 명령 패턴(Command Pattern)에서 말하는 명령과 같다. 이 책에서 이 의미의 명령을 이야기할 때는 먼저 '명령 객체'라고 한번 언급해준 후 '명령'으로 줄여 쓸 것이다. 한편 [명령-질의 분리 원칙](https://martinfowler.com/bliki/CommandQuerySeparation.html)에서도 명령이 등장한다. 이 원칙에서의 명령은 객체의 겉보기 상태를 변경하는 메서드를 가리킨다. 이 책에서는 이 의미의 명령을 이야기할 때는 명령이라는 단어를 쓰지 않으려 노력할 것이다. 대신 '변경 함수(modifier 또는 mutator)'라 하겠다.

#### 절차
##### (1)
대상 함수의 기능을 옮길 빈 클래스를 만든다. 클래스 이름은 함수 이름에 기초해 짓는다.
##### (2)
방금 생성한 빈 클래스로 [8.1 함수 옮기기(Move Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-1.md) 한다.
- 리팩터링이 끝날 때까지는 원래 함수를 전달 함수 역할로 남겨두자.
- 명령 관련 이름은 사용하는 프로그래밍 언어의 명명규칙을 따른다. 규칙이 딱히 없다면 'execute'나 'call' 같이 명령의 실행 함수에 흔히 쓰이는 이름을 택하자.
##### (3)
함수의 인수들 각각은 명령의 필드로 만들어 생성자를 통해 설정할지 고민해본다.
#### 예시
자바스크립트는 허점이 많은 언어다. 하지만 함수를 일급으로 만든 선택은 아주 훌륭했다. 그래서 일급 함수를 지원하지 않는 언어에서라면 필요했을 일반적인 작업에는 굳이 명령을 만들어 해결할 이유가 없다. 하지만 명령을 사용하는 편이 나을 때가 없는 건 아니다.

예컨대 복잡한 함수를 잘게 쪼개서 이해하거나 수정하기 쉽게 만들고자 할 때가 있다. 그래서 사실 이 리팩터링의 가치를 잘 보여주려면 길고 복잡한 함수를 준비해야 한다. 하지만 그렇게 하면 책에 싣기에는 너무 길고 여러분이 읽기에도 불편할 것이므로 길이를 최소한으로 제한했다. 다음은 건강보험 애플리케이션에서 사용하는 점수 계산 함수다.
``` javascript
function score(candidate, medicalExam, scoringGuide) {
  let result = 0;
  let healthLevel = 0;
  let highMedicalRiskFlag = false;

  if (medicalExam.isSmoker) {
    healthLevel += 10;
    highMedicalRiskFlag = true;
  }

  let certificationGrade = 'regular';
  if (scoringGuide.stateWithLowCertification(candidate.originState)) {
    certificationGrade = 'low';
    result -= 5;
  }
  // 비슷한 코드가 한참 이어짐
  result -= Math.max(healthLevel - 5, 0);
  return result;
}
```
##### STEP 1
[(1)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-9.md#1) 시작은 빈 클래스를 만들고 [(2)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-9.md#2) 이 함수를 그 클래스로 [8.1 함수 옮기기(Move Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-1.md)는 일부터 시작한다.
``` diff
function score(candidate, medicalExam, scoringGuide) {
+ return new Scorer().execute(candidate, medicalExam, scoringGuide);
+}

+class Scorer {
+ execute(candidate, medicalExam, scoringGuide) {
    let result = 0;
    let healthLevel = 0;
    let highMedicalRiskFlag = false;

    if (medicalExam.isSmoker) {
      healthLevel += 10;
      highMedicalRiskFlag = true;
    }

    let certificationGrade = 'regular';
    if (scoringGuide.stateWithLowCertification(candidate.originState)) {
      certificationGrade = 'low';
      result -= 5;
    }
    // 비슷한 코드가 한참 이어짐
    result -= Math.max(healthLevel - 5, 0);
    return result;
+ }
}
```
주로 나는 명령이 받는 인수들을 생성자로 올겨서 `execute()` 메서드는 매개변수를 받지 않게 하는 편이다. 지금 예 정도의 단순한 시나리오에서는 큰 차이가 없지만, 명령의 수명주기나 사용자 정의 기능 등을 지원해야 해서 매개변수가 복잡할 때는 아주 편리하다. 예컨대 이 방식이라면 매개변수 목록이 서로 다른 여러 형태의 명령들을 하나의 실행 대기열(queue)을 통해 전달할 수도 있다.
##### STEP 2
매개변수 옮기기는 한 번에 하나씩 수행하자.
``` diff
function score(candidate, medicalExam, scoringGuide) {
- return new Scorer().execute(candidate, medicalExam, scoringGuide);
+ return new Scorer(candidate).execute(medicalExam, scoringGuide);
}

class Scorer {
+ constructor(candidate) {
+   this._candidate = candidate;
+ }

- execute(candidate, medicalExam, scoringGuide) {
+ execute(medicalExam, scoringGuide) {
    let result = 0;
    let healthLevel = 0;
    let highMedicalRiskFlag = false;

    if (medicalExam.isSmoker) {
      healthLevel += 10;
      highMedicalRiskFlag = true;
    }

    let certificationGrade = 'regular';
-   if (scoringGuide.stateWithLowCertification(candidate.originState)) {
+   if (scoringGuide.stateWithLowCertification(this._candidate.originState)) {
      certificationGrade = 'low';
      result -= 5;
    }
    // 비슷한 코드가 한참 이어짐
    result -= Math.max(healthLevel - 5, 0);
    return result;
  }
}
```
##### STEP 3
계속해서 다른 매개변수들도 옮긴다.
``` diff
function score(candidate, medicalExam, scoringGuide) {
- return new Scorer(candidate).execute(medicalExam, scoringGuide);
+ return new Scorer(candidate, medicalExam, scoringGuide).execute();
}

class Scorer {
- constructor(candidate) {
+ constructor(candidate, medicalExam, scoringGuide) {
    this._candidate = candidate;
+   this._medicalExam = medicalExam;
+   this._scoringGuide = scoringGuide;
  }

- execute(medicalExam, scoringGuide) {
+ execute() {  
    let result = 0;
    let healthLevel = 0;
    let highMedicalRiskFlag = false;

-   if (medicalExam.isSmoker) {
+   if (this._medicalExam.isSmoker) {  
      healthLevel += 10;
      highMedicalRiskFlag = true;
    }

    let certificationGrade = 'regular';
-   if (scoringGuide.stateWithLowCertification(this._candidate.originState)) {
+   if (this._scoringGuide.stateWithLowCertification(this._candidate.originState)) {  
      certificationGrade = 'low';
      result -= 5;
    }
    // 비슷한 코드가 한참 이어짐
    result -= Math.max(healthLevel - 5, 0);
    return result;
  }
}
```
##### 더 가다듬기
이상으로 함수를 명령으로 바꿔봤다. 하지만 이 리팩터링의 본래 목적은 복잡한 함수를 잘게 나누는 것이다. 이 목적을 이루기 위한 단계들을 개략적으로 설명해보겠다.
##### STEP 4
먼저 모든 지역 변수를 필드로 바꿔야 한다. 역시 한 번에 하나씩 진행한다.
``` diff
function score(candidate, medicalExam, scoringGuide) {
  return new Scorer(candidate, medicalExam, scoringGuide).execute();
}

class Scorer {
  constructor(candidate, medicalExam, scoringGuide) {
    this._candidate = candidate;
    this._medicalExam = medicalExam;
    this._scoringGuide = scoringGuide;
  }

  execute() {  
-   let result = 0;
+   this._result = 0;
    let healthLevel = 0;
    let highMedicalRiskFlag = false;

    if (this._medicalExam.isSmoker) {  
      healthLevel += 10;
      highMedicalRiskFlag = true;
    }

    let certificationGrade = 'regular';
    if (this._scoringGuide.stateWithLowCertification(this._candidate.originState)) {  
      certificationGrade = 'low';
-     result -= 5;
+     this._result -= 5;
    }
    // 비슷한 코드가 한참 이어짐
-   result -= Math.max(healthLevel - 5, 0);
+   this._result -= Math.max(healthLevel - 5, 0);
-   return result;
+   return this._result;
  }
}
```
##### STEP 5
남은 지역 변수들도 같은 방법으로 바꿔준다.(너무 단순해서 책에 싣지 않은 리팩터링이 몇 개 있는데, 방금 적용한 리팩터링이 그 중 하나다. 조금 미안하게 생각한다.)
``` diff
function score(candidate, medicalExam, scoringGuide) {
  return new Scorer(candidate, medicalExam, scoringGuide).execute();
}

class Scorer {
  constructor(candidate, medicalExam, scoringGuide) {
    this._candidate = candidate;
    this._medicalExam = medicalExam;
    this._scoringGuide = scoringGuide;
  }

  execute() {  
    this._result = 0;
-   let healthLevel = 0;
+   this._healthLevel = 0;
-   let highMedicalRiskFlag = false;
+   this._highMedicalRiskFlag = false;

    if (this._medicalExam.isSmoker) {  
-     healthLevel += 10;
+     this._healthLevel += 10;
-     highMedicalRiskFlag = true;
+     this._highMedicalRiskFlag = true;
    }

-   let certificationGrade = 'regular';
+   this._certificationGrade = 'regular';
    if (this._scoringGuide.stateWithLowCertification(this._candidate.originState)) {  
-     certificationGrade = 'low';
+     this._certificationGrade = 'low';
      this._result -= 5;
    }
    // 비슷한 코드가 한참 이어짐
-   this._result -= Math.max(healthLevel - 5, 0);
+   this._result -= Math.max(this._healthLevel - 5, 0);
    return this._result;
  }
}
```
##### STEP 6
이제 함수의 상태가 모두 명령 객체로 옮겨졌다. 따라서 함수가 사용하던 변수나 그 유효범위에 구애받지 않고 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md)같은 리팩터링을 적용할 수 있다.
``` diff
function score(candidate, medicalExam, scoringGuide) {
  return new Scorer(candidate, medicalExam, scoringGuide).execute();
}

class Scorer {
  constructor(candidate, medicalExam, scoringGuide) {
    this._candidate = candidate;
    this._medicalExam = medicalExam;
    this._scoringGuide = scoringGuide;
  }

  execute() {  
    this._result = 0;
    this._healthLevel = 0;
    this._highMedicalRiskFlag = false;

-   if (this._medicalExam.isSmoker) {
-     this._healthLevel += 10;
-     this._highMedicalRiskFlag = true;
-   }
+   this.scoreSmoking();
    this._certificationGrade = 'regular';
    if (this._scoringGuide.stateWithLowCertification(this._candidate.originState)) {  
      this._certificationGrade = 'low';
      this._result -= 5;
    }
    // 비슷한 코드가 한참 이어짐
    this._result -= Math.max(this._healthLevel - 5, 0);
    return this._result;
  }

+ scoreSmoking() {
+   if (this._medicalExam.isSmoker) {  
+     this._healthLevel += 10;
+     this._highMedicalRiskFlag = true;
+   }
+ }  
}
```
이제 명령을 중첩 함수처럼 다룰 수 있다. 사실 자바스크립트에서라면 중첩 함수는 명령의 합리적인 대안이 될 수 있다. 그래도 나는 여전히 명령을 사용한다. 내가 명령에 더 익숙하기도 하거니와, 명령을 사용하면 (execute 외의) 서브함수들을 테스트와 디버깅에 활용할 수 있기 때문이다.