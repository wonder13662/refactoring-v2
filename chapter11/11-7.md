# 11.7 세터 제거하기(Remove Setting Method)
``` diff
class Person {
  get name() { ... }
- set name(aString) { ... }
}
```
## 배경
세터 메서드가 있다고 함은 필드가 수정될 수 있다는 뜻이다. 객체 생성 후에는 수정되지 않길 원하는 필드라면 세터를 제공하지 않을 것이다(그래서 그 필드를 불편으로 만들었을 것이다). 그러면 해당 필드는 오직 생성자에서만 설정되며, 수정하지 않겠다는 의도가 명명백백해지고, 변경될 가능성도 봉쇄된다(자바의 리플렉션처럼 언어에 따라 변경할 수 있는 특별한 메커니즘을 제공하기도 한다).

세터 제거하기 리팩터링이 필요한 상황은 주로 두 가지다.
1. 사람들이 무조건 접근자 메서드를 통해서 필드를 다루려 할 때다. 심지어 생성자 안에서도 말이다. 이러면 오직 생성자에서만 호출하는 세터가 생겨나곤 한다. 하지만 나라면 세터를 제거해서 객체가 생성된 후에는 값이 바뀌면 안된다는 뜻을 분명히 할 것이다.
2. 클라이언트에서 생성 스크립트(creation script)를 사용해 객체를 생성할 때다. 생성 스크립트란 생성자를 호출한 후 일련의 세터를 호출하여 객체를 완성하는 형태의 코드를 말한다(별도의 스크립트 파일이 아니다). 그러면서 설계자는 스크립트가 완료된 뒤로는 그 객체의 필드 일부(혹은 전체)는 변경되지 않으리라 기대한다. 즉, 해당 세터들은 처음 생성할 때만 호출되리라 가정한다. 이런 경우에도 세터들을 제거하여 의도를 더 정확하게 전달하는 게 좋다.
## 절차
### (1)
설정해야 할 값을 생성자에서 받지 않는다면 그 값을 받을 매개변수를 생성자에 추가한다([6.5 함수 선언 바꾸기(Change Function Declaration)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-5.md)). 그런 다음 생성자 안에서 적절한 세터를 호출한다.
- 세터 여러 개를 제거하려면 해당 값 모두를 한꺼번에 생성자에 추가한다. 그러면 이후 과정이 간소해진다.
### (2)
생성자 밖에서 세터를 호출하는 곳을 찾아 제거하고, 대신 새로운 생성자를 사용하도록 한다. 하나 수정할 때마다 테스트한다.
- (갱신하려는 대상이 공유 참조 객체라서) 새로운 객체를 생성하는 방식으로는 세터 호출을 대체할 수 없다면 이 리팩터링을 취소한다.
### (3)
세터 메서드를 [6.2 함수 인라인하기(Inline Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-2.md)한다. 가능하다면 해당 필드를 불변으로 만든다.
### (4)
테스트한다.
## 예시
간단한 사람(Person) 클래스를 준비했다.
``` javascript
class Person {
  get name() { return this._name; }
  set name(arg) { this._name = arg; }
  get id() { return this._id; }
  set id(arg) { this._id = arg; }
}
```

그리고 다음 코드로 사람 객체를 하나 생성한다.
``` javascript
const martin = new Person();
martin.name = "마틴";
martin.id = "1234";
```
### STEP 1
사람의 속성 중 이름은 객체를 생성한 뒤라도 변경될 수 있겠지만 `id`는 그러면 안 된다. 이 의도를 명확히 알리기 위해 `id` 세터를 없애보자.

[(1)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-7.md#1) 최초 한 번은 ID를 설정할 수 있어야 하므로 [6.5 함수 선언 바꾸기(Change Function Declaration)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-5.md)로 생성자에서 `id`를 받도록 한다.
``` diff
class Person {
+ constructor(id) {
+   this.id = id;
+ }
  get name() { return this._name; }
  set name(arg) { this._name = arg; }
  get id() { return this._id; }
  set id(arg) { this._id = arg; }
}

const martin = new Person();
martin.name = "마틴";
martin.id = "1234";
```
### STEP 2
[(2)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-7.md#2) 그런 다음 생성 스크립트가 이 생성자를 통해 `id`를 설정하게끔 수정한다.
``` diff
class Person {
  constructor(id) {
    this.id = id;
  }
  get name() { return this._name; }
  set name(arg) { this._name = arg; }
  get id() { return this._id; }
  set id(arg) { this._id = arg; }
}

-const martin = new Person();
+const martin = new Person("1234");
martin.name = "마틴";
-martin.id = "1234";
```
### STEP 3
[(3)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-7.md#3) 모두 수정했다면 세터 메서드를 [6.2 함수 인라인하기(Inline Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-2.md)한다.
``` diff
class Person {
  constructor(id) {
-   this.id = id;
+   this._id = id;
  }
  get name() { return this._name; }
  set name(arg) { this._name = arg; }
  get id() { return this._id; }
- set id(arg) { this._id = arg; }
}

const martin = new Person("1234");
martin.name = "마틴";
```

- [목차](https://github.com/wonder13662/refactoring-v2/blob/writing/README.md)
- [11 API 리팩터링](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11)
- [11.6 질의 함수를 매개변수로 바꾸기(Replace Query with Parameter)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-6.md)
- [11.8 생성자를 팩터리 함수로 바꾸기(Replace Constructor with Factory Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-8.md)
