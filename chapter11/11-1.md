# 11.1 질의 함수와 변경 함수 분리하기(Separate Query from Modifier)
``` diff
-function getTotalOutstandingAndSendBill() {
- const result = customer.invoices.reduce((total, each) => each.amount + total, 0);
- sendBill();
- return result;
-}
+function totalOutstanding() {
+ return customer.invoices.reduce((total, each) => each.amount + total, 0);
+}
+function sendBill() {
+ emailGateway.send(formatBill(customer));
+}
```

## 배경
우리는 외부에서 관찰할 수 있는 겉보기 부수효과(observable side effect)가 전혀 없이 값을 반환해주는 함수를 추구해야 한다. 이런 함수는 어느 때건 원하는 만큼 호출해도 아무 문제가 없다. 호출하는 문장의 위치를 호출하는 함수 안 어디로든 옮겨도 되며 테스트하기도 쉽다. 한마디로, 이용할 때 신경쓸 것들이 매우 적다.

겉보기 부수효과가 있는 함수와 없는 함수는 명확히 구분하는 것이 좋다. 이를 위한 한 가지 방법은 '질의 함수(읽기 함수)는 모두 부수효과가 없어야 한다'는 규칙을 따르는 것이다. 이를 [명령-질의 분리(command-query separation)](https://martinfowler.com/bliki/CommandQuerySeparation.html)라 하는데, 이 규칙을 절대적으로 신봉하는 프로그래머도 있다. 나는 이 견해에(혹은 다른 무엇이라도) 100% 동의하지는 않지만 되도록 따르려 노력하고 있으며, 그동안 효과도 톡톡히 봤다.

나는 값을 반환하면서 부수효과도 있는 함수를 발견하면 상태를 변경하는 부분과 질의하는 부분을 분리하려 시도한다. 무조건이다!

내가 '겉보기' 부수효과라고 한 데는 이유가 있다. 흔히 쓰는 최적화 기법 중 요청된 값을 캐시해두고 다음번 호출 때 빠르게 응답하는 방법이 있는데, 이러한 캐싱도 객체의 상태를 변경하지만 객체 밖에서는 관찰할 수 없다. 즉, 겉보기 부수효과 없이 어떤 순서로 호출하든 모든 호출에 항상 똑같은 값을 반환할 뿐이다.

## 절차
### (1)
대상 함수를 복제하고 질의 목적에 충실한 이름을 짓는다.
- 함수 내부를 살펴 무엇을 반환하는지 찾는다. 어떤 변수의 값을 반환한다면 그 변수 이름이 훌륭한 단초가 될 것이다.
### (2)
새 질의 함수에서 부수효과를 모두 제거한다.
### (3)
정적 검사를 수행한다.
### (4)
원래 함수(변경 함수)를 호출하는 곳을 모두 찾아낸다. 호출하는 곳에서 반환 값을 사용한다면 질의 함수를 호출하도록 바꾸고, 원래 함수를 호출하는 코드를 바로 아래 줄에 새로 추가한다. 하나 수정할 때마다 테스트한다.
### (5)
원래 함수에서 질의 관련 코드를 제거한다.
### (6)
테스트한다.

이 리팩터링을 마친 후에는 새로 만든 질의 함수와 원래 함수에 (정리해야 할) 줄복이 남아 있을 수 있다.

## 예시
이름 목록을 훑어 악당(miscreant)을 찾는 함수를 준비했다. 악당을 찾으면 그 사람의 이름을 반환하고 경고를 울린다. 이 함수는 가장 먼저 찾은 악당만 취급한다.
``` javascript
function alertForMiscreant(people) {
  for (const p of people) {
    if (p === "조커") {
      setOffAlarms();
      return "조커";
    }
    if (p === "사루만") {
      setOffAlarms();
      return "사루만";
    }
  }
  return "";
}
const found = alertForMiscreant(people);
```
### STEP 1
[(1)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/11-1.md#1) 첫 단계는 함수를 복제하고 질의 목적에 맞는 이름짓기다.
``` diff
function alertForMiscreant(people) {
  for (const p of people) {
    if (p === "조커") {
      setOffAlarms();
      return "조커";
    }
    if (p === "사루만") {
      setOffAlarms();
      return "사루만";
    }
  }
  return "";
}

+function findMiscreant(people) {  
+ for (const p of people) {
+   if (p === "조커") {
+     setOffAlarms();
+     return "조커";
+   }
+   if (p === "사루만") {
+     setOffAlarms();
+     return "사루만";
+   }
+ }
+ return "";
+}

const found = alertForMiscreant(people);
```
### STEP 2
[(2)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/11-1.md#2) 새 질의 함수에서 부수효과를 낳는 부분을 제거한다.
``` diff
function alertForMiscreant(people) {
  for (const p of people) {
    if (p === "조커") {
      setOffAlarms();
      return "조커";
    }
    if (p === "사루만") {
      setOffAlarms();
      return "사루만";
    }
  }
  return "";
}

function findMiscreant(people) {  
  for (const p of people) {
    if (p === "조커") {
-     setOffAlarms();
      return "조커";
    }
    if (p === "사루만") {
-     setOffAlarms();
      return "사루만";
    }
  }
  return "";
}
const found = alertForMiscreant(people);
```
### STEP 3
[(4)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/11-1.md#4) 이제 원래 함수를 호출하는 곳을 모두 찾아서 새로운 질의 함수를 호출하도록 바꾸고, 이어서 원래의 변경 함수를 호출하는 코드를 바로 아래에 삽입한다. 예컨대 다음 코드를 다음과 같이 바꾼다.
``` diff
function alertForMiscreant(people) {
  for (const p of people) {
    if (p === "조커") {
      setOffAlarms();
      return "조커";
    }
    if (p === "사루만") {
      setOffAlarms();
      return "사루만";
    }
  }
  return "";
}

function findMiscreant(people) {  
  for (const p of people) {
    if (p === "조커") {
      return "조커";
    }
    if (p === "사루만") {
      return "사루만";
    }
  }
  return "";
}
-const found = alertForMiscreant(people);
+const found = findMiscreant(people);
```
### STEP 4
[(5)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/11-1.md#5) 이제 원래의 변경 함수에서 질의 관련 코드를 없앤다.
``` diff
function alertForMiscreant(people) {
  for (const p of people) {
    if (p === "조커") {
      setOffAlarms();
-     return "조커";
+     return;
    }
    if (p === "사루만") {
      setOffAlarms();
-     return "사루만";
+     return;
    }
  }
- return "";
+ return;
}

function findMiscreant(people) {  
  for (const p of people) {
    if (p === "조커") {
      return "조커";
    }
    if (p === "사루만") {
      return "사루만";
    }
  }
  return "";
}
const found = findMiscreant(people);
```
#### 더 가다듬기
### STEP 5
리팩터링은 마쳤지만 변경 함수와 새 질의 함수에는 중복된 코드가 많이 보인다. 이번 경우엔 변경 함수에서 질의 함수를 사용하도록 고치면 해결된다.([7.9 알고리즘 교체하기(Subtitute Algorithm)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-9.md) 적용)
``` diff
function alertForMiscreant(people) {
+ if (findMiscreant(people) !== "") setOffAlarms();
- for (const p of people) {
-   if (p === "조커") {
-     setOffAlarms();
-     return;
-   }
-   if (p === "사루만") {
-     setOffAlarms();
-     return;
-   }
- }
  return;
}

function findMiscreant(people) {  
  for (const p of people) {
    if (p === "조커") {
      return "조커";
    }
    if (p === "사루만") {
      return "사루만";
    }
  }
  return "";
}
const found = findMiscreant(people);
```