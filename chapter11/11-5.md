# 11.5 매개변수를 질의 함수로 바꾸기(Replace Parameter with Query)
- 반대 리팩터링: [11.6 질의 함수를 매개변수로 바꾸기(Replace Query with Parameter)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-6.md)
``` diff
-availableVacation(anEmployee, anEmployee.grade);
+availableVacation(anEmployee);

-function availableVacation(anEmployee, grade) {
+function availableVacation(anEmployee) {
+ const grade = anEmployee.grade;
  // 연휴 계산...
```

## 배경
매개변수 목록은 함수의 변동 요인을 모아놓은 곳이다. 즉, 함수의 동작에 변화를 줄 수 있는 일차적인 수단이다. 다른 코드와 마찬가지로 이 목록에서도 중복은 피하는 게 좋으며 짧을수록 이해하기 쉽다.

피호출 함수가 스스로 '쉽게' 결정할 수 있는 값을 매개변수로 건네는 것도 일종의 중복이다. 이런 함수를 호출할 때 매개변수의 값은 호출자가 정하게 되는데, 이 결정은 사실 하지 않아도 되었을 일이니 의미 없이 코드만 복잡해질 뿐이다.

이번 리팩터링의 한계는 '쉽게'라는 단어에 있다. 해당 매개변수를 제거하면 값을 결정하는 책임주체가 달라진다. 매개변수가 있다면 결정 주체가 호출자가 되고, 매개변수가 없다면 피호출 함수가 된다. 나는 습관적으로 호출하는 쪽을 간소하게 만든다. 즉, 책임 소재를 피호출 함수로 옮긴다는 뜻인데, 물론 피호출 함수가 그 역할을 수행하기에 적합할 때만 그렇게 한다.

매개변수를 질의 함수로 바꾸지 말아야 할 상황도 있다. 가장 흔한 예는 매개변수를 제거하면 피호출 함수에 원치 않는 의존성이 생길 때다. 즉, 해당 함수가 알지 못했으면 하는 프로그램 요소에 접근해야 하는 상황을 만들 때다. 새로운 의존성이 생기거나 제거하고 싶은 기존 의존성을 강화하는 경우라 할 수 있다. 이런 상황은 주로 함수 본문에서 문제의 외부 함수를 호출해야 하거나 나중에 함수 밖으로 빼내길 원하는 수용 객체(receiver object)에 담긴 데이터를 사용해야 할 때 일어난다.

제거하려는 매개변수의 값을 다른 매개변수에 질의해서 얻을 수 있다면 안심하고 질의 함수로 바꿀 수 있다. 다른 매개변수에서 얻을 수 있는 값을 별도 매개변수로 전달하는 것은 아무 의미가 없다.

주의사항이 하나 있다. 대상 함수가 참조 투명(referenctial transparency)해야 한다는 것이다. 참조 투명이란 '함수에 똑같은 값을 건네 호출하면 항상 똑같이 동작한다'는 뜻이다. 이런 함수는 동작을 예측하고 테스트하기가 훨씬 쉬우니 이 특성이 사라지지 않도록 주의하자. 따라서 매개변수를 잆애는 대신 가변 전역 변수를 이용하는 일은 하면 안된다.

##### 참고
참조 투명성은 [멱등법칙](https://ko.wikipedia.org/wiki/%EB%A9%B1%EB%93%B1%EB%B2%95%EC%B9%99)과 연결되어 있다.
## 절차
### (1)
필요하다면 대상 매개변수의 값을 계산하는 코드를 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md) 한다.
### (2)
함수 본문에서 대상 매개변수로의 참조를 모두 찾아서 그 매개변수의 값을 만들어주는 표현식을 참조하도록 바꾼다. 하나 수정할 때마다 테스트한다.
### (3)
[6.5 함수 선언 바꾸기(Change Function Declaration)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-5.md)로 대상 매개변수를 없앤다.
## 예시
다른 리팩터링을 수행한 뒤 특정 매개변수가 더는 필요 없어졌을 때가 있는데, 바로 이번 리팩터링을 적용하는 가장 흔한 사례다. 다음 코드를 보자.
``` javascript
class Order {
  get finalPrice() {
    const basePrice = this.quantity * this.itemPrice;
    let discountLevel;
    if (this.quantity > 100) discountLevel = 2;
    else discountLevel = 1;
    return this.discountedPrice(basePrice, discountLevel);
  }

  discountedPrice(basePrice, discountLevel) {
    switch (discountLevel) {
      case 1: return basePrice * 0.95;
      case 2: return basePrice * 0.9;
    }
  }
}
```
### STEP 1
함수를 간소화하다 보면 [7.4 임시 변수를 질의 함수로 바꾸기(Replace Temp with Query)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-4.md)를 적용할 때가 많다. 이를 앞의 `finalPrice()` 함수에 적용하면 다음처럼 변한다.
``` diff
class Order {
  get finalPrice() {
    const basePrice = this.quantity * this.itemPrice;
-   let discountLevel;
-   if (this.quantity > 100) discountLevel = 2;
-   else discountLevel = 1;
-   return this.discountedPrice(basePrice, discountLevel);
+   return this.discountedPrice(basePrice, this.discountLevel);
  }

+ get discountLevel() {
+   return (this.quantity > 100) ? 2 : 1;
+ }  

  discountedPrice(basePrice, discountLevel) {
    switch (discountLevel) {
      case 1: return basePrice * 0.95;
      case 2: return basePrice * 0.9;
    }
  }
}
```
그 결과로 `discountedPrice()` 함수에 `discountLevel()`의 반환 값을 건넬 이유가 사라졌다. 필요할 때 직접 호출하면 되기 때문이다.
### STEP 2
[(2)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-5.md#2) 이 매개변수를 참조하는 코드를 모두 함수 호출로 바꿔보자.
``` diff
class Order {
  get finalPrice() {
    const basePrice = this.quantity * this.itemPrice;
    return this.discountedPrice(basePrice, this.discountLevel);
  }

  get discountLevel() {
    return (this.quantity > 100) ? 2 : 1;
  }  

  discountedPrice(basePrice, discountLevel) {
-   switch (discountLevel) {
+   switch (this.discountLevel) {  
      case 1: return basePrice * 0.95;
      case 2: return basePrice * 0.9;
    }
  }
}
```
### STEP 3
[(3)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-5.md#3) 이제 [6.5 함수 선언 바꾸기(Change Function Declaration)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-5.md)로 이 매개변수를 없앨 수 있다.
``` diff
class Order {
  get finalPrice() {
    const basePrice = this.quantity * this.itemPrice;
-   return this.discountedPrice(basePrice, this.discountLevel);
+   return this.discountedPrice(basePrice);
  }

  get discountLevel() {
    return (this.quantity > 100) ? 2 : 1;
  }  

- discountedPrice(basePrice, discountLevel) {
+ discountedPrice(basePrice) {  
    switch (this.discountLevel) {  
      case 1: return basePrice * 0.95;
      case 2: return basePrice * 0.9;
    }
  }
}
```

- [목차](https://github.com/wonder13662/refactoring-v2/blob/writing)
- [11 API 리팩터링](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11)
- [11.4 객체 통째로 넘기기(Preserve Whole Object)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-4.md)
- [11.6 질의 함수를 매개변수로 바꾸기(Replace Query with Parameter)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-6.md)
