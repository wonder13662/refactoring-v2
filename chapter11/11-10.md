# 11.10 명령을 함수로 바꾸기(Replace Command with Function)
- 반대 리팩터링: [11.9 함수를 명령으로 바꾸기(Replace Function with Command)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-9.md)
``` diff
-class ChargeCalculator {
- constructor(customer, usage) {
-   this._customer = customer;
-   this._usage = usage;
- }

- execute() {
-   return this._customer.rate * this._usage;
- }
-}
+function charge(customer, usage) {
+ return customer.rate * usage;
+}
```

## 배경
명령 객체는 복잡한 연산을 다룰 수 있는 강력한 매커니즘을 제공한다. 구체적으로는, 큰 연산 하나를 여러 개의 작은 메서드로 쪼개고 필드를 이용해 쪼개진 메서드들끼리 정보를 공유할 수 있다. 또한 어떤 메서드를 호출하냐에 따라 다른 효과를 줄 수 있고, 각 단계를 거치며 데이터를 조금씩 완성해 갈 수도 있다.

명령의 이런 능력은 공짜가 아니다. 명령은 그저 함수를 하나 호출해 정해진 일을 수행하는 용도로 주로 쓰인다. 이런 상황이고 로직이 크게 복잡하지 않다면 명령 객체는 장점보다 단점이 크니 평범한 함수로 바꿔주는 게 낫다.
## 절차
### (1)
명령을 생성하는 코드와 명령의 실행 메서드를 호출하는 코드를 함께 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md) 한다.
- 이 함수가 바로 명령을 대체할 함수다.
### (2)
명령의 실행 함수가 호출하는 보조 메서드들 각각을 [6.2 함수 인라인하기(Inline Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-2.md) 한다.
- 보조 메서드가 값을 반환한다면 함수 인라인에 앞서 [6.3 변수 추출하기(Extract Variable)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-3.md)를 적용한다.
### (3)
[6.5 함수 선언 바꾸기(Change Function Declaration)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-5.md)를 적용하여 생성자의 매개변수 모두를 명령의 실행 메서드로 옮긴다.
### (4)
명령의 실행 메서드에서 참조하는 필드를 대신 대응하는 매개변수를 사용하게끔 바꾼다. 하나씩 수정할 때마다 테스트한다.
### (5)
생성자 호출과 명령의 실행 메서드 호출을 호출자(대체 함수) 안으로 인라인한다.
### (6)
테스트한다.
### (7)
[8.9 죽은 코드 제거하기(Remove Dead Code)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-9.md)로 명령 클래스를 없앤다.

## 예시
작은 명령 객체에서 시작해보자.
``` javascript
class ChargeCalculator {
  constructor(customer, usage, provider) {
    this._customer = customer;
    this._usage = usage;
    this._provider = provider;
  }

  get baseCharge() {
    return this._customer.baseRate * this._usage;
  }

  get charge() {
    return this.baseCharge + this._provider.connectionCharge;
  }
}
```
다음은 호출하는 쪽의 코드다.
``` javascript
monthCharge = new ChargeCalculator(customer, usage, provider).charge;
```
이 명령 클래스는 간단한 편이므로 함수로 대체하는 게 나아 보인다.
### STEP 1
[(1)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-10.md#1) 첫 번째로, 이 클래스를 생성하고 호출하는 코드를 함께 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md) 한다.
``` diff
class ChargeCalculator {
  constructor(customer, usage, provider) {
    this._customer = customer;
    this._usage = usage;
    this._provider = provider;
  }

  get baseCharge() {
    return this._customer.baseRate * this._usage;
  }

  get charge() {
    return this.baseCharge + this._provider.connectionCharge;
  }
}

// 최상위
+function charge(customer, usage, provider) {
+ return new ChargeCalculator(customer, usage, provider).charge;
+}

// 호출자
-monthCharge = new ChargeCalculator(customer, usage, provider).charge;
+monthCharge = charge(customer, usage, provider);
```
### STEP 2
[(2)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-10.md#2) 이 때 보조 메서드들을 어떻게 다룰지 정해야 하는데, `baseCharge()`가 이러한 보조 메서드에 속한다. 값을 반환하는 메서드라면 먼저 반환할 값을 [6.3 변수 추출하기(Extract Variable)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-3.md) 한다.
``` diff
class ChargeCalculator {
  constructor(customer, usage, provider) {
    this._customer = customer;
    this._usage = usage;
    this._provider = provider;
  }

  get baseCharge() {
    return this._customer.baseRate * this._usage;
  }

  get charge() {
+   const baseCharge = this.baseCharge;    
-   return this.baseCharge + this._provider.connectionCharge;
+   return baseCharge + this._provider.connectionCharge;
  }
}

// 최상위
function charge(customer, usage, provider) {
  return new ChargeCalculator(customer, usage, provider).charge;
}

// 호출자
monthCharge = charge(customer, usage, provider);
```
### STEP 3
그런 다음 보조 메서드를 [6.2 함수 인라인하기(Inline Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-2.md) 한다.
``` diff
class ChargeCalculator {
  constructor(customer, usage, provider) {
    this._customer = customer;
    this._usage = usage;
    this._provider = provider;
  }

  get baseCharge() {
    return this._customer.baseRate * this._usage;
  }

  get charge() {
-   const baseCharge = this.baseCharge;
+   const baseCharge = this._customer.baseRate * this._usage;
    return baseCharge + this._provider.connectionCharge;
  }
}

// 최상위
function charge(customer, usage, provider) {
  return new ChargeCalculator(customer, usage, provider).charge;
}

// 호출자
monthCharge = charge(customer, usage, provider);
```
### STEP 4
이제 로직 전체가 한 메서드에서 이뤄지므로, 그 다음으로는 생성자에 전달되는 모든 데이터를 주 메서드로 옮겨야 한다. 먼저 생성자가 받던 모든 매개변수를 `charge()` 메서드로 옮기기 위해 [6.5 함수 선언 바꾸기(Change Function Declaration)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-5.md)를 적용한다.
``` diff
class ChargeCalculator {
  constructor(customer, usage, provider) {
    this._customer = customer;
    this._usage = usage;
    this._provider = provider;
  }

- get baseCharge() {
-   return this._customer.baseRate * this._usage;
- }

- get charge() {
+ get charge(customer, usage, provider) {  
    const baseCharge = this._customer.baseRate * this._usage;
    return baseCharge + this._provider.connectionCharge;
  }
}

// 최상위
function charge(customer, usage, provider) {
- return new ChargeCalculator(customer, usage, provider).charge;
+ return new ChargeCalculator(customer, usage, provider).charge(customer, usage, provider);
}

// 호출자
monthCharge = charge(customer, usage, provider);
```
### STEP 5
이제 `charge()`의 본문에서 필드 대신 건네받은 매개변수를 사용하도록 수정한다. 이번에도 한 번에 하나씩 진행한다.
``` diff
class ChargeCalculator {
  constructor(customer, usage, provider) {
-   this._customer = customer;
    this._usage = usage;
    this._provider = provider;
  }

  get charge(customer, usage, provider) {  
-   const baseCharge = this._customer.baseRate * this._usage;
+   const baseCharge = customer.baseRate * this._usage;
    return baseCharge + this._provider.connectionCharge;
  }
}

// 최상위
function charge(customer, usage, provider) {
  return new ChargeCalculator(customer, usage, provider).charge(customer, usage, provider);
}

// 호출자
monthCharge = charge(customer, usage, provider);
```
생성자에 있는 대입문 `this._customer = customer;`는 무시되므로 꼭 지워야 하는 건 아니지만 지워두는 편이 좋다. 그래야 혹시라도 필드 대신 매개변수를 사용하는 수정을 빼먹었을 때 테스트가 실패하기 때문이다(테스트가 실패하지 않는다면 새로운 테스트를 추가하는 걸 고려해보자).
### STEP 6
나머지 매개변수들도 똑같이 바꿔주면 다음처럼 될 것이다.
``` diff
class ChargeCalculator {
  constructor(customer, usage, provider) {
    this._usage = usage;
    this._provider = provider;
  }

  get charge(customer, usage, provider) {  
-   const baseCharge = customer.baseRate * this._usage;
+   const baseCharge = customer.baseRate * usage;
-   return baseCharge + this._provider.connectionCharge;
+   return baseCharge + provider.connectionCharge;
  }
}

// 최상위
function charge(customer, usage, provider) {
  return new ChargeCalculator(customer, usage, provider).charge(customer, usage, provider);
}

// 호출자
monthCharge = charge(customer, usage, provider);
```
### STEP 7
[(5)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-10.md#5) 다 됐다면 최상위 `charge()` 함수로 인라인할 수 있다. 이는 생성자와 메서드 호출을 함께 인라인하는 특별한 형태의 [6.2 함수 인라인하기(Inline Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-2.md)이다.
``` diff
class ChargeCalculator {
  constructor(customer, usage, provider) {
    this._usage = usage;
    this._provider = provider;
  }

  get charge(customer, usage, provider) {  
    const baseCharge = customer.baseRate * usage;
    return baseCharge + provider.connectionCharge;
  }
}

// 최상위
function charge(customer, usage, provider) {
- return new ChargeCalculator(customer, usage, provider).charge(customer, usage, provider);
+ const baseCharge = customer.baseRate * usage;
+ return baseCharge + provider.connectionCharge;
}

// 호출자
monthCharge = charge(customer, usage, provider);
```
### STEP 8
[(7)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-10.md#7) 명령 클래스는 이제 죽은 코드가 되었으니 [8.9 죽은 코드 제거하기(Remove Dead Code)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-9.md)로 영면에 들게 해준다.
``` diff
-class ChargeCalculator {
- constructor(customer, usage, provider) {
-   this._usage = usage;
-   this._provider = provider;
- }

- get charge(customer, usage, provider) {  
-   const baseCharge = customer.baseRate * usage;
-   return baseCharge + provider.connectionCharge;
- }
-}

// 최상위
function charge(customer, usage, provider) {
  const baseCharge = customer.baseRate * usage;
  return baseCharge + provider.connectionCharge;
}

// 호출자
monthCharge = charge(customer, usage, provider);
```

- [목차](https://github.com/wonder13662/refactoring-v2/blob/writing/README.md)
- [11 API 리팩터링](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11)
- [11.9 함수를 명령으로 바꾸기(Replace Function with Command)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-9.md)
- [11.11 수정된 값 반환하기(Return Modified Value)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-11.md)
