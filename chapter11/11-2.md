### 11.2 함수 매개변수화하기(Parameterize Function)
``` diff
-function tenPercentRaise(aPerson) {
- aPerson.salary = aPerson.salary.multiply(1.1);
-}
-function fivePercentRaise(aPerson) {
- aPerson.salary = aPerson.salary.multiply(1.05);
-}
+function raise(aPerson, factor) {
+ aPerson.salary = aPerson.salary.multiply(1 + factor);
+}
```

#### 배경
두 함수의 로직이 아주 비슷하고 단지 리터럴 값만 다르다면, 그 다른 값만 매개변수로 받아 처리하는 함수 하나로 합쳐서 중복을 없앨 수 있다. 이렇게 하면 매개변수 값만 바꿔서 여러 곳에서 쓸 수 있으니 함수의 유용성이 커진다.
#### 절차
##### (1)
비슷한 함수 중 하나를 선택한다.
##### (2)
[6.5 함수 선언 바꾸기(Change Function Declaration)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-5.md)로 리터럴들을 매개변수로 추가한다.
##### (3)
이 함수를 호출하는 곳 모두에 적절한 리터럴 값을 추가한다.
##### (4)
테스트한다.
##### (5)
매개변수로 받은 값을 사용하도록 함수 본문을 수정한다. 하나 수정할 때마다 테스트한다.
##### (6)
비슷한 다른 함수를 호출하는 코드를 찾아 매개변수화된 함수를 호출하도록 하나씩 수정한다. 하나 수정할 때마다 테스트한다.
- 매개변수화된 함수가 대체할 비슷한 함수와 다르게 동작한다면, 그 비슷한 함수의 동작도 처리할 수 있도록 본문 코드를 적절히 수정한 후 진행한다.
#### 예시
먼저 명백한 예를 보자.
``` javascript
function tenPercentRaise(aPerson) {
  aPerson.salary = aPerson.salary.multiply(1.1);
}
function fivePercentRaise(aPerson) {
  aPerson.salary = aPerson.salary.multiply(1.05);
}
```
앞의 두 함수는 확실히 다음 함수로 대체할 수 있다.
``` javascript
function raise(aPerson, factor) {
  aPerson.salary = aPerson.salary.multiply(1 + factor);
}
```
하지만 이렇게 간단히 끝나지 않는 경우도 있다. 다음 코드를 보자.
``` javascript
function baseCharge(usage) {
  if (usage < 0) return usd(0);
  const amount = 
    bottomBand(usage) * 0.03
    + middleBand(usage) * 0.05
    + topBand(usage) * 0.07
    ;
  return usd(amount);
}

function bottomBand(usage) {
  return Math.min(usage, 100);
}

function middleBand(usage) {
  return usage > 100 ? Math.min(usage, 200) - 100 : 0;
}

function topBand(usage) {
  return usage > 200 ? usage - 200 : 0;
}
```
대역(band)을 다루는 세 함수의 로직이 상당히 비슷한 건 사실이지만, 과연 매개변수화 함수로 통합할 수 있을 만큼 비슷한가? 그렇다. 하지만 앞의 간단한 예보다는 덜 직관적이다.

[(1)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-2.md#1) 비슷한 함수들을 매개변수화하여 통합할 때는 먼저 대상 함수 중 하나를 골라 매개변수를 추가한다. 단, 다른 함수들까지 고려해 선택해야 한다. 지금 예처럼 범위를 다루는 로직에서는 대개 중간에 해당하는 함수에서 시작하는 게 좋다. 그러니 `middleBand()`에 매개변수를 추가하고 다른 호출들을 여기에 맞춰보자.

##### STEP 1
[(2)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-2.md#2)`middleBand()`는 리터럴을 두 개(100과 200) 사용하며, 그 각각은 중간 대역의 하한(bottom)과 상한(top)을 뜻한다. [6.5 함수 선언 바꾸기(Change Function Declaration)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-5.md)를 적용하고, [(3)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-2.md#3)이 리터럴들을 호출 시점에 입력하도록 바꿔보자. 이 과정에서 함수 이름도 매개 변수화된 기능에 어울리게 수정한다.
``` diff
function baseCharge(usage) {
  if (usage < 0) return usd(0);
  const amount = 
    bottomBand(usage) * 0.03
-   + middleBand(usage) * 0.05
+   + withinBand(usage, 100, 200) * 0.05
    + topBand(usage) * 0.07;
  return usd(amount);
}

function bottomBand(usage) {
  return Math.min(usage, 100);
}

-function middleBand(usage) {
+function withinBand(usage, bottom, top) {
  return usage > 100 ? Math.min(usage, 200) - 100 : 0;
}

function topBand(usage) {
  return usage > 200 ? usage - 200 : 0;
}
```
##### STEP 2
함수에서 사용하던 리터럴들을 적절한 매개변수로 대체한다.
``` diff
function baseCharge(usage) {
  if (usage < 0) return usd(0);
  const amount = 
    bottomBand(usage) * 0.03
    + withinBand(usage, 100, 200) * 0.05
    + topBand(usage) * 0.07;
  return usd(amount);
}

function bottomBand(usage) {
  return Math.min(usage, 100);
}

function withinBand(usage, bottom, top) {
- return usage > 100 ? Math.min(usage, 200) - 100 : 0;
+ return usage > bottom ? Math.min(usage, 200) - bottom : 0;
}

function topBand(usage) {
  return usage > 200 ? usage - 200 : 0;
}
```
##### STEP 3
나머지 매개변수도 대체한다.
``` diff
function baseCharge(usage) {
  if (usage < 0) return usd(0);
  const amount = 
    bottomBand(usage) * 0.03
    + withinBand(usage, 100, 200) * 0.05
    + topBand(usage) * 0.07;
  return usd(amount);
}

function bottomBand(usage) {
  return Math.min(usage, 100);
}

function withinBand(usage, bottom, top) {
- return usage > bottom ? Math.min(usage, 200) - bottom : 0;
+ return usage > bottom ? Math.min(usage, top) - bottom : 0;
}

function topBand(usage) {
  return usage > 200 ? usage - 200 : 0;
}
```
##### STEP 4
[(6)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-2.md#6)대역의 하한을 호출하는 부분도 새로 만든 매개변수화 함수를 호출하도록 바꾼다.
``` diff
function baseCharge(usage) {
  if (usage < 0) return usd(0);
  const amount = 
-   bottomBand(usage) * 0.03
+   withinBand(usage, 0, 100) * 0.03
    + withinBand(usage, 100, 200) * 0.05
    + topBand(usage) * 0.07;
  return usd(amount);
}

-function bottomBand(usage) {
- return Math.min(usage, 100);
-}

function withinBand(usage, bottom, top) {
  return usage > bottom ? Math.min(usage, top) - bottom : 0;
}

function topBand(usage) {
  return usage > 200 ? usage - 200 : 0;
}
```
##### STEP 5
대역의 상한 호출을 대체할 때는 무한대를 뜻하는 `Infinity`를 이용하면 된다.
``` diff
function baseCharge(usage) {
  if (usage < 0) return usd(0);
  const amount = 
    withinBand(usage, 0, 100) * 0.03
    + withinBand(usage, 100, 200) * 0.05
-   + topBand(usage) * 0.07;
+   + withinBand(usage, 200, Infinity) * 0.07;
  return usd(amount);
}

function withinBand(usage, bottom, top) {
  return usage > bottom ? Math.min(usage, top) - bottom : 0;
}

-function topBand(usage) {
- return usage > 200 ? usage - 200 : 0;
-}
```
이제 로직이 의도한 대로 동작하니 초기의 보호 구문을 제거해도 된다. 하지만 논리적으로는 필요 없어졌다고 해도, 예외 상황에서의 대처 방식을 잘 설명해주므로 그냥 두기로 했다.