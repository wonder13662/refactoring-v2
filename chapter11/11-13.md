# 11.13 예외를 사전확인으로 바꾸기(Replace Exception with Precheck)
``` diff
double getValueForPeriod (int periodNumber) {
- try {
-   return values[periodNumber];
- } catch (ArrayIndexOutOfBoundsException e) {
-   return 0;
- }
+ return (periodNumber >= values.length) ? 0 : values[periodNumber];
}
```

## 배경
예외라는 개념은 프로그래밍 언어의 발전에 의미있는 한 걸음이었다. 오류 코드를 연쇄적으로 전파하던 긴 코드를 예외로 바꿔 깔끔히 제거할 수 있게 되었으니 말이다([11.12 오류 코드를 예외로 바꾸기(Replace Error Code with Exception)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-12.md)). 하지만 좋은 것들이 늘 그렇듯, 예외도 (더 이상 좋지 않을 정도까지) 과용되곤 한다. 예외는 '뜻밖의 오류'라는, 말 그대로 예외적으로 동작할 때만 쓰여야 한다. 함수 수행 시 문제가 될 수 있는 조건을 함수 호출 전에 검사할 수 있다면, 예외를 던지는 대신 호출하는 곳에서 조건을 검사하도록 해야 한다.
## 절차
### (1)
예외를 유발하는 상황을 검사할 수 있는 조건문을 추가한다. catch 블록의 코드를 조건문의 조건절 중 하나로 옮기고, 남은 try 블록의 코드를 다른 조건절로 옮긴다.
### (2)
catch 블록에 어서션을 추가하고 테스트한다.
### (3)
try 문과 catch 블록을 제거한다.
### (4)
테스트한다.
## 예시(Java)
데이터베이스 연결 같은 자원들을 관리하는 자원 풀(resource pool) 클래스가 있다고 해보자. 자원이 필요한 코드는 풀에서 하나씩 꺼내 사용한다. 풀은 어떤 자원이 할당되었고 가용한 지를 추적하고, 자원이 바닥나면 새로 생성한다.
``` java
class ResourcePool {
  public Resource get() {
    Resource result;
    try {
      result = available.pop();
      allocated.add(result);
    } catch(NoSuchelementException e) {
      result = Resource.create();
      allocated.add(result);
    }
    return result;
  }

  private Deque<Resource> available;
  private List<Resource> allocated;
}
```
풀에서 자원이 고갈되는 건 예상치 못한 조건이 아니므로 예외 처리로 대응하는 건 올지 않다. 사용하기 전에 `allocated` 컬렉션의 상태를 확인하기란 아주 쉬운 일이며, 예상 범주에 있는 동작임을 더 뚜렷하게 드러내주는 방식이다.

### STEP 1
[(1)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-13.md#1) 조건을 검사하는 코드를 추가하고, `catch` 블록의 코드를 조건문의 조건절로 옮기고, 남은 `try` 블록 코드를 다른 조건절로 옮겨보자.
``` diff
class ResourcePool {
  public Resource get() {
    Resource result;
-   try {
+   if (available.isEmpty()) {
-     result = available.pop();
+     result = Resource.create();
      allocated.add(result);
-   } catch(NoSuchelementException e) {
+   } else {
+     try {
-       result = Resource.create();
+       result = available.pop();
        allocated.add(result);
+     } catch (NoSuchElementException e) {
+     }
    }
    return result;
  }

  private Deque<Resource> available;
  private List<Resource> allocated;
}
```
### STEP 2
[(2)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-13.md#2) `catch` 절은 더 이상 호출되지 않으므로 어서션을 추가한다.
``` diff
class ResourcePool {
  public Resource get() {
    Resource result;
    if (available.isEmpty()) {
      result = Resource.create();
      allocated.add(result);
    } else {
      try {
        result = available.pop();
        allocated.add(result);
      } catch (NoSuchElementException e) {
+       throw new AssertionError("도달 불가");
      }
    }
    return result;
  }

  private Deque<Resource> available;
  private List<Resource> allocated;
}
```
> 나는 `AssertionError`를 던지기보다는 `assert` 키워드를 사용할 때가 많지만, 그러면 `result`가 초기화 되지 않을 수 있다며 컴파일러가 불평할 것이다.
### STEP 3
어서션까지 추가한 후 테스트에 통과하면 [(3)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-13.md#3) `try`키워드와 `catch` 블록을 삭제한다.
``` diff
class ResourcePool {
  public Resource get() {
    Resource result;
    if (available.isEmpty()) {
      result = Resource.create();
      allocated.add(result);
    } else {
-     try {
      result = available.pop();
      allocated.add(result);
-     } catch (NoSuchElementException e) {
-       throw new AssertionError("도달 불가");
-     }
    }
    return result;
  }

  private Deque<Resource> available;
  private List<Resource> allocated;
}
```
[(4)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-13.md#4) 한 번 더 테스트에 통과하면 이번 리팩터링은 끝이다.
##### 더 가다듬기
그런데 이번 리팩터링의 결과로 얻어진 코드에는 정리할 거리가 더 있을 때가 많다. 이번에도 마찬가지다.
### STEP 4
먼저 [8.6 문장 슬라이드하기(Slide Statements)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-6.md)부터 적용해보자.
``` diff
class ResourcePool {
  public Resource get() {
    Resource result;
    if (available.isEmpty()) {
      result = Resource.create();
-     allocated.add(result);
    } else {
      result = available.pop();
-     allocated.add(result);
    }
+   allocated.add(result);    
    return result;
  }

  private Deque<Resource> available;
  private List<Resource> allocated;
}
```
### STEP 5
그런 다음 `if/else` 쌍을 3항 연산자로 바꾼다.
``` diff
class ResourcePool {
  public Resource get() {
-   Resource result;
+   Resource result = available.isEmpty() ? Resource.create() : available.pop();
-   if (available.isEmpty()) {
-     result = Resource.create();
-   } else {
-     result = available.pop();
-   }
    allocated.add(result);    
    return result;
  }

  private Deque<Resource> available;
  private List<Resource> allocated;
}
```
한결 깔끔해졌다.

- [목차](https://github.com/wonder13662/refactoring-v2/blob/writing/README.md)
- [11 API 리팩터링](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11)
- [11.12 오류 코드를 예외로 바꾸기(Replace Error Code with Exception)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-12.md)
- [12 상속 다루기](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12)
- [12.1 메서드 올리기(Pull Up Method)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-1.md)