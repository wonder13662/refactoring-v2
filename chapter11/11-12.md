# 11.12 오류 코드를 예외로 바꾸기(Replace Error Code with Exception)
``` diff
if (data)
  return new ShippingRules(data);
else
- return -23;
+ throw new OrderProcessingError(-23);
```

## 배경
내가 프로그래밍을 시작할 당시엔 오류 코드(error code)를 사용하는 게 보편적이었다. 함수를 호출하면 언제든지 오류를 반환할 수 있었고, 그래서 오류 코드 검사를 빼먹으면 안 됐다.오류 코드를 검사해서 발생한 오류를 직접 처리하거나 다른 누군가가 처리해주길 기대하며 콜스택 위로 던져보냈다.

예외는 프로그래밍 언어에서 제공하는 독립적인 오류 처리 매커니즘이다. 오류가 발견되면 예외를 던진다. 그러면 적절한 예외 핸들러를 찾을 때까지 콜스택을 타고 위로 전파된다(핸들러를 찾지 못하면 보통은 단순할 정도로 극단적인 기본 동작이 수행된다). 예외를 사용하면 오류 코드를 일일이 검사하거나 오류를 식별해 콜스택 위로 던지는 일을 신경 쓰지 않아도 된다. 예외에는 독자적인 흐름이 있어서 프로그램의 나머지에서는 오류 발생에 따른 복잡한 상황에 대처하는 코드를 작성하거나 읽을 일이 없게 해준다.

예외는 정교한 매커니즘이지만 대다수의 다른 정교한 매커니즘과 같이 정확하게 사용할 때만 최고의 효과를 낸다. 예외는 정확히 예상 밖의 동작일 때만 쓰여야 한다. 달리 말하면 프로그램의 정상 동작 범우에 들지 않는 오류를 나타낼 때만 쓰여야 한다. 괜찮은 경험 법칙이 하나 있다. 예외를 던지는 코드를 프로그램 종료 코드로 바꿔도 프로그램이 여전히 정상 동작할지를 따져보는 것이다. 정상 동작하지 않을 것 같다면 예외를 사용하지 말라는 신호다. 예외 대신 오류를 검출하여 프로그램을 정상 흐름으로 되돌리게끔 처리해야 한다.
## 절차
### (1)
콜스택 상위에 해당 예외를 처리할 예외 핸들러를 작성한다.
- 이 핸들러는 처음에는 모든 예외를 다시 던지게 해둔다.
- 적절한 처리를 해주는 핸들러가 이미 있다면 지금의 콜스택도 처리할 수 있도록 확장한다.
### (2)
테스트한다.
### (3)
해당 오류 코드를 대체할 예외와 그 밖의 예외를 구분할 식별 방법을 찾는다.
- 사용하는 프로그래밍 언어에 맞게 선택하면 된다. 대부분 언어에서는 서브클래스를 사용하면 될 것이다.
### (4)
정적 검사를 수행한다.
### (5)
catch 절을 수정하여 직접 처리할 수 있는 예외는 적절히 대처하고 그렇지 않은 예외는 다시 던진다.
### (6)
테스트한다.
### (7)
오류 코드를 반환하는 곳 모두에서 예외를 던지도록 수정한다. 하나씩 수정할 때마다 테스트한다.
### (8)
모두 수정했다면 그 오류 코드를 콜스택 위로 전달하는 코드를 모두 제거한다. 하나씩 수정할 때마다 테스트한다.
- 먼저 오류 코드를 검사하는 부분을 함정(trap)으로 바꾼 다음, 함정에 걸려들지 않는지 테스트한 후 제거하는 전략을 권한다. 함정에 걸려드는 곳이 있다면 오류 코드를 검사하는 코드가 아직 남아 있다는 뜻이다. 함정을 무사히 피했다면 안심하고 본문을 정리하자([8.9 죽은 코드 제거하기(Remove Dead Code)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-9.md))
## 예시
전역 테이블에서 배송지의 배송 규칙을 알아내는 코드를 생각해보자.
``` javascript
function localShippingRules(country) {
  const data = countryData.shippingRules[country];
  if (data) return new ShippingRules(data);
  else return -23;
}
```
이 코드는 국가 정보(country)가 유효한지를 이 함수 호출 전에 다 검증했다고 가정한다. 따라서 이 함수에서 오류가 난다면 무언가 잘못됐음을 뜻한다. 다음과 같이 호출한 곳에서는 반환된 오류 코드를 검사하여 오류가 발견되면 위로 전파한다.
``` javascript
function calculateShippingCosts(anOrder) {
  // 관련 없는 코드
  const shippingRules = localShippingRules(anOrder.country);
  if (shippingRules < 0) return shippingRules; // 오류 전파
  // 더 관련 없는 코드
}
```
더 윗단 함수는 오류를 낸 주문을 오류 목록(`errorList`)에 넣는다.
``` javascript
// 최상위
const status = calculateShippingCosts(orderData);
if (status < 0) errorList.push({ order: orderData, errorCode: status });
```
여기서 가장 먼저 고려할 것은 이 오류가 '예상된 것이냐'다. `localShippingRules()`는 배송 규칙들이 `countryData`에 제대로 반영되어 있다고 가정해도 되나? `country` 인수가 전역 데이터에 저장된 키들과 일치하는 곳에서 가져온 것인가, 아니면 앞서 검증을 받았나?

이 질문들의 답이 긍정적이면 (즉, 예상할 수 있는 정상 동작 범주에 든다면) 오류 코드를 예외로 바꾸는 이번 리팩터링을 적용할 준비가 된 것이다.
### STEP 1
[(1)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-12.md#1) 가장 먼저 최상위에 예외 핸들러를 갖춘다. `localShippingRules()` 호출을 `try` 블록으로 감싸려 하지만 처리 로직은 포함하고 싶지 않다. 그런데 다음처럼 할 수는 없다.
``` javascript
// 최상위
try {
  const status = calculateShippingCosts(orderData);
} catch {
  // 예외 처리 로직
}
if (status < 0) errorList.push({ order: orderData, errorCode: status });
```
이렇게 하면 `status`의 유효범위가 `try` 블록으로 국한되어 조건문에서 검사할 수 없기 때문이다.
그래서 `status` 선언과 초기화를 분리해야 한다. 평소라면 좋아하지 않을 방식이지만 지금은 어쩔 수 없다.
``` diff
function localShippingRules(country) {
  const data = countryData.shippingRules[country];
  if (data) return new ShippingRules(data);
  else return -23;
}

function calculateShippingCosts(anOrder) {
  // 관련 없는 코드
  const shippingRules = localShippingRules(anOrder.country);
  if (shippingRules < 0) return shippingRules; // 오류 전파
  // 더 관련 없는 코드
}

// 최상위
-const status = calculateShippingCosts(orderData);
+let status;
+status = calculateShippingCosts(orderData);
if (status < 0) errorList.push({ order: orderData, errorCode: status });
```
### STEP 2
이제 함수 호출을 `try/catch` 블록으로 감쌀 수 있다.
``` diff
function localShippingRules(country) {
  const data = countryData.shippingRules[country];
  if (data) return new ShippingRules(data);
  else return -23;
}

function calculateShippingCosts(anOrder) {
  // 관련 없는 코드
  const shippingRules = localShippingRules(anOrder.country);
  if (shippingRules < 0) return shippingRules; // 오류 전파
  // 더 관련 없는 코드
}

// 최상위
let status;
+try {
  status = calculateShippingCosts(orderData);
+} catch(e) {
+ throw e;
+}
if (status < 0) errorList.push({ order: orderData, errorCode: status });
```
잡은 예외는 모두 다시 던져야 한다. 다른 곳에서 발생한 예외를 무심코 삼켜버리고 싶진 않을테니 말이다. 
### STEP 3
호출하는 쪽 코드의 다른 부분에서도 주문을 오류 목록에 추가할 일이 있을 수 있으니 적절한 핸들러가 이미 구비되어 있을 수 있다. 그렇다면 그 `try` 블록을 수정해서 `calculateShippingCosts()` 호출을 포함시킨다.

[(3)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-12.md#3) 이번 리팩터링으로 추가된 예외만을 처리하고자 한다면 다른 예외와 구별할 방법이 필요하다. 별도의 클래스를 만들어서 할 수도 있고 특별한 값을 부여하는 방법도 있다. 예외를 클래스 기반으로 처리하는 프로그래밍 언어가 많은데, 이런 경우라면 서브클래스를 만드는 게 가장 자연스럽다. (현재의) 자바스크립트는 여기 해당하지 않지만, 나는 다음처럼 하는 걸 좋아한다.
``` javascript
class OrderProcessingError extends Error {
  constructor(errorCode) {
    super(`주문 처리 오류: ${errorCode}`);
    this.code = errorCode;
  }
  get name() { return "OrderProcessingError" }
}
```
### STEP 4
[(5)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-12.md#5) 이 클래스가 준비되면 오류 코드를 처리할 때와 같은 방식으로 이 예외 클래스를 처리하는 로직을 추가할 수 있다.
``` diff
function localShippingRules(country) {
  const data = countryData.shippingRules[country];
  if (data) return new ShippingRules(data);
  else return -23;
}

function calculateShippingCosts(anOrder) {
  // 관련 없는 코드
  const shippingRules = localShippingRules(anOrder.country);
  if (shippingRules < 0) return shippingRules; // 오류 전파
  // 더 관련 없는 코드
}

+class OrderProcessingError extends Error {
+ constructor(errorCode) {
+   super(`주문 처리 오류: ${errorCode}`);
+   this.code = errorCode;
+ }
+ get name() { return "OrderProcessingError" }
+}

// 최상위
let status;
try {
  status = calculateShippingCosts(orderData);
} catch(e) {
+ if (e instanceof OrderProcessingError)
+   errorList.push({ order: orderData, errorCode: e.code });
+ else
    throw e;
}
if (status < 0) errorList.push({ order: orderData, errorCode: status });
```
### STEP 5
[(7)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-12.md#7)그런 다음 오류 검출 코드를 수정하여 오류 코드 대신 이 예외를 던지도록 한다.
``` diff
function localShippingRules(country) {
  const data = countryData.shippingRules[country];
  if (data) return new ShippingRules(data);
- else return -23;
+ else throw new OrderProcessingError(-23);
}

function calculateShippingCosts(anOrder) {
  // 관련 없는 코드
  const shippingRules = localShippingRules(anOrder.country);
  if (shippingRules < 0) return shippingRules; // 오류 전파
  // 더 관련 없는 코드
}

class OrderProcessingError extends Error {
  constructor(errorCode) {
    super(`주문 처리 오류: ${errorCode}`);
    this.code = errorCode;
  }
  get name() { return "OrderProcessingError" }
}

// 최상위
let status;
try {
  status = calculateShippingCosts(orderData);
} catch(e) {
  if (e instanceof OrderProcessingError)
    errorList.push({ order: orderData, errorCode: e.code });
  else
    throw e;
}
if (status < 0) errorList.push({ order: orderData, errorCode: status });
```
### STEP 6
[(8)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-12.md#8) 코드를 다 작성했고 테스트도 통과했다면 오류 코드를 전파하는 임시 코드를 제거할 수 있다. 하지만 나라면 먼저 다음처럼 함정을 추가한 후 테스트 해 볼 것이다.
``` diff
function localShippingRules(country) {
  const data = countryData.shippingRules[country];
  if (data) return new ShippingRules(data);
  else throw new OrderProcessingError(-23);
}

function calculateShippingCosts(anOrder) {
  // 관련 없는 코드
  const shippingRules = localShippingRules(anOrder.country);
- if (shippingRules < 0) return shippingRules; // 오류 전파
+ if (shippingRules < 0) throw new Error('오류 코드가 다 사라지지 않았습니다.');
  // 더 관련 없는 코드
}

class OrderProcessingError extends Error {
  constructor(errorCode) {
    super(`주문 처리 오류: ${errorCode}`);
    this.code = errorCode;
  }
  get name() { return "OrderProcessingError" }
}

// 최상위
let status;
try {
  status = calculateShippingCosts(orderData);
} catch(e) {
  if (e instanceof OrderProcessingError)
    errorList.push({ order: orderData, errorCode: e.code });
  else
    throw e;
}
if (status < 0) errorList.push({ order: orderData, errorCode: status });
```
### STEP 7
이 함정에 걸려들지 않는다면 이 줄 전체를 제거해도 안전하다. 오류를 콜스택 위로 전달하는 일은 예외 매커니즘이 대신 처리해줄 것이기 때문이다.
``` diff
function localShippingRules(country) {
  const data = countryData.shippingRules[country];
  if (data) return new ShippingRules(data);
  else throw new OrderProcessingError(-23);
}

function calculateShippingCosts(anOrder) {
  // 관련 없는 코드
  const shippingRules = localShippingRules(anOrder.country);
- if (shippingRules < 0) throw new Error('오류 코드가 다 사라지지 않았습니다.');
  // 더 관련 없는 코드
}

class OrderProcessingError extends Error {
  constructor(errorCode) {
    super(`주문 처리 오류: ${errorCode}`);
    this.code = errorCode;
  }
  get name() { return "OrderProcessingError" }
}

// 최상위
let status;
try {
  status = calculateShippingCosts(orderData);
} catch(e) {
  if (e instanceof OrderProcessingError)
    errorList.push({ order: orderData, errorCode: e.code });
  else
    throw e;
}
-if (status < 0) errorList.push({ order: orderData, errorCode: status });
```
### STEP 8
이제는 필요 없어진 `status` 변수 역시 제거할 수 있다.
``` diff
function localShippingRules(country) {
  const data = countryData.shippingRules[country];
  if (data) return new ShippingRules(data);
  else throw new OrderProcessingError(-23);
}

function calculateShippingCosts(anOrder) {
  // 관련 없는 코드
  const shippingRules = localShippingRules(anOrder.country);
  // 더 관련 없는 코드
}

class OrderProcessingError extends Error {
  constructor(errorCode) {
    super(`주문 처리 오류: ${errorCode}`);
    this.code = errorCode;
  }
  get name() { return "OrderProcessingError" }
}

// 최상위
-let status;
try {
- status = calculateShippingCosts(orderData);
+ calculateShippingCosts(orderData);
} catch(e) {
  if (e instanceof OrderProcessingError)
    errorList.push({ order: orderData, errorCode: e.code });
  else
    throw e;
}
```

- [목차](https://github.com/wonder13662/refactoring-v2/blob/writing/README.md)
- [11 API 리팩터링](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11)
- [11.11 수정된 값 반환하기(Return Modified Value)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-11.md)
- [11.13 예외를 사전확인으로 바꾸기(Replace Exception with Precheck)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-13.md)
