### 11.6 질의 함수를 매개변수로 바꾸기(Replace Query with Parameter)
- 반대 리팩터링: [11.5 매개변수를 질의 함수로 바꾸기(Replace Parameter with Query)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-5.md)
``` diff
-targetTemperature(aPlan)
+targetTemperature(aPlan, thermostat.currentTemperature)

-function targetTemperature(aPlan) {
+function targetTemperature(aPlan, currentTemperature) {
- currentTemperature = thermostat.currentTemperature;
  // 생략
```

#### 배경
코드를 읽다 보면 함수 안에 두기엔 거북한 참조를 발견할 때가 있다. 전역 변수를 참조한다거나(같은 모듈 안에서라도) 제거하길 원하는 원소를 참조하는 경우가 여기 속한다. 이 문제는 해당 참조를 매개변수로 바꿔 해결할 수 있다. 참조를 풀어내는 책임을 호출자로 옮기는 것이다.

이런 상황 대부분은 코드의 의존 관계를 바꾸려 할 때 벌어진다. 예컨대 대상 함수가 더 이상(매개변수화하려는) 특정 원소에 의존하길 원치 않을 때 일어난다. 이때 두 극단 사이에서 적절한 균형을 찾아야 한다. 한쪽 끝은 모든 것을 매개변수로 바꿔 아주 길고 반복적인 매개변수 목록을 만드는 것이고, 다른 쪽 끝은 함수들끼리 많은 것을 공유하여 수많은 결합을 만들어내는 것이다. 대다수 까다로운 결정이 그렇듯, 이 역시 한 시점에 내린 결정이 영원히 옳다고 할 수는 없는 문제다. 따라서 프로그램을 더 잘 이해하게 됐을 때 더 나은 쪽으로 개선하기 쉽게 설계해두는 게 중요하다.

똑같은 값을 건네면 매번 똑같은 결과를 내는 함수는 다루기 쉽다. 이런 성질을 '참조 투명성'이라고 한다. 참조 투명하지 않은 원소에 접근하는 모든 함수는 참조 투명성을 잃게 되는데, 이 문제는 해당 원소를 매개변수로 바꾸면 해결된다. 책임이 호출자로 옮겨진다는 점을 고려해야 하지만, 모듈을 참조 투명하게 만들어 얻는 장점은 대체로 아주 크다. 그래서 모듈을 개발할 때 순수 함수들을 따로 구분하고, 프로그램의 입출력과 기타 가변 원소들을 다루는 로직으로 순수 함수들의 겉을 감싸는 패턴을 많이 활용한다. 그리고 이번 리팩터링을 활용하면 프로그램의 일부를 순수 함수로 바꿀 수 있으며, 결과적으로 그 부분은 테스트하거나 다루기가 쉬워진다.

이 리팩터링에도 단점은 있다. 질의 함수를 매개변수로 바꾸면 어떤 값을 제공할지를 호출자가 알아내야 한다. 결국 호출자가 복잡해지는데, 이왕이면 고객(호출자)의 삶이 단순해지도록 설계하자는 내 평소 지론과 배치된다. 이 문제는 결국 책임 소재를 프로그램의 어디에 배정하느냐의 문제로 귀결된다. 답을 찾기가 쉽지 않으며 항상 정답이 있는 것도 아니다. 프로젝트를 진행하면서 균형점이 이리저리 옮겨질 수 있으니 이 리팩터링(과 그 반대 리팩터링)과는 아주 친해져야 한다.
#### 절차
##### (1)
[6.3 변수 추출하기(Extract Variable)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-3.md)로 질의 코드를 함수 본문의 나머지 코드와 분리한다.
##### (2)
함수 본문 중 해당 질의를 호출하지 않는 코드들을 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md) 한다.
- 이 함수의 이름은 나중에 수정해야 하니 검색하기 쉬운 이름으로 짓는다.
##### (3)
방금 만든 변수를 [6.4 변수 인라인하기(Inline Variable)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-4.md)하여 제거한다.
##### (4)
원래 함수도 [6.4 변수 인라인하기(Inline Variable)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-4.md)하여 한다.
##### (5)
새 함수의 이름을 원래 함수의 이름으로 고쳐준다.
#### 예시
간단하지만 거추장스러운 코드를 준비했다. 실내온도 제어 시스템이다. 사용자는 온도조절기(thermostat)로 온도를 설정할 수 있지만, 목표 온도는 난방 계획에서 정한 범위에서만 선택할 수 있다.
``` javascript
class HeatingPlan {
  get targetTemperature() {
    if (thermostat.selectedTemperature > this._max) return this._max;
    else if (thermostat.selectedTemperature < this._min ) return this._min;
    else return thermostat.selectedTemperature;
  }
}

// 호출자
if (thePlan.targetTemperature > thermostat.currentTemperature) setToHeat();
else if (thePlan.targetTemperature < thermostat.currentTemperature) setToCool();
else setOff();
```
내가 이 시스템의 사용자라면 내 바람보다 난방 계획이 우선한다는 사실에 짜증 날 것이다. 하지만 개발자로서의 나는 `targetTemperature()` 메서드가 전역 객체인 `thermostat`에 의존한다는 데 더 신경이 쓰인다. 그러니 이 전역 객체에 건네는 질의 메서드를 매개변수로 옮겨서 의존성을 끊어보자.
##### STEP 1
[(1)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-6.md#1) 첫 번째로 할 일은 [6.3 변수 추출하기(Extract Variable)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-3.md)를 이용하여 이 메서드에서 사용할 매개변수를 준비하는 것이다.
``` diff
class HeatingPlan {
  get targetTemperature() {
+   const selectedTemperature = thermostat.selectedTemperature;
-   if (thermostat.selectedTemperature > this._max) return this._max;
+   if (selectedTemperature > this._max) return this._max;
-   else if (thermostat.selectedTemperature < this._min ) return this._min;
+   else if (selectedTemperature < this._min ) return this._min;
-   else return thermostat.selectedTemperature;
+   else return selectedTemperature;
  }
}

// 호출자
if (thePlan.targetTemperature > thermostat.currentTemperature) setToHeat();
else if (thePlan.targetTemperature < thermostat.currentTemperature) setToCool();
else setOff();
```
##### STEP 2
[(2)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-6.md#2) 이제 매개변수의 값을 구하는 코드를 제외한 나머지를 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md)하기가 한결 수월해졌다.
``` diff
class HeatingPlan {
  get targetTemperature() {
    const selectedTemperature = thermostat.selectedTemperature;
-   if (selectedTemperature > this._max) return this._max;
-   else if (selectedTemperature < this._min ) return this._min;
-   else return selectedTemperature;
+   return this.xxNEWtargetTemperature(selectedTemperature);
  }

+ xxNEWtargetTemperature(selectedTemperature) {
+   if (selectedTemperature > this._max) return this._max;
+   else if (selectedTemperature < this._min ) return this._min;
+   else return selectedTemperature;
+ }
}

// 호출자
if (thePlan.targetTemperature > thermostat.currentTemperature) setToHeat();
else if (thePlan.targetTemperature < thermostat.currentTemperature) setToCool();
else setOff();
```
##### STEP 3
[(3)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-6.md#3) 다음으로 방금 추출한 변수를 [6.4 변수 인라인하기(Inline Variable)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-4.md)하면 원래 메서드에는 단순한 호출만 남게 된다.
``` diff
class HeatingPlan {
  get targetTemperature() {
-   const selectedTemperature = thermostat.selectedTemperature;
-   return this.xxNEWtargetTemperature(selectedTemperature);
+   return this.xxNEWtargetTemperature(thermostat.selectedTemperature);
  }

  xxNEWtargetTemperature(selectedTemperature) {
    if (selectedTemperature > this._max) return this._max;
    else if (selectedTemperature < this._min ) return this._min;
    else return selectedTemperature;
  }
}

// 호출자
if (thePlan.targetTemperature > thermostat.currentTemperature) setToHeat();
else if (thePlan.targetTemperature < thermostat.currentTemperature) setToCool();
else setOff();
```
##### STEP 4
[(4)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-6.md#4) 이어서 이 메서드까지 [6.2 함수 인라인하기(Inline Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-2.md) 한다.
``` diff
class HeatingPlan {
  get targetTemperature() {
    return this.xxNEWtargetTemperature(thermostat.selectedTemperature);
  }

  xxNEWtargetTemperature(selectedTemperature) {
    if (selectedTemperature > this._max) return this._max;
    else if (selectedTemperature < this._min ) return this._min;
    else return selectedTemperature;
  }
}

// 호출자
-if (thePlan.targetTemperature > thermostat.currentTemperature) setToHeat();
+if (thePlan.xxNEWtargetTemperature(thermostat.selectedTemperature) > thermostat.currentTemperature) setToHeat();
-else if (thePlan.targetTemperature < thermostat.currentTemperature) setToCool();
+else if (thePlan.xxNEWtargetTemperature(thermostat.selectedTemperature) < thermostat.currentTemperature) setToCool();
else setOff();
```
##### STEP 5
이제 새 메서드의 이름을 원래 메서드의 이름으로 바꿀 차례다. 앞서 이 메서드의 이름을 검색하기 쉽게 만들어 놓은 덕에 쉽게 바꿀 수 있다(접두어만 제거하면 된다).
``` diff
class HeatingPlan {
  get targetTemperature() {
    return this.xxNEWtargetTemperature(thermostat.selectedTemperature);
  }

- xxNEWtargetTemperature(selectedTemperature) {
+ targetTemperature(selectedTemperature) {  
    if (selectedTemperature > this._max) return this._max;
    else if (selectedTemperature < this._min ) return this._min;
    else return selectedTemperature;
  }
}

// 호출자
-if (thePlan.xxNEWtargetTemperature(thermostat.selectedTemperature) > thermostat.currentTemperature) setToHeat();
+if (thePlan.targetTemperature(thermostat.selectedTemperature) > thermostat.currentTemperature) setToHeat();
-else if (thePlan.xxNEWtargetTemperature(thermostat.selectedTemperature) < thermostat.currentTemperature) setToCool();
+else if (thePlan.targetTemperature(thermostat.selectedTemperature) < thermostat.currentTemperature) setToCool();
else setOff();
```
> 이 리팩터링을 수행하면 호출하는 쪽 코드는 전보다 다루기 어려워지는 게 보통이다. '의존성을 모듈 바깥으로 밀어낸다'함은 그 의존성을 처리하는 책임을 호출자에게 지운다는 뜻이기 때문이다. 결합도를 낮춘 효과에 대한 반대급부인 셈이다. 그런데 이 리팩터링으로 얻은 것이 온도조절기 객체와의 결합을 제거한 것만은 아니다. `HeatingPlan` 클래스는 불변이 되었다. 모든 필드가 생성자에서 설정되며, 필드를 변경할 수 있는 메서드는 없다.(이 클래스의 다른 코드를 생략한 것은 독자 여러분이 굳이 다 살펴보지 않도록 배려한 것이니 그냥 나를 믿어주기 바란다). 난방 계획도 불변이므로 온도조절기 참조를 메서드 밖으로 옮긴 것이 `targetTemperature()`를 참조 투명하게 만들어준다. 따라서 같은 객체의 `targetTemperature()`에 같은 인수를 넘겨 호출하면 언제나 똑같은 결과를 돌려줄 것이다. 난방 계획의 메서드도 모두 참조 투명하다면 이 클래스는 테스트하고 다루기가 훨씬 쉬워졌을 것이다.

#### 자바스크립트와 불별 클래스
자바스크립트의 클래스 모델에서는 객체 안의 데이터를 직접 얻어낼 방법이 항상 존재하기 때문에 불변 클래스임을 보장하는 수단이 없다는 문제가 있다. 하지만 클래스를 불변으로 설계했음을 알리고 그렇게 사용하라고 제안하는 것만으로도 충분한 값어치를 할 때가 많다. 클래스에 불변 성격을 부여하는 건 훌륭한 전략이며, 질의 함수를 매개변수로 바꾸기 리팩터링은 이 전략을 실행하는 데 큰 도움이 된다.