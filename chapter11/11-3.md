# 11.3 플래그 인수 제거하기(Remove Flag Argument)
``` diff
-function setDimension(name, value) {
- if (name === "height") {
-   this._height = value;
-   return;
- }
- if (name === "width") {
-   this._width = value;
-   return;
- }
-}
+function setHeight(value) {this._height = value;}
+function setWidth(value) {this._width = value;}
```

## 배경
플래그 인수(flag argument)란 호출되는 함수가 실행할 로직을 호출하는 쪽에서 선택하기 위해 전달하는 인수다. 다음 함수를 보자.
``` javascript
function bookConcert(aCustomer, isPremium) {
  if (isPremium) {
    // 프리미엄 예약용 로직
  } else {
    // 일반 예약용 로직
  }
}
```
콘서트를 프리미엄으로 예약하려면 다음처럼 호출해야 한다.
``` javascript
bookConcert(aCustomer, true);
```
플래그 인수가 열거형일 수도 있다.
``` javascript
bookConcert(aCustomer, CustomerType.PREMIUM);
```
문자열(혹은 해당 프로그래밍 언어가 제공하는 또 다른 타입)을 쓰기도 한다.
``` javascript
bookConcert(aCustomer, "premium");
```
내가 플래그 인수를 싫어하는 이유가 있다. 호출할 수 있는 함수들이 무엇이고 어떻게 호출해야 하는지를 이해하기가 어려워지기 때문이다. 나는 API를 익힐 때 주로 함수 목록부터 살펴보는데, 플래그 인수가 있으면 함수들의 기능 차이가 잘 드러나지 않는다. 사용할 함수를 선택한 후에도 플래그 인수로 어떤 값을 넘겨야 하는지를 또 알아내야 한다. 불리언 플래그는 코드를 읽는 이에게 뜻은 온전히 전달하지 못하기 때문에 더욱 좋지 못하다. 함수에 전달한 `true`의 의미가 대체 뭐란 말인가? 이보다는 다음처럼 특정한 기능 하나만 수행하는 명시적인 함수를 제공하는 편이 훨씬 깔끔하다.
``` javascript
preimiumBookConcert(aCustomer);
```
이렇게 생긴 인수라고 해서 다 플래그 인수는 아니다. 플래그 인수가 되려면 호출하는 쪽에서 불리언 값으로 (프로그램에서 사용되는 데이터가 아닌) 리터럴 값을 건네야 한다. 또한, 호출되는 함수는 그 인수를 (다른 함수에 전달하는 데이터가 아닌) 제어 흐름을 결정하는 데 사용해야 한다.

플래그 인수를 제거하면 코드가 깔끔해짐은 물론 프로그래밍 도구에도 도움을 준다. 예컨대 코드 분석 도구는 프리미엄 로직 호출과 일반 로직 호출의 차이를 더 쉽게 파악할 수 있게 된다.

함수 하나에서 플래그 인수를 두 개 이상 사용하면 플래그 인수를 써야 하는 합당한 근거가 될 수 있다. 플래그 인수 없이 구현하려면 플래그 인수들의 가능한 조합 수만큼의 함수를 만들어야 하기 때문이다. 그런데 다른 관점에서 보자면, 플래그 인수가 둘 이상이면 함수 하나가 너무 많은 일을 처리하고 있다는 신호이기도 하다. 그러니 같은 로직을 조합해내는 더 간단한 함수를 만들 방법을 고민해 봐야 한다.
## 절차
### (1)
매개변수로 주어질 수 있는 값 각각에 대응하는 명시적인 함수들을 생성한다.
- 주가 되는 함수에 깔끔한 분배 조건문이 포함되어 있다면 [10.1 조건문 분해하기(Decompose Conditional)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-1.md)로 명시적 함수들을 생성하자. 그렇지 않다면 래핑 함수(wrapping function) 형태로 만든다.
### (2)
원래 함수를 호출하는 코드들을 모두 찾아서 각 리터럴 값에 대응되는 명시적 함수를 호출하도록 수정한다.
## 예시
코드를 살펴보던 중 배송일자를 계산하는 호출을 발견했다고 치자. 그중 일부는 다음처럼 호출한다.
``` javascript
aShipment.deliveryDate = deliveryDate(anOrder, true);
```
다른 곳에서는 다음처럼 호출한다.
``` javascript
aShipment.deliveryDate = deliveryDate(anOrder, false);
```
이 코드들을 확인한 나는 곧바로 "이 불리언 값이 뭘 의미하지?"란 의문이 떠올랐다.
`deliveryDate()` 함수의 코드는 다음과 같았다.
``` javascript
function deliveryDate(anOrder, isRush) {
  if (isRush) {
    let deliveryTime;
    if (["MA", "CT"].includes(anOrder.deliveryState)) deliveryTime = 1;
    else if(["NY", "NH"].includes(anOrder.deliveryState)) deliveryTime = 2;
    else deliveryTime = 3;
    return anOrder.placedOn.plusDays(1 + deliveryTime);
  } else {
    let deliveryTime;
    if (["MA", "CT", "NY"].includes(anOrder.deliveryState)) deliveryTime = 2;
    else if(["ME", "NH"].includes(anOrder.deliveryState)) deliveryTime = 3;
    else deliveryTime = 4;
    return anOrder.placedOn.plusDays(2 + deliveryTime);
  }
}
```
즉, 호출하는 쪽에서는 이 불리언 리터럴 값을 이용해서 어느 쪽 코드를 실행할지를 정한 것이다. 전형적인 플래그 인수다. 이 함수가 어느 코드를 실행할지는 전적으로 호출자의 지시에 따른다. 따라서 명시적인 함수를 사용해 호출자의 의도를 분명히 밝히는 편이 나을 것이다.
### STEP 1-1
[(1)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-3.md#1)이 예에서라면 [10.1 조건문 분해하기(Decompose Conditional)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-1.md)를 적용할 수 있는데, 결과는 다음과 같다.
``` javascript
function deliveryDate(anOrder, isRush) {
  if (isRush) return rushDeliveryDate(anOrder);
  else return regularDeliveryDate(anOrder);
}

function rushDeliveryDate(anOrder) {
  let deliveryTime;
  if (["MA", "CT"].includes(anOrder.deliveryState)) deliveryTime = 1;
  else if(["NY", "NH"].includes(anOrder.deliveryState)) deliveryTime = 2;
  else deliveryTime = 3;
  return anOrder.placedOn.plusDays(1 + deliveryTime);
}

function regularDeliveryDate(anOrder) {
  let deliveryTime;
  if (["MA", "CT", "NY"].includes(anOrder.deliveryState)) deliveryTime = 2;
  else if(["ME", "NH"].includes(anOrder.deliveryState)) deliveryTime = 3;
  else deliveryTime = 4;
  return anOrder.placedOn.plusDays(2 + deliveryTime);
}
```
보다시피 새로 만든 두 함수가 호촐자의 의도를 더 잘 드러낸다. [(2)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-3.md#2) 따라서 다음 호출은 이렇게 바꿀 수 있다.
``` diff
-aShipment.deliveryDate = deliveryDate(anOrder, true);
+aShipment.deliveryDate = rushDelivery(anOrder);
```
나머지 호출도 같은 식으로 바꿔주면 된다.
모든 호출을 대체했다면 `deliveryDate()`를 제거한다.
##### 참고
플래그 인수를 싫어하는 이유는 불리언 값을 사용해서가 아니라, 불리언 값을 (변수와 같은) 데이터가 아닌 리터럴로 설정하기 때문이다. 가령 `deliveryDate()`를 호출하는 코드가 모두 다음처럼 생겼다면 어떨까?
``` javascript
const isRush = determinIfRush(anOrder);
aShipment.deliveryDate = deliveryDate(anOrder, isRush);
```
이런 상황이라면 나는 `deliveryDate()`의 시그니처에 불만이 없었을 것이다(여전히 [10.1 조건문 분해하기(Decompose Conditional)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-1.md)는 적용하고 싶어 할 테지만...)

한편 리터럴을 사용하는 곳과 데이터를 사용하는 곳이 혼재할 수도 있다. 그렇더라도 나라면 플래그 인수를 제거할 것이다. 단, 데이터를 사용하는 코드는 수정하지 않고 `deliveryDate()`도 제거하지 않을 것이다. 이렇게 하여 쓰임새가 다른 두 인터페이스를 모두 지원할 수 있다.
## 예시: 매개변수를 까다로운 방식으로 사용할 때
앞에서 본 것처럼 조건문을 쪼개면 이 리팩터링을 수행하는 게 수월해진다. 하지만 매개변수에 따른 분배 로직이 함수 핵심 로직의 바깥에 해당할 때만 이용할 수 있다(물론 그렇지 않더라도 이런 형태로 쉽게 리팩터링할 수 있다). 그런데 매개변수가 훨씬 까다로운 방식으로 사용될 때도 있다. 다음은 까다로운 버전의 `deliveryDate()`다.
``` javascript
function deliveryDate(anOrder, isRush) {
  let result;
  let deliveryTime;
  if (anOrder.deliveryState === "MA" || anOrder.deliveryState === "CT")
    deliveryTime = isRush ? 1 : 2;
  else if (anOrder.deliveryState === "NY" || anOrder.deliveryState === "NH") {
    deliveryTime = 2;
    if (anOrder.deliveryState === "NH" && !isRush)
      deliveryTime = 3;
  }
  else if (isRush)
    deliveryTime = 3;
  else if (anOrder.deliveryState === "ME")
    deliveryTime = 3;
  else
    deliveryTime = 4;
  result = anOrder.placedOn.plusDays(2 + deliveryTime);
  if (isRush) result = result.minusDays(1);
  return result;
}
```
이 코드에서 `isRush`를 최상위 분배 조건으로 뽑아내려면 생각보다 일이 커질 수도 있어 보인다.[(1)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-3.md#1)그렇다면 `deliveryDate()`를 감싸는 래핑 함수를 생각해볼 수 있다.
``` javascript
function rushDeliveryDate(anOrder) { return deliveryDate(anOrder, true); }
function regularDeliveryDate(anOrder) { return deliveryDate(anOrder, false); }
```
> 래핑 함수들을 독립적으로 정의했지만, 새로운 기능을 추가한 게 아니라 각각이 `deliveryDate()`의 기능의 일부만을 제공한다.

[(2)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-3.md#2) 이 두 함수를 추가했다면 호출하는 코드들을 앞에서 조건문을 쪼갰을 때와 똑같은 방식으로 대체할 수 있다.

> 매개변수를 데이터로 사용한 호출자가 하나도 없다면 이 함수들의 가시 범위를 제한하거나, 함수 이름을 (예컨대 `deliveryDateHelperOnly()`) 바꿔서 직접 호출하지 말라는 뜻을 명시했을 것이다.

- [목차](https://github.com/wonder13662/refactoring-v2/blob/writing)
- [11 API 리팩터링](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11)
- [11.2 함수 매개변수화하기(Parameterize Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-2.md)
- [11.4 객체 통째로 넘기기(Preserve Whole Object)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-4.md)