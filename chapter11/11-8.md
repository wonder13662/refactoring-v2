# 11.8 생성자를 팩터리 함수로 바꾸기(Replace Constructor with Factory Function)
``` diff
-leadEngineer = new Employee(document.leadEngineer, 'E');
+leadEngineer = createEngineer(document.leadEngineer);
```

## 배경
많은 객체 지향 언어에서 제공하는 생성자는 객체를 초기화하는 특별한 용도의 함수다. 실제로 새로운 객체를 생성할 때면 주로 생성자를 호출한다. 하지만 생성자에는 일반 함수에는 없는 이상한 제약이 따라붙기도 한다. 가령 자바 생성자는 반드시 그 생성자를 정의한 클래스의 인스턴스를 반환해야 한다. 서브클래스의 인스턴스나 프락시를 반환할 수는 없다. 생성자의 이름도 고정되어, 기본 이름보다 더 적절한 이름이 있어도 사용할 수 없다. 생성자를 호출하려면 특별한 연산자(많은 언어에서 `new`를 쓴다)를 사용해야 해서 일반 함수가 오길 기대하는 자리에는 쓰기 어렵다.

팩터리 함수에는 이런 제약이 없다. 팩터리 함수를 구현하는 과정에서 생성자를 호출할 수는 있지만, 원한다면 다른 무언가로 대체할 수 있다. 팩터리 함수를 구현하는 과정에서 생성자를 호출할 수는 있지만, 원한다면 다른 무언가로 대체할 수 있다.
## 절차
### (1)
팩터리 함수를 만든다. 팩터리 함수의 본문에서는 원래의 생성자를 호출한다.
### (2)
생성자를 호출하던 코드를 팩터리 함수 호출로 바꾼다.
### (3)
하나씩 수정할 때마다 테스트한다.
### (4)
생성자의 가시 범위가 최소가 되도록 제한한다.
## 예시
직원(employee) 유형을 다루는, 간단하지만 이상한 예를 살펴보자. 먼저 직원 클래스를 보자.
``` javascript
class Employee {
  constructor(name, typeCode) {
    this._name = name;
    this._typeCode = typeCode;
  }

  get name() { return this._name; }
  get type() {
    return Employee.legalTypeCodes[this._typeCode];
  }
  static get legalTypeCodes() {
    return {"E":"Engineer", "M":"Manager", "S":"Salesperson"};
  }
}
```
다음은 이 클래스를 사용하는 코드다.
``` javascript
// 호출자
candidate = new Employee(document.name, document.empType);
```
다음처럼도 사용한다.
``` javascript
// 호출자
const leadEngineer = new Employee(document.leadEngineer, 'E');
```
### STEP 1
[(1)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-8.md#1) 첫 번째로 할 일은 팩터리 함수 만들기다. 팩터리 본문은 단순히 생성자에 위임하는 방식으로 구현한다.
``` diff
class Employee {
  constructor(name, typeCode) {
    this._name = name;
    this._typeCode = typeCode;
  }

  get name() { return this._name; }
  get type() {
    return Employee.legalTypeCodes[this._typeCode];
  }
  static get legalTypeCodes() {
    return {"E":"Engineer", "M":"Manager", "S":"Salesperson"};
  }
}
+// 최상위
+function createEmployee(name, typeCode) {
+ return new Employee(name, typeCode);
+}
// 호출자
candidate = new Employee(document.name, document.empType);
// 호출자
const leadEngineer = new Employee(document.leadEngineer, 'E');
```
### STEP 2
그런 다음 생성자를 호출하는 곳을 찾아 수정한다. 한 번에 하나씩, 생성자 대신 팩터리 함수를 사용하게 바꾼다. 첫 번째 코드는 쉽게 바꿀 수 있다.
``` diff
class Employee {
  constructor(name, typeCode) {
    this._name = name;
    this._typeCode = typeCode;
  }

  get name() { return this._name; }
  get type() {
    return Employee.legalTypeCodes[this._typeCode];
  }
  static get legalTypeCodes() {
    return {"E":"Engineer", "M":"Manager", "S":"Salesperson"};
  }
}
// 최상위
function createEmployee(name, typeCode) {
  return new Employee(name, typeCode);
}
// 호출자
-candidate = new Employee(document.name, document.empType);
+candidate = createEmployee(document.name, document.empType);
// 호출자
const leadEngineer = new Employee(document.leadEngineer, 'E');
```
### STEP 3
두번째 코드를 바꾸려면 다음과 같은 모습의 새로운 팩터리 함수를 사용할 수도 있을 것이다.
``` diff
class Employee {
  constructor(name, typeCode) {
    this._name = name;
    this._typeCode = typeCode;
  }

  get name() { return this._name; }
  get type() {
    return Employee.legalTypeCodes[this._typeCode];
  }
  static get legalTypeCodes() {
    return {"E":"Engineer", "M":"Manager", "S":"Salesperson"};
  }
}
// 최상위
function createEmployee(name, typeCode) {
  return new Employee(name, typeCode);
}
// 호출자
candidate = createEmployee(document.name, document.empType);
// 호출자
-const leadEngineer = new Employee(document.leadEngineer, 'E');
+const leadEngineer = createEmployee(document.leadEngineer, 'E');
```
하지만 이건 내가 권장하는 코드 스타일이 아니다.(함수에 문자열 리터럴을 건네는 건 악취로 봐야한다). 그 대신 직원 유형을 팩터리 함수의 이름에 녹이는 방식을 권한다.
``` diff
class Employee {
  constructor(name, typeCode) {
    this._name = name;
    this._typeCode = typeCode;
  }

  get name() { return this._name; }
  get type() {
    return Employee.legalTypeCodes[this._typeCode];
  }
  static get legalTypeCodes() {
    return {"E":"Engineer", "M":"Manager", "S":"Salesperson"};
  }
}
// 최상위
function createEmployee(name, typeCode) {
  return new Employee(name, typeCode);
}
+function createEngineer(name) {
+ return new Employee(name, 'E');
+}
// 호출자
candidate = createEmployee(document.name, document.empType);
// 호출자
-const leadEngineer = new Employee(document.leadEngineer, 'E');
+const leadEngineer = createEngineer(document.leadEngineer);
```