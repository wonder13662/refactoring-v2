# 12.11 슈퍼클래스를 위임으로 바꾸기(Replace Superclass with Delegate)
``` diff
class List {...}
-class Stack extends List {...}
+class Stack {
+ constructor() {
+   this._storage = new List();
+ }
+}
```

## 배경
객체 지향 프로그래밍에서 상속은 기존 기능을 재활용하는 강력하고 손쉬운 수단이다. 기존 클래스를 상속하여 입맛에 맞게 오버라이드하거나 새 기능을 추가하면 된다. 하지만 상속이 혼란과 복잡도를 키우는 방식으로 이뤄지기도 한다.

상속을 잘못 적용한 예로는 자바의 스택 클래스가 유명하다. 자바의 스택은 리스트를 상속하고 있는데, 데이터를 저장하고 조작하는 리스트의 기능을 재활용하겠다는 생각이 초래한 결과다. 재활용이란 관점에서는 좋았지만 이 상속에는 문제가 있다. 리스트의 연산 중 스택에는 적용되지 않는 게 많음에도 그 모든 연산이 스택 인터페이스에 그대로 노출되는 게 아닌가! 이보다는 스택에서 리스트 객체를 필드에 저장해두고 필요한 기능만 위임했다면 더 멋졌을 것이다.

자바의 스택은 슈퍼클래스를 위임으로 바꾸는 이번 리팩터링을 적용해야 하는 좋은 예다. 슈퍼클래스의 기능들이 서브클래스에는 어울리지 않는다면 그 기능들을 상속을 통해 이용하면 안된다는 신호다.

제대로 된 상속이라면 서브클래스가 슈퍼클래스의 모든 기능을 사용함은 물론, 서브클래스의 인스턴스를 슈퍼클래스의 인스턴스로도 취급할 수 있어야 한다. 다시 말해, 슈퍼클래스가 사용되는 모든 곳에서 서브클래스의 인스턴스를 대신 사용해도 이상없이 동작해야 한다. 예컨대 이름과 엔진 크기 등을 속성으로 갖는 자동차 모델 클래스(타입)가 있다고 하자. 그러면 여기에 차량 식별 번호와 제조일자 메서드를 더하면 물리적인 자동차(인스턴스)를 표현하는 데 재활용할 수 있을거라 착각할 수 있다. 이는 흔하고 미묘한 모델링 실수로, 내가 [타입-인스턴스 동형이의어(type-instance homonym)](https://martinfowler.com/bliki/TypeInstanceHomonym.html)라고 부르는 것이다.

이상은 모두 혼란과 오류를 일으키는 예인 동시에 상속을 버리고 위임으로 갈아타 객체를 분리하면 쉽게 피할 수 있는 예다. 위임을 이용하면 기능 일부만 빌려올 뿐인, 서로 별개인 개념임이 명확해진다.

서브클래스 방식 모델링이 합리적일 때라도 슈퍼클래스를 위임으로 바꾸기도 한다. 슈퍼/서브클래스는 강하게 결합된 관계라서 슈퍼클래스를 수정하면 서브클래스가 망가지기 쉽기 때문이다. 위임에도 물론 단점이 있다. 위임의 기능을 이용할 호스트의 함수 모두를 전달 함수(forwarding function)로 만들어야 한다는 점이다. 전달 함수를 적성하기란 지루한 일이다. 하지만 아주 단순해서 문제가 생길 가능성은 적다.

이상의 이유로 "상속은 절대 사용하지 말라"고 조언하는 사람도 있다. 나는 동의하지 않는다. 상위 타입의 모든 메서드가 하위 타입에도 적용되고, 하위 타입의 모든 인스턴스가 상휘 타입의 인스턴스도 되는 등, 의미상 적합한 조건이라면 상속은 간단하고 효과적인 매커니즘이다. 이런 상황이 변하여 상속이 더는 최선의 방법이 아니게 되면 언제든 이번 리팩터링을 이용해 슈퍼클래스를 위임으로 바꿀 수 있다. 그래서 (왠만하면) 상속을 먼저 적용하고 (만일) 나중에 문제가 생기면 슈퍼클래스를 위임으로 바꾸라는 것이 나의 조언이다.

## 절차
### (1)
슈퍼클래스 객체를 참조하는 필드를 서브클래스에 만든다(이번 리팩터링을 끝마치면 슈퍼클래스가 위임 객체가 될 것이므로 이 필드를 '위임 참조'라 부르자). 위임 참조를 새로운 슈퍼클래스 인스턴스로 초기화한다.
### (2)
슈퍼클래스의 동작 각각에 대응하는 전달 함수를 서브클래스에 만든다(물론 위임 참조로 전달한다). 서로 관련된 함수끼리 그룹으로 묶어 진행하며, 그룹을 하나씩 만들 때마다 테스트한다.
- 대부붑은 전달 함수 각각을 테스트할 수 있을 것이다. 하지만 예컨대 게터와 세터 쌍은 둘 다 옮긴 후에야 테스트할 수 있다.
### (3)
슈퍼클래스의 동작 모두가 전달 함수로 오버라이드되었다면 상속 관계를 끊는다.
## 예시
최근에 고대 스크롤(scroll:두루마리 문서)을 보관하고 있는 오래된 도서관에 컨설팅을 해주었다. 스크롤들의 상세정보는 이미 카탈로그로 분류되어 있었는데, 각 스크롤에는 ID번호와 제목이 있었고, 그외 여러 가지 태그가 붙어 있었다.
```javascript
class CatalogItem {
  constructor(id, title, tags) {
    this._id = id;
    this._title = title;
    this._tags = tags;
  }

  get id() {
    return this._id;
  }
  get title() {
    return this._title;
  }
  hasTag(arg) {
    return this._tags.includes(arg);
  }
}
```
스크롤에는 정기 세척 이력이 필요했다. 그래서 카탈로그 아이템(CatalogItem)을 확장하여 세척 관련 데이터를 추가해 사용하였다.
```javascript
class Scroll extends CatalogItem {
  constructor(id, title, tags, dateLastCleaned) {
    super(id, title, tags);
    this._lastCleaned = dateLastCleaned;
  }

  needsCleaning(targetDate) {
    const threshold = this.hasTag('revered') ? 700 : 1500;
    return this.daysSinceLastCleaning(targetDate) > threshold;
  }

  daysSinceLastCleaning(targetDate) {
    return this._lastCleaned.until(targetDate, ChronoUnit.DAYS);
  }
}
```
지금까지는 흔한 모델링 실수의 예다. 물리적인 스크롤과 카탈로그 아이템에는 차이가 있다. 예컨대 석화병 치료법을 적어 놓은 스크롤은 사본이 여러 개임에도 카탈로그 아이템은 하나뿐이었다.

이런 종류의 오류에는 대부분 해법이 있다. 지금 예애서라면 제목과 태그로 사본을 구별할 수 있다. 데이터가 절대 변하지 않는다면 이런 대표성이 문제를 해결해 줄 것이다. 하지만 사본 중 하나의 내용을 수정해야 한다면 같은 카테고리 항목의 다른 사본들 모두가 올바르게 수정되는지를 주의해서 확인해야 한다.

이런 문제가 아니더라도 나라면 여전히 이 관계를 끊으려 할 것이다. 카탈로그 아이템을 스크롤의 슈퍼클래스로 사용한다면 미래에 이 코드를 읽는 프로그래머에게 혼란을 줄 터이니 좋은 모델이 아니다.

### STEP 1-1
[(1)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-11.md#1) 가장 먼저 `Scroll`에 카탈로그 아이템을 참조하는 속성을 만들고 슈퍼클래스(카탈로그 아이템)의 인스턴스를 새로 하나 만들어서 대입하자.
```diff
class CatalogItem {
  constructor(id, title, tags) {
    this._id = id;
    this._title = title;
    this._tags = tags;
  }

  get id() {
    return this._id;
  }
  get title() {
    return this._title;
  }
  hasTag(arg) {
    return this._tags.includes(arg);
  }
}

class Scroll extends CatalogItem {
  constructor(id, title, tags, dateLastCleaned) {
    super(id, title, tags);
+   this._catalogItem = new CatalogItem(id, title, tags);
    this._lastCleaned = dateLastCleaned;
  }

  needsCleaning(targetDate) {
    const threshold = this.hasTag('revered') ? 700 : 1500;
    return this.daysSinceLastCleaning(targetDate) > threshold;
  }

  daysSinceLastCleaning(targetDate) {
    return this._lastCleaned.until(targetDate, ChronoUnit.DAYS);
  }
}
```
### STEP 1-2
[(2)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-11.md#2) 그런 다음 이 서브클래스에서 사용하는 슈퍼클래스의 동작 각각에 대응하는 전달 메서드를 만든다.
```diff
class CatalogItem {
  constructor(id, title, tags) {
    this._id = id;
    this._title = title;
    this._tags = tags;
  }

  get id() {
    return this._id;
  }
  get title() {
    return this._title;
  }
  hasTag(arg) {
    return this._tags.includes(arg);
  }
}

class Scroll extends CatalogItem {
  constructor(id, title, tags, dateLastCleaned) {
    super(id, title, tags);
    this._catalogItem = new CatalogItem(id, title, tags);
    this._lastCleaned = dateLastCleaned;
  }

+ get id() {
+   return this._id;
+ }

+ get title() {
+   return this._title;
+ }

+ hasTag(arg) {
+   return this._tags.includes(arg);
+ }  

  needsCleaning(targetDate) {
    const threshold = this.hasTag('revered') ? 700 : 1500;
    return this.daysSinceLastCleaning(targetDate) > threshold;
  }

  daysSinceLastCleaning(targetDate) {
    return this._lastCleaned.until(targetDate, ChronoUnit.DAYS);
  }
}
```
### STEP 1-3
[(3)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-11.md#3)
이제 카탈로그 아이템과의 상속 관계를 끊는다.
```diff
class CatalogItem {
  constructor(id, title, tags) {
    this._id = id;
    this._title = title;
    this._tags = tags;
  }

  get id() {
    return this._id;
  }
  get title() {
    return this._title;
  }
  hasTag(arg) {
    return this._tags.includes(arg);
  }
}

-class Scroll extends CatalogItem {
+class Scroll {  
  constructor(id, title, tags, dateLastCleaned) {
-   super(id, title, tags);
    this._catalogItem = new CatalogItem(id, title, tags);
    this._lastCleaned = dateLastCleaned;
  }

  get id() {
    return this._id;
  }

  get title() {
    return this._title;
  }

  hasTag(arg) {
    return this._tags.includes(arg);
  }  

  needsCleaning(targetDate) {
    const threshold = this.hasTag('revered') ? 700 : 1500;
    return this.daysSinceLastCleaning(targetDate) > threshold;
  }

  daysSinceLastCleaning(targetDate) {
    return this._lastCleaned.until(targetDate, ChronoUnit.DAYS);
  }
}
```
#### 더 가다듬기
이것으로 슈퍼클래스를 위임으로 바꾸는 리팩터링은 끝이 났지만, 지금 예시에서는 할 일이 남았다.
### STEP 2-1
이번 리팩터링에서는 카탈로그 아이템의 역할을 스크롤의 속성으로 옮겼다. 그 결과 각각의 스크롤은 카탈로그 아이템의 '고유' 인스턴스를 하나씩 갖게 되었다. 이 리팩터링을 적용하는 많은 경우에서 문제될 게 없는 변화다. 하지만 지금 상황에서는 더 나은 모델이 있다. 도서관에 보관된 사본 스크롤 여섯 개 모두 단 하나의 석화병 카탈로그 아이템을 참조하게 하는 방법이다. 다시 말해, [9.5 값을 참조로 바꾸기(Change Value to Reference)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter09/9-5.md)를 하는 것이다.

하지만 값을 참조로 바꾸려면 먼저 해결해야 하는 문제가 있다. 원래의 상속 구조에서는 스크롤이 자신의 ID를 카탈로그 아이템의 ID 필드에 저장했다. 하지만 카탈로그 아이템을 참조로 바꾼다면 이 ID는 스크롤의 ID가 아닌 해당 카탈로그 아이템의 ID로 이용해야 한다. 다시 말해, 스크롤은 카탈로그 아이템의 ID를 빌려 쓰지 말고 자신만의 ID 필드를 새로 만들어야 한다. 옮기기 작업이자, 다른 한편으로는 쪼개기다.
```diff
class CatalogItem {
  constructor(id, title, tags) {
    this._id = id;
    this._title = title;
    this._tags = tags;
  }

  get id() {
    return this._id;
  }
  get title() {
    return this._title;
  }
  hasTag(arg) {
    return this._tags.includes(arg);
  }
}

class Scroll {  
  constructor(id, title, tags, dateLastCleaned) {
+   this._id = id;    
-   this._catalogItem = new CatalogItem(id, title, tags);
+   this._catalogItem = new CatalogItem(null, title, tags);
    this._lastCleaned = dateLastCleaned;
  }

  get id() {
    return this._id;
  }

  get title() {
    return this._title;
  }

  hasTag(arg) {
    return this._tags.includes(arg);
  }  

  needsCleaning(targetDate) {
    const threshold = this.hasTag('revered') ? 700 : 1500;
    return this.daysSinceLastCleaning(targetDate) > threshold;
  }

  daysSinceLastCleaning(targetDate) {
    return this._lastCleaned.until(targetDate, ChronoUnit.DAYS);
  }
}
```
### STEP 2-2
카탈로그 아이템에 ID를 `null`로 주는 것은 보통 위험 신호지만, 지금은 일처리 중간에 만들어진 임시 상태이니 넘어가도록 하자. 작업이 끝나면 이 스크롤은 올바른 ID를 통해 공유 카탈로그 아이템을 참조하게 될 것이다.

지금의 스크롤들은 다음 코드에 의해 컴퓨터로 읽혀진다.
```diff
class CatalogItem {
  constructor(id, title, tags) {
    this._id = id;
    this._title = title;
    this._tags = tags;
  }

  get id() {
    return this._id;
  }
  get title() {
    return this._title;
  }
  hasTag(arg) {
    return this._tags.includes(arg);
  }
}

class Scroll {  
  constructor(id, title, tags, dateLastCleaned) {
    this._id = id;    
    this._catalogItem = new CatalogItem(null, title, tags);
    this._lastCleaned = dateLastCleaned;
  }

  get id() {
    return this._id;
  }

  get title() {
    return this._title;
  }

  hasTag(arg) {
    return this._tags.includes(arg);
  }  

  needsCleaning(targetDate) {
    const threshold = this.hasTag('revered') ? 700 : 1500;
    return this.daysSinceLastCleaning(targetDate) > threshold;
  }

  daysSinceLastCleaning(targetDate) {
    return this._lastCleaned.until(targetDate, ChronoUnit.DAYS);
  }
}
+// 스크롤 데이터 읽기
+const scrolls = aDocument.map(record => {
+ return new Scroll(
+   record.id, 
+   record.catalogData.title, 
+   record.catalogData.tags, 
+   LocalDate.parse(record.lastCleaned),
+ );
+});
```
### STEP 2-3
[9.5 값을 참조로 바꾸기(Change Value to Reference)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter09/9-5.md)의 첫 번째 단계는 저장소 찾기다(적절한 게 없다면 새로 만든다). 이번 사례에서는 쉽게 이용할 수 있는 저장소를 찾을 수 있었다. 이 저장소는 ID로 색인된 카탈로그 아이템을 제공한다. 다음 단계로는 이 ID를 스크롤의 생성자로 건넬 방법을 찾아야 한다. 다행히도 이 정보는 입력 데이터에 포함되어 있다. 상속 방식에서는 쓸 일이 없어서 무시했을 뿐이다. 이상의 해법들이 나왔으니 [6.5 함수 선언 바꾸기(Change Function Declaration)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-5.md)를 적용하여 카탈로그와 카탈로그 아이템의 ID를 생성자 매개변수로 추가한다.
```diff
class CatalogItem {
  constructor(id, title, tags) {
    this._id = id;
    this._title = title;
    this._tags = tags;
  }

  get id() {
    return this._id;
  }
  get title() {
    return this._title;
  }
  hasTag(arg) {
    return this._tags.includes(arg);
  }
}

class Scroll {  
- constructor(id, title, tags, dateLastCleaned) {
+ constructor(id, title, tags, dateLastCleaned, catalogID, catalog) {  
    this._id = id;    
    this._catalogItem = new CatalogItem(null, title, tags);
    this._lastCleaned = dateLastCleaned;
  }

  get id() {
    return this._id;
  }

  get title() {
    return this._title;
  }

  hasTag(arg) {
    return this._tags.includes(arg);
  }  

  needsCleaning(targetDate) {
    const threshold = this.hasTag('revered') ? 700 : 1500;
    return this.daysSinceLastCleaning(targetDate) > threshold;
  }

  daysSinceLastCleaning(targetDate) {
    return this._lastCleaned.until(targetDate, ChronoUnit.DAYS);
  }
}
// 스크롤 데이터 읽기
const scrolls = aDocument.map(record => {
  return new Scroll(
    record.id, 
    record.catalogData.title, 
    record.catalogData.tags, 
    LocalDate.parse(record.lastCleaned),
+   record.catalogData.id,
+   catalog,
  );
});
```
### STEP 2-4
이제 생성자를 수정할 차례다. 새로운 카탈로그 아이템을 만드는 대신 인수로 받은 카탈로그 ID를 사용해서 카탈로그 아이템을 얻어오게 한다.
```diff
class CatalogItem {
  constructor(id, title, tags) {
    this._id = id;
    this._title = title;
    this._tags = tags;
  }

  get id() {
    return this._id;
  }
  get title() {
    return this._title;
  }
  hasTag(arg) {
    return this._tags.includes(arg);
  }
}

class Scroll {  
  constructor(id, title, tags, dateLastCleaned, catalogID, catalog) {  
    this._id = id;    
-   this._catalogItem = new CatalogItem(null, title, tags);
+   this._catalogItem = catalog.get(catalogID);
    this._lastCleaned = dateLastCleaned;
  }

  get id() {
    return this._id;
  }

  get title() {
    return this._title;
  }

  hasTag(arg) {
    return this._tags.includes(arg);
  }  

  needsCleaning(targetDate) {
    const threshold = this.hasTag('revered') ? 700 : 1500;
    return this.daysSinceLastCleaning(targetDate) > threshold;
  }

  daysSinceLastCleaning(targetDate) {
    return this._lastCleaned.until(targetDate, ChronoUnit.DAYS);
  }
}
// 스크롤 데이터 읽기
const scrolls = aDocument.map(record => {
  return new Scroll(
    record.id, 
    record.catalogData.title, 
    record.catalogData.tags, 
    LocalDate.parse(record.lastCleaned),
    record.catalogData.id,
    catalog,
  );
});
```
### STEP 2-5
마지막으로, 생성자로 건네지던 제목과 태그는 필요가 없어졌으니 6.5 함수 선언 바꾸기(Change Function Declaration)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-5.md)로 제거한다.
```diff
class CatalogItem {
  constructor(id, title, tags) {
    this._id = id;
    this._title = title;
    this._tags = tags;
  }

  get id() {
    return this._id;
  }
  get title() {
    return this._title;
  }
  hasTag(arg) {
    return this._tags.includes(arg);
  }
}

class Scroll {  
- constructor(id, title, tags, dateLastCleaned, catalogID, catalog) {  
+ constructor(id, dateLastCleaned, catalogID, catalog) {    
    this._id = id;    
    this._catalogItem = catalog.get(catalogID);
    this._lastCleaned = dateLastCleaned;
  }

  get id() {
    return this._id;
  }

  get title() {
    return this._title;
  }

  hasTag(arg) {
    return this._tags.includes(arg);
  }  

  needsCleaning(targetDate) {
    const threshold = this.hasTag('revered') ? 700 : 1500;
    return this.daysSinceLastCleaning(targetDate) > threshold;
  }

  daysSinceLastCleaning(targetDate) {
    return this._lastCleaned.until(targetDate, ChronoUnit.DAYS);
  }
}
// 스크롤 데이터 읽기
const scrolls = aDocument.map(record => {
  return new Scroll(
    record.id, 
-   record.catalogData.title, 
-   record.catalogData.tags, 
    LocalDate.parse(record.lastCleaned),
    record.catalogData.id,
    catalog,
  );
});
```

- [12.10 서브클래스를 위임으로 바꾸기(Replace Subclass with Delegate)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-10.md)
