# 12.8 슈퍼클래스 추출하기(Extract Subclasses)
``` diff
+class Party {
+ get name() {
+   ...
+ }
+ get annualCost() {
+   ...
+ }
+}
-class Department {
+class Department extends Party {  
- get totalAnnualCost() {
+ get annualCost() {
    ...
  }
- get name() {
-   ...
- }
  get headCount() {
    ...
  }
}

-class Employee() {
+class Employee extends Party() {
  get annualCost() {
    ...
  }
- get name() {
-   ...
- }
  get id() {
    ...
  }
}
```

## 배경
비슷한 일을 수행하는 두 클래스가 보이면 상속 매커니즘을 이용해서 비슷한 부분을 공통의 슈퍼클래스로 옮겨 담을 수 있다. 공통된 부분이 데이터라면 [12.2 필드 올리기(Pull Up Field)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-2.md)를 활용하고, 동작이라면 [12.1 메서드 올리기(Pull Up Method)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-1.md)를 활용하면 된다.

객체 지향을 설명할 때 상속 구조는 '**현실 세계**에서 활용하는 어떤 분류 체계에 기초하여 구현에 들어가기 앞서 부모,자식 관계를 신중하게 설계해야 한다'라고 이야기하는 사람이 많다. 현실 세계의 이런 분류 쳬계는 상속을 적용하는 데 힌트가 될 수 있다. 하지만 내 경험에 비춰보자면 상속은 프로그램이 성장하면서 깨우쳐가게 되며, 슈퍼클래스로 끌어올리고 싶은 공통 요소를 찾았을 때 수행하는 사례가 잦았다.

슈퍼클래스 추출하기의 대안으로는 [7.5 클래스 추출하기(Extract Class)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-5.md)가 있다. 어느 것을 선택하느냐는 중복 동작을 상속으로 해결하느냐에 달렸다. 슈퍼클래스 추출하기 방법이 더 간단할 경우가 많으니 이 리팩터링을 먼저 시도해보길 권한다. 나중에라도 필요해지면 [12.11 슈퍼클래스를 위임으로 바꾸기(Replace Superclass with Delegate)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-11.md)는 어렵지 않다.
## 절차
### (1)
빈 슈퍼클래스를 만든다. 원래의 클래스들이 새 클래스를 상속하도록 한다.
- 필요하다면 생성자에 [6.5 함수 선언 바꾸기(Change Function Declaration)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-5.md)를 적용한다.
### (2)
테스트한다.
### (3)
[12.3 생성자 본문 올리기(Pull Up Constructor Body)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-3.md), [12.1 메서드 올리기(Pull Up Method)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-1.md), [12.2 필드 올리기(Pull Up Field)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-2.md)를 차례로 적용하여 공통 원소를 슈퍼 클래스로 옮긴다.
### (4)
서브클래스에 남은 메서드들을 검토한다. 공통되는 부분이 있다면 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md) 한 다음에 [12.1 메서드 올리기(Pull Up Method)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-1.md)를 적용한다.
### (5)
원래 클래스들을 사용하는 코드를 검토하여 슈퍼클래스의 인터페이스를 사용하게 할지 고민해본다.
## 예시
다음 두 클래스를 사용하고 있는데, 공통된 기능이 눈에 띈다. 연간 비용과 월간 비용이라는 개념, 그리고 이름이 여기 속한다.
```javascript
class Employee {
  constructor(name, id, monthlyCost) {
    this._id = id;
    this._name = name;
    this._monthlyCost = monthlyCost;
  }
  get monthlyCost() {
    return this._monthlyCost;
  }
  get name() {
    return this._name;
  }
  get id() {
    return this._id;
  }

  get annualCost() {
    return this.monthlyCost * 12;
  }
}

class Department {
  constructor(name, staff) {
    this._name = name;
    this._staff = staff;
  }
  get staff() {
    return this._staff.slice();
  }
  get name() {
    return this._name;
  }
  get totalMonthlyCost() {
    return this.staff.map(e => e.monthlyCost).reduce((sum, cost) => sum + cost);
  }
  get headCount() {
    return this.staff.length;
  }
  get totalAnnualCost() {
    return this.totalMonthlyCost * 12;
  }
}
```
### STEP 1
두 클래스로부터 슈퍼클래스를 추출하면 이 공통된 동작들을 더 명확하게 드러낼 수 있다. [(1)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-8.md#1)우선 빈 슈퍼클래스를 만들고, 두 클래스가 이를 확장하도록 한다.
```diff
+class Party {

+}
-class Employee {
+class Employee extends Party {  
  constructor(name, id, monthlyCost) {
+   super();
    this._id = id;
    this._name = name;
    this._monthlyCost = monthlyCost;
  }
  get monthlyCost() {
    return this._monthlyCost;
  }
  get name() {
    return this._name;
  }
  get id() {
    return this._id;
  }

  get annualCost() {
    return this.monthlyCost * 12;
  }
}

-class Department {
+class Department extends Party {  
  constructor(name, staff) {
+   super();    
    this._name = name;
    this._staff = staff;
  }
  get staff() {
    return this._staff.slice();
  }
  get name() {
    return this._name;
  }
  get totalMonthlyCost() {
    return this.staff.map(e => e.monthlyCost).reduce((sum, cost) => sum + cost);
  }
  get headCount() {
    return this.staff.length;
  }
  get totalAnnualCost() {
    return this.totalMonthlyCost * 12;
  }
}
```
### STEP 2
[(3)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-8.md#3) 나는 슈퍼클래스 추출하기를 적용할 때 데이터부터 바꿔나가는 걸 좋아하는데, 자바스크립트에서는 이때 생성자를 만져줘야 한다. 그러니 먼저 이름 속성을 위로 올려보자([12.2 필드 올리기(Pull Up Field)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-2.md)).
```diff
class Party {
+ constructor(name) {
+   this._name = name;
+ }
}
class Employee extends Party {  
  constructor(name, id, monthlyCost) {
-   super();
+   super(name);
    this._id = id;
-   this._name = name;
    this._monthlyCost = monthlyCost;
  }
  get monthlyCost() {
    return this._monthlyCost;
  }
  get name() {
    return this._name;
  }
  get id() {
    return this._id;
  }

  get annualCost() {
    return this.monthlyCost * 12;
  }
}

class Department extends Party {  
  constructor(name, staff) {
-   super();
+   super(name);
-   this._name = name;
    this._staff = staff;
  }
  get staff() {
    return this._staff.slice();
  }
  get name() {
    return this._name;
  }
  get totalMonthlyCost() {
    return this.staff.map(e => e.monthlyCost).reduce((sum, cost) => sum + cost);
  }
  get headCount() {
    return this.staff.length;
  }
  get totalAnnualCost() {
    return this.totalMonthlyCost * 12;
  }
}
```
### STEP 3
데이터를 슈퍼클래스로 옮겼으니, 다음은 그 데이터와 관련된 메서드들 차례다([12.1 메서드 올리기(Pull Up Method)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-1.md)). 지금 예에서는 `name()` 메서드가 해당된다.
```diff
class Party {
  constructor(name) {
    this._name = name;
  }
+ get name() {
+   return this._name;
+ }  
}
class Employee extends Party {  
  constructor(name, id, monthlyCost) {
    super(name);
    this._id = id;
    this._monthlyCost = monthlyCost;
  }
  get monthlyCost() {
    return this._monthlyCost;
  }
- get name() {
-   return this._name;
- }
  get id() {
    return this._id;
  }

  get annualCost() {
    return this.monthlyCost * 12;
  }
}

class Department extends Party {  
  constructor(name, staff) {
    super(name);
    this._staff = staff;
  }
  get staff() {
    return this._staff.slice();
  }
- get name() {
-   return this._name;
- }
  get totalMonthlyCost() {
    return this.staff.map(e => e.monthlyCost).reduce((sum, cost) => sum + cost);
  }
  get headCount() {
    return this.staff.length;
  }
  get totalAnnualCost() {
    return this.totalMonthlyCost * 12;
  }
}
```
### STEP 4
다음으로, 구현 로직이 비슷한 메서드가 두 개 보인다.
``` javascript
class Employee extends Party {  
  ...
  get annualCost() {
    return this.monthlyCost * 12;
  }
  ...
}
class Department extends Party {
  ...
  get totalAnnualCost() {
    return this.totalMonthlyCost * 12;
  }
  ...
}
```
이 두 메서드에서 호출하는 메서드(`monthlyCost()`와 `totalMonthlyCost()`)는 이름도 다르고 본문 코드도 다르다. 하지만 의도는 같다. 그렇다면 [6.5 함수 선언 바꾸기(Change Function Declaration)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-5.md)로 이름을 통일한다.
```diff
class Party {
  constructor(name) {
    this._name = name;
  }
  get name() {
    return this._name;
  }  
}
class Employee extends Party {  
  constructor(name, id, monthlyCost) {
    super(name);
    this._id = id;
    this._monthlyCost = monthlyCost;
  }
  get monthlyCost() {
    return this._monthlyCost;
  }
  get id() {
    return this._id;
  }

  get annualCost() {
    return this.monthlyCost * 12;
  }
}

class Department extends Party {  
  constructor(name, staff) {
    super(name);
    this._staff = staff;
  }
  get staff() {
    return this._staff.slice();
  }
- get totalMonthlyCost() {
-   return this.staff.map(e => e.monthlyCost).reduce((sum, cost) => sum + cost);
- }
  get headCount() {
    return this.staff.length;
  }
  get totalAnnualCost() {
-   return this.totalMonthlyCost * 12;
+   return this.monthlyCost * 12;
  }
+ get monthlyCost() {
+   ...
+ }
}
```
### STEP 5
같은 방식으로 연간 비용 산출 메서드의 이름도 통일한다.
```diff
class Party {
  constructor(name) {
    this._name = name;
  }
  get name() {
    return this._name;
  }  
}
class Employee extends Party {  
  constructor(name, id, monthlyCost) {
    super(name);
    this._id = id;
    this._monthlyCost = monthlyCost;
  }
  get monthlyCost() {
    return this._monthlyCost;
  }
  get id() {
    return this._id;
  }

  get annualCost() {
    return this.monthlyCost * 12;
  }
}

class Department extends Party {  
  constructor(name, staff) {
    super(name);
    this._staff = staff;
  }
  get staff() {
    return this._staff.slice();
  }
  get headCount() {
    return this.staff.length;
  }
- get totalAnnualCost() {
+ get annualCost() {
    return this.monthlyCost * 12;
  }
  get monthlyCost() {
    ...
  }
}
```
### STEP 6
이제 두 연간 비용 산출 메서드에 [12.1 메서드 올리기(Pull Up Method)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-1.md)를 적용할 수 있다.
```diff
class Party {
  constructor(name) {
    this._name = name;
  }
  get name() {
    return this._name;
  }
+ get annualCost() {
+   return this.monthlyCost * 12;
+ }
}
class Employee extends Party {  
  constructor(name, id, monthlyCost) {
    super(name);
    this._id = id;
    this._monthlyCost = monthlyCost;
  }
  get monthlyCost() {
    return this._monthlyCost;
  }
  get id() {
    return this._id;
  }
- get annualCost() {
-   return this.monthlyCost * 12;
- }
}

class Department extends Party {  
  constructor(name, staff) {
    super(name);
    this._staff = staff;
  }
  get staff() {
    return this._staff.slice();
  }
  get headCount() {
    return this.staff.length;
  }
- get annualCost() {
-   return this.monthlyCost * 12;
- }
  get monthlyCost() {
    ...
  }
}
```