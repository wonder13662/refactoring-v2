### 12.1 메서드 올리기(Pull Up Method)
``` diff
class Employee {
+ get name() {...}
}

class SalesPerson extends Employee {
- get name() {...}
}

class Engineer extends Employee {
- get name() {...}
}
```

#### 배경
중복 코드 제거는 중요하다. 중복된 두 메서드가 당장은 문제없이 동작할지라도 미래에는 벌레(bug)가 꼬이는 음식물 쓰레기로 전락할 수 있다. 무언가 중복되었다는 것은 한쪽의 변경이 다른 쪽에 반영되지 않을 수 있다는 위험을 항상 수반한다. 그런데 일반적으로는 중복을 찾기가 그리 쉽지 않다는 게 문제다.

메서드 올리기를 적용하기 가장 쉬운 상황은 메서드들의 본문 코드가 똑같을 때다. 이럴 땐 그냥 복사해서 붙여넣으면 끝이다. 물론 세상이 언제나 이처럼 만만하지는 않다. 리팩터링이 제대로 되었는지를 검증하려면 테스트가 여전히 잘 동작하는지 확인하면 되지만, 테스트를 얼마나 잘 만들었느냐에 크게 의존하는 방법이다. 그래서 차이점을 찾는 방법이 효과가 좋다. 테스트에서 놓친 동작까지 알게 해주는 경우가 자주 있기 때문이다.

메서드 올리기 리팩터링을 적용하려면 선행 단계를 거쳐야 할 때가 많다. 예컨대 서로 다른 두 클래스의 두 메서드를 각각 매개변수화하면 궁극적으로 같은 메서드가 되기도 한다. 이런 경우에 가장 적은 단계를 거쳐 리팩터링하려면 각각의 함수를 [11.2 함수 매개변수화하기(Parameterize Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-2.md)한 다음 메서드를 상속 계층의 위로 올리면 된다.

반면, 메서드 올리기를 적용하기에 가장 이상하고 복잡한 상황은 해당 메서드의 본문에서 참조하는 필드들이 서브클래스에만 있는 경우다. 이런 경우라면 필드들 먼저 슈퍼클래스로 올린 후에 메서드를 올려야 한다.

두 메서드의 전체 흐름은 비슷하지만 세부 내용이 다르다면 [템플릿 메서드 만들기(Form Template Method)](https://refactoring.com/catalog/formTemplateMethod.html)를 고려해보자.

#### 절차
##### (1)
똑같이 동작하는 메서드인지 면밀히 살펴본다.
- 실질적으로 하는 일은 같지만 코드가 다르다면 본문 코드가 똑같아 질 때까지 리팩터링한다.
##### (2)
메서드 안에서 호출하는 다른 메서드를 참조하는 필드들을 슈퍼클래스에서도 호출하고 참조할 수 있는지 확인한다.
##### (3)
메서드 시그니처가 다르다면 [6.5 함수 선언 바꾸기(Change Function Declaration)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-5.md)로 슈퍼클래스에서 사용하고 싶은 형태로 통일한다. 
##### (4)
슈퍼클래스에 새로운 메서드를 생성하고, 대상 메서드의 코드를 복사해넣는다.
##### (5)
정적 검사를 수행한다.
##### (6)
서브클래스 중 하나의 메서드를 제거한다.
##### (7)
테스트한다.
##### (8)
모든 서브클래스의 메서드가 없어질 때까지 다른 서브클래스의 메서드를 하나씩 제거한다.
#### 예시
##### STEP 1
[(1)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-1.md#1) 두 서브클래스에서 같은 일을 수행하는 메서드를 찾았다.
```javascript
class Party {

}

class Employee extends Party {
  get annualCost() {
    return this.monthlyCost * 12;
  }
}

class Department extends Party {
  get totalAnnualCost() {
    return this.monthlyCost * 12;
  }
}
```
##### STEP 2
[(2)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-1.md#2) 확인해보니 두 메서드에서 참조하는 `monthlyCost()` 속성은 슈퍼클래스에는 정의되지 있지 않지만, 두 서브클래스 모두에 존재한다. 지금은 동적 언어인 자바스크립트를 사용해서 괜찮다. 정적 언어였다면 슈퍼클래스인 `Party`에 추상메서드를 정의해야 한다.
##### STEP 3
[(3)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-1.md#3)두 메서드의 이름이 다르므로 [6.5 함수 선언 바꾸기(Change Function Declaration)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-5.md)로 이름을 통일한다.
```diff
class Party {

}

class Employee extends Party {
  get annualCost() {
    return this.monthlyCost * 12;
  }
}

class Department extends Party {
- get totalAnnualCost() {
+ get annualCost() {
    return this.monthlyCost * 12;
  }
}
```
##### STEP 4
[(4)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-1.md#4)서브클래스 중 하나의 메서드를 복사해 슈퍼클래스에 붙여넣는다.
```diff
class Party {
+ get annualCost() {
+   return this.monthlyCost * 12;
+ }
}

class Employee extends Party {
- get annualCost() {
-   return this.monthlyCost * 12;
- }
}

class Department extends Party {
- get annualCost() {
-   return this.monthlyCost * 12;
- }
}
```
정적 언어였다면 이 시점에서 컴파일하여 모든 참조가 올바른지 확인해야 한다. 자바스크립트에서는 해당하지 않으니 [(6)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-1.md#6) 먼저 `Employee`에서 `annualCost()`를 제거하고, [(7)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-1.md#7) 테스트하고, [(8)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-1.md#8) `Department`에서도 제거한다.

> 이상으로 리팩터링은 끝났다. 그런데 의문이 하나 남는다. `annualCost()`가 `monthlyCost()`를 호출하는데, `Party` 클래스에서는 `monthlyCost`가 보이질 않는다. 이 상태로 잘 동작하는 까닭은 자바스크립트가 동적 언어이기 때문이다. 하지만 나중에 다른 서브클래스가 더해질 수도 있으니 `Party`의 서브클래스가 `monthlyCost()`를 구현해야 한다는 사실을 알려주는 게 좋을 것이다. 이럴 때는 다음처럼 함정(trap) 메서드를 만들어두면 유용하다. 이런 오류를 서브클래스 책임 오류(subclass responsibility error)라 한다. 스몰토크에서 유래한 이름이다.
```diff
class Party {
  get annualCost() {
    return this.monthlyCost * 12;
  }

+ get monthlyCost() {
+   throw new SubclassResponsibilityError();
+ }  
}

class Employee extends Party {}

class Department extends Party {}
```