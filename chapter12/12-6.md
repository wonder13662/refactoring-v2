### 12.6 타입 코드를 서브클래스로 바꾸기(Replace Type Code with Subclasses)
- 반대 리팩터링: [12.7 서브클래스 제거하기(Remove Subclasses)](https://github.com/wonder1©g662/refactoring-v2/blob/writing/chapter12/12-7.md)
- 하위 리팩터링: 
   - 타입 코드를 상태/전략 패턴으로 바꾸기
   - 서브클래스 추출하기
``` diff
function createEmployee(name, type) {
- return new Employee(name, type);
+ switch (type) {
+   case "engineer": return new Engineer(name);
+   case "salesperson": return new Salesperson(name);
+   case "manager": return new Manager(name);
+ }
}
```

#### 배경
소프트웨어 시스템에서는 비슷한 대상들을 특정 특성에 따라 구분해야 할 때가 자주 있다. 예컨대 직원을 담당 업무로 구분하거나(엔지니어, 관리자, 영업자 등) 주문을 시급성으로 구분하기도 한다(급함, 보통 등). 이런 일을 다루는 수단으로는 타입 코드(type code) 필드가 있다. 타입 코드는 프로그래밍 언어에 따라 열거형이나 심볼, 문자열, 숫자등으로 표현하며, 외부 서비스가 제공하는 데이터를 다루려 할 때 딸려오는 일이 흔하다.

타입 코드만으로도 특별히 불편한 상황은 없지만 그 이상의 무언가가 필요할 때가 있다. 여기서 '그 이상'이라 하면 바로 서브클래스를 가리킨다. 서브클래스는 두 가지 면에서 특히 매력적이다. 
1. 조건에 따라 다르게 동작하도록 해주는 다형성을 제공한다.타입코드에 따라 동작이 달라져야 하는 함수가 여러 개일 때 특히 유용하다. 서브클래스를 이용하면 이런 함수들에 [10.4 조건부 로직을 다형성으로 바꾸기(Replace Conditional with Polymorphism)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-4.md)를 적용할 수 있다.
2. 특정 타입에서만 의미가 있는 값을 사용하는 필드나 메서드가 있을 때 발현된다. 예컨대 '판매 목표'는 '영업자(Salesperson)' 유형일 때만 의미가 있다. 이런 상황이라면 서브클래스를 만들고 필요한 서브클래스만 필드를 갖도록 정리하자([12.5 필드 내리기(Push Down Field)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-5.md)). 물론 타입 코드를 사용할 때도 타입과 값이 올바르게 짝지어 사용되는지 검증하는 코드를 넣을 수 있지만, 서브클래스 방식이 관계를 더 명확히 드러내준다.

이번 리팩터링은 대상 클래스에 직접 적용할지, 아니면 타입 코드 자체에 적용할지를 고민해야 한다. 예컨대 전자 방식이라면 직원의 하위 타입인 엔지니어를 만들 것이다. 반면 후자는 직원에게 직원 유형 '속성'을 부여하고, 이 속성을 클래스로 정의해 엔지니어 속성과 관리자 속성 같은 서브클래스를 만드는 식이다. 대상 클래스를 직접 서브클래싱하는 게 간단하지만 업무 유형을 다른 용도로도 쓰고 싶을 때 그럴 수 없다는 단점이 있다. 또한 유형이 불변일 때도 직접 서브클래싱 방식은 이용할 수 없다. 서브클래싱 대상을 직원 유형 속성에 적용하고자 한다면 먼저 타입 코드에 [7.3 기본형을 객체로 바꾸기(Replace Primitive with Object)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-3.md)를 적용하여 직원 유형 클래스를 만든 다음, 이 클래스에 이번 리팩터링을 적용하면 된다.
#### 절차
##### (1)
타입 코드 필드를 자가 캡슐화한다.
##### (2)
타입 코드 값 하나를 선택하여 그 값에 해당하는 서브클래스를 만든다. 타입 코드 게터 메서드를 오버라이드하여 해당 타입 코드의 리터럴 값을 반환하게 한다.
##### (3)
매개변수로 받은 타입 코드와 방금 만든 서브클래스를 매핑하는 선택 로직을 만든다.
- 직접 상속일 때는 [11.8 생성자를 팩터리 함수로 바꾸기(Replace Constructor with Factory Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-8.md)를 적용하고 선택 로직을 팩터리에 넣는다. 간접 상속일 때는 선택 로직을 생성자에 두면 될 것이다.
##### (4)
테스트한다.
##### (5)
타입 코드 값 각각에 대해 서브클래스 생성과 선택 로직 추가를 반복한다. 클래스 하나가 완성될 때마다 테스트한다.
##### (6)
타입 코드 필드를 제거한다.
##### (7)
테스트한다.
##### (8)
타입 코드 접근자를 이용하는 메서드 모두에 [12.4 메서드 내리기(Push Down Method)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-4.md)와 [10.4 조건부 로직을 다형성으로 바꾸기(Replace Conditional with Polymorphism)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-4.md)를 적용한다.
#### 예시: 직접 상속할 때
이번에도 직원 코드를 예로 살펴보자.
```javascript
class Employee {
  constructor(name, type) {
    this.validateType(type);
    this._name = name;
    this._type = type;
  }
  validateType(arg) {
    if (!["engineer", "manager", "salesperson"].includes(arg))
      throw new Error(`${arg}라는 직원 유형은 없습니다.`);
  }
  toString() {
    return `${this._name} (${this._type})`;
  }
}
```

##### STEP 1-1
[(1)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-6.md#1) 첫 번째로, 타입 코드 변수를 [6.6 변수 캡슐화하기(Encapsulate Variable)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-6.md)한다.
```diff
class Employee {
  constructor(name, type) {
    this.validateType(type);
    this._name = name;
    this._type = type;
  }
  validateType(arg) {
    if (!["engineer", "manager", "salesperson"].includes(arg))
      throw new Error(`${arg}라는 직원 유형은 없습니다.`);
  }
+ get type() {
+   return this._type;
+ }  
  toString() {
    return `${this._name} (${this._type})`;
  }
}
```
`toString()`에서 타입 코드를 가져올 때 방금 만든 게터를 사용했음에 주의하자(밑줄이 없어졌다).
##### STEP 1-2
[(2)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-6.md#2)타입 코드 중 하나, 여기서는 엔지니어(engineer)를 선택해보자. 이번에는 직접 상속 방식으로 구현할 것이다. 즉, 직원 클래스 자체를 서브클래싱한다. 타입 코드 게터를 오버라이드하여 적절한 리터럴 값을 반환하기만 하면 되므로 아주 간단하게 처리할 수 있다.
```diff
class Employee {
  constructor(name, type) {
    this.validateType(type);
    this._name = name;
    this._type = type;
  }
  validateType(arg) {
    if (!["engineer", "manager", "salesperson"].includes(arg))
      throw new Error(`${arg}라는 직원 유형은 없습니다.`);
  }
  get type() {
    return this._type;
  }  
  toString() {
    return `${this._name} (${this._type})`;
  }
}

+class Engineer extends Employee {
+ get type() {
+   return "engineer";
+ }
+}
```
##### STEP 1-3
자바스크립트의 생성자는 객체를 반환할 수 있지만 선택 로직을 생성자에 넣으려 하면 필드 초기화와 로직이 꼬여서 엉망이 될 것이다. [(3)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-6.md#3) 그러니 [11.8 생성자를 팩터리 함수로 바꾸기(Replace Constructor with Factory Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-8.md)해서 선택 로직을 담을 별도 장소를 마련한다.
```diff
class Employee {
  constructor(name, type) {
    this.validateType(type);
    this._name = name;
    this._type = type;
  }
  validateType(arg) {
    if (!["engineer", "manager", "salesperson"].includes(arg))
      throw new Error(`${arg}라는 직원 유형은 없습니다.`);
  }
  get type() {
    return this._type;
  }  
  toString() {
    return `${this._name} (${this._type})`;
  }
}

class Engineer extends Employee {
  get type() {
    return "engineer";
  }
}

+function createEmployee(name, type) {
+ return new Employee(name, type);
+}
```
##### STEP 1-4
새로 만든 서브클래스를 사용하기 위한 선택 로직을 팩터리에 추가한다.
```diff
class Employee {
  constructor(name, type) {
    this.validateType(type);
    this._name = name;
    this._type = type;
  }
  validateType(arg) {
    if (!["engineer", "manager", "salesperson"].includes(arg))
      throw new Error(`${arg}라는 직원 유형은 없습니다.`);
  }
  get type() {
    return this._type;
  }  
  toString() {
    return `${this._name} (${this._type})`;
  }
}

class Engineer extends Employee {
  get type() {
    return "engineer";
  }
}

function createEmployee(name, type) {
+ switch (type) {
+   case "engineer": return new Engineer(name, type);
+ }
  return new Employee(name, type);
}
```
##### STEP 1-5
[(4)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-6.md#4) 지금까지 수정한 것이 제대로 동작하는지 테스트한다. 그런데 난 편집증이 있어서, 엔지니어 클래스에서 오버라이드한 게터가 일부러 엉뚱한 값을 반환하게 수정한 다음 다시 테스트해봤다. 그러면 당연히 실패하는데, 이런 식으로 이 서브클래스가 실제로 사용됐음을 확인할 수 있다! 반환 값을 정상으로 되돌리고 [(5)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-6.md#5) 남은 유형들에도 같은 작업을 반복한다. 한 번에 한 유형씩 수정하고, 수정 후에는 테스트한다.
```diff
class Employee {
  constructor(name, type) {
    this.validateType(type);
    this._name = name;
    this._type = type;
  }
  validateType(arg) {
    if (!["engineer", "manager", "salesperson"].includes(arg))
      throw new Error(`${arg}라는 직원 유형은 없습니다.`);
  }
  get type() {
    return this._type;
  }  
  toString() {
    return `${this._name} (${this._type})`;
  }
}

class Engineer extends Employee {
  get type() {
    return "engineer";
  }
}

+class Salesperson extends Employee {
+ get type() {
+   return "salesperson";
+ }
+}

+class Manager extends Employee {
+ get type() {
+   return "manager";
+ }
+}

function createEmployee(name, type) {
  switch (type) {
    case "engineer": return new Engineer(name, type);
+   case "salesperson": return new Salesperson(name, type);
+   case "engineer": return new Manager(name, type);
  }
  return new Employee(name, type);
}
```
##### STEP 1-6
[(6)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-6.md#6) 모든 유형에 적용했다면 타입 코드 필드와 슈퍼클래스의 게터(서브클래스들에서 재정의한 메서드)를 제거한다.
```diff
class Employee {
  constructor(name, type) {
    this.validateType(type);
    this._name = name;
-   this._type = type;
  }
  validateType(arg) {
    if (!["engineer", "manager", "salesperson"].includes(arg))
      throw new Error(`${arg}라는 직원 유형은 없습니다.`);
  }
- get type() {
-   return this._type;
- }  
  toString() {
    return `${this._name} (${this._type})`;
  }
}

class Engineer extends Employee {
  get type() {
    return "engineer";
  }
}

class Salesperson extends Employee {
  get type() {
    return "salesperson";
  }
}

class Manager extends Employee {
  get type() {
    return "manager";
  }
}

function createEmployee(name, type) {
  switch (type) {
    case "engineer": return new Engineer(name, type);
    case "salesperson": return new Salesperson(name, type);
    case "engineer": return new Manager(name, type);
  }
  return new Employee(name, type);
}
```
##### STEP 1-7
[(7)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-6.md#7) 모든 게 정상인지 테스트한 후 검증 로직도 제거한다. `switch`문이 사실상 똑같은 검증을 수행해주기 때문이다.
```diff
class Employee {
  constructor(name, type) {
-   this.validateType(type);
    this._name = name;
  }
  validateType(arg) {
    if (!["engineer", "manager", "salesperson"].includes(arg))
      throw new Error(`${arg}라는 직원 유형은 없습니다.`);
  }
  toString() {
    return `${this._name} (${this._type})`;
  }
}

class Engineer extends Employee {
  get type() {
    return "engineer";
  }
}

class Salesperson extends Employee {
  get type() {
    return "salesperson";
  }
}

class Manager extends Employee {
  get type() {
    return "manager";
  }
}

function createEmployee(name, type) {
  switch (type) {
    case "engineer": return new Engineer(name, type);
    case "salesperson": return new Salesperson(name, type);
    case "engineer": return new Manager(name, type);
+   default: throw new Error(`${type}라는 직원 유형은 없습니다.`)    
  }
- return new Employee(name, type);
}
```
##### STEP 1-8
이제 생성자에 건네는 타입 코드 인수는 쓰이지 않으니 없애버린다([6.5 함수 선언 바꾸기(Change Function Declaration)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-5.md)).
```diff
class Employee {
- constructor(name, type) {
+ constructor(name) {  
    this._name = name;
  }
  validateType(arg) {
    if (!["engineer", "manager", "salesperson"].includes(arg))
      throw new Error(`${arg}라는 직원 유형은 없습니다.`);
  }
  toString() {
    return `${this._name} (${this._type})`;
  }
}

class Engineer extends Employee {
  get type() {
    return "engineer";
  }
}

class Salesperson extends Employee {
  get type() {
    return "salesperson";
  }
}

class Manager extends Employee {
  get type() {
    return "manager";
  }
}

function createEmployee(name, type) {
  switch (type) {
-   case "engineer": return new Engineer(name, type);
+   case "engineer": return new Engineer(name);
-   case "salesperson": return new Salesperson(name, type);
+   case "salesperson": return new Salesperson(name);
-   case "engineer": return new Manager(name, type);
+   case "engineer": return new Manager(name);
    default: throw new Error(`${type}라는 직원 유형은 없습니다.`)    
  }
}
```
##### STEP 1-9
[(8)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-6.md#8) 서브클래스들에는 타입 코드 게터(`get type()`)가 여전히 남아있다. 보통은 이 게터들을 제거하고 싶겠찌만, 이 메서드를 이용하는 코드가 어딘가에 남아있을 수 있다. 그러니 [10.4 조건부 로직을 다형성으로 바꾸기(Replace Conditional with Polymorphism)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-4.md)와 [12.4 메서드 내리기(Push Down Method)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-4.md)로 문제를 해결하자. 하나씩 해결하다 보면 타입 게터를 호출하는 코드가 모두 사라질 것이다. 그러면 마음 편히 작별을 고하면 된다([8.9 죽은 코드 제거하기(Remove Dead Code)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-9.md)).
#### 예시: 간접 상속할 때
처음 상황으로 돌아가보자. 하지만 이번에는 직원의 서브클래스로 '아르바이트'와 '정직원'이라는 클래스가 이미 있어 `Employee`를 직접 상속하는 방식으로는 타입 코드 문제에 대처할 수 없다고 해보자. 직원 유형을 변경하는 기능을 유지하고 싶다는 점도 직접 상속을 사용하지 않는 이유다.
```javascript
class Employee {
  constructor(name, type) {
    this.validateType(type);
    this._name = name;
    this._type = type;
  }
  validateType(arg) {
    if (!["engineer", "manager", "salesperson"].includes(arg))
      throw new Error(`${arg}라는 직원 유형은 없습니다.`);
  }
  get type() {
    return this._type;
  }
  set type(arg) {
    this._type = arg;
  }
  get capitalizedType() {
    return this._type.charAt(0).toUpperCase() + this._type.substr(1).toLowerCase();
  }
  toString() {
    return `${this._name} (${this.capitalizedType})`;
  }
}
```

> 이번에는 이 예시 마지막에서 설명할 내용을 위해 `toString()`이 살짝 복잡해졌다.

##### STEP 2-1
[(1)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-6.md#1) 첫 번째로 할 일은 타입 코드를 객체로 바꾸기다([7.3 기본형을 객체로 바꾸기(Replace Primitive with Object)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-3.md)).
```diff
+class EmployeeType {
+ constructor(aString){
+   this._value = aString;
+ }
+ toString() {
+   return this._value;
+ }
+}
class Employee {
  constructor(name, type) {
    this.validateType(type);
    this._name = name;
    this._type = type;
  }
  validateType(arg) {
    if (!["engineer", "manager", "salesperson"].includes(arg))
      throw new Error(`${arg}라는 직원 유형은 없습니다.`);
  }
+ get typeString() {
+   return this._type.toString();
+ }
  get type() {
    return this._type;
  }
  set type(arg) {
    this._type = arg;
  }
  get capitalizedType() {
-   return this._type.charAt(0).toUpperCase() + this._type.substr(1).toLowerCase();
+   return this.typeString.charAt(0).toUpperCase() + this.typeString.substr(1).toLowerCase();
  }
  toString() {
    return `${this._name} (${this.capitalizedType})`;
  }
}
```
##### STEP 2-2
이제 바로 앞 예시와 같은 방식으로 직원 유형을 차분히 리팩터링해보자.
```diff
class EmployeeType {
- constructor(aString){
-   this._value = aString;
- }
- toString() {
-   return this._value;
- }
}
+class Engineer extends EmployeeType {
+ toString() {
+   return "engineer";
+ }
+}
+class Manager extends EmployeeType {
+ toString() {
+   return "manager";
+ }
+}
+class Salesperson extends EmployeeType {
+ toString() {
+   return "salesperson";
+ }
+}
class Employee {
  constructor(name, type) {
    this.validateType(type);
    this._name = name;
    this._type = type;
  }
  validateType(arg) {
    if (!["engineer", "manager", "salesperson"].includes(arg))
      throw new Error(`${arg}라는 직원 유형은 없습니다.`);
  }
  get typeString() {
    return this._type.toString();
  }
  get type() {
    return this._type;
  }
  set type(arg) {
-   this._type = arg;
+   this._type = Employee.createEmployeeType(arg);
  }
+ static createEmployeeType(aString) {
+   switch(aString) {
+     case "engineer": return new Engineer();
+     case "manager": return new Manager();
+     case "salesperson": return new Salesperson();
+     default: throw new Error(`${arg}라는 직원 유형은 없습니다.`);
+   }
+ }
  get capitalizedType() {
    return this.typeString.charAt(0).toUpperCase() + this.typeString.substr(1).toLowerCase();
  }
  toString() {
    return `${this._name} (${this.capitalizedType})`;
  }
}
```
##### STEP 2-3
이 코드에서 빈 `EmployeeType`을 제거할 수도 있었다. 하지만 나는 이번 예처럼 다양한 서브클래스 사이의 관계를 명확히 알려주는 클래스라면 그냥 두는 편이다. 또한 이 클래스는 다른 기능을 옮겨놓기에 편리한 장소이기도 하다. 예컨대 이 예에서는 이름의 첫 문자만 대문자로 변환해주는 로직을 이 클래스로 옮길 수 있을 것이다.
```diff
class EmployeeType {
+ get capitalizedName() {
+   return this.toString().charAt(0).toUpperCase() + this.toString().substr(1).toLowerCase();
+ }
}
class Engineer extends EmployeeType {
  toString() {
    return "engineer";
  }
}
class Manager extends EmployeeType {
  toString() {
    return "manager";
  }
}
class Salesperson extends EmployeeType {
  toString() {
    return "salesperson";
  }
}
class Employee {
  constructor(name, type) {
    this.validateType(type);
    this._name = name;
    this._type = type;
  }
  validateType(arg) {
    if (!["engineer", "manager", "salesperson"].includes(arg))
      throw new Error(`${arg}라는 직원 유형은 없습니다.`);
  }
  get typeString() {
    return this._type.toString();
  }
  get type() {
    return this._type;
  }
  set type(arg) {
    this._type = Employee.createEmployeeType(arg);
  }
  static createEmployeeType(aString) {
    switch(aString) {
      case "engineer": return new Engineer();
      case "manager": return new Manager();
      case "salesperson": return new Salesperson();
      default: throw new Error(`${arg}라는 직원 유형은 없습니다.`);
    }
  }
  get capitalizedType() {
    return this.typeString.charAt(0).toUpperCase() + this.typeString.substr(1).toLowerCase();
  }
  toString() {
-   return `${this._name} (${this.capitalizedType})`;
+   return `${this._name} (${this.type.capitalizedName})`;
  }
}
```

> 이 책의 초판을 기억하는 독자는 이 예시가 '분류 부호를 상태/전략 패턴으로 전환(Replace Type Code with State/Strategy)'의 예시와 본질적으로 같다는 사실을 눈치챘을 것이다. 이번 리팩터링을 간접 상속에 적용하면 결국 '분류 부호를 상태/전략 패턴으로 전환(Replace Type Code with State/Strategy)'과 같아지기 때문에 둘을 하나로 통합한 결과다.