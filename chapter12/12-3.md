# 12.3 생성자 본문 올리기(Pull Up Constructor Body)
``` diff
class Party {
+ constructor(name) {
+   this._name = name;
+ }
}

class Employee extends Party {
  constructor(name, id, monthlyCost) {
-   super();
+   super(name);
    this._id = id;
-   this._name = name;
    this._monthlyCost = monthlyCost;
  }
}
```

## 배경
생성자는 다루기 까다롭다. 일반 메서드와는 많이 달라서, 나는 생성자에서 하는 일에 제약을 두는 편이다.

나는 서브클래스들에서 기능이 같은 메서드들을 발견하면 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md)와 [12.1 메서드 올리기(Pull Up Method)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-1.md)를 차례로 적용하여 말끔히 슈퍼클래스로 옮기곤 한다. 그런데 그 메서드가 생성자라면 스텝이 꼬인다. 생성자는 할 수 있는 일과 호출 순서에 제약이 있기 때문에 조금 다른 식으로 접근해야 한다.

> 이번 리팩터링이 간단히 끝날 것 같지 않다면 [11.8 생성자를 팩터리 함수로 바꾸기(Replace Constructor with Factory Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-8.md)를 고려해본다.
## 절차
### (1)
슈퍼클래스에 생성자가 없다면 하나 정의한다. 서브클래스의 생성자들에서 이 생성자가 호출되는지 확인한다.
### (2)
[8.6 문장 슬라이드하기(Slide Statements)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-6.md)로 공통 문장 모두를 `super()` 호출 직후로 옮긴다.
### (3)
공통 코드를 슈퍼클래스에 추가하고 서브클래스들에서는 제거한다. 생성자 매개변수 중 공통 코드에서 참조하는 값들을 모두 `super()`로 건넨다.
### (4)
테스트한다.
### (5)
생성자 시작 부분으로 옮길 수 없는 공통 코드에는 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md)와 [12.1 메서드 올리기(Pull Up Method)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-1.md)를 차례로 적용한다.

## 예시
다음 코드에서 시작해보자.
```javascript
class Party {

}

class Employee extends Party {
  constructor(name, id, monthlyCost) {
    super();
    this._id = id;
    this._name = name;
    this._monthlyCost = monthlyCost;
  }
}

class Department extends Party {
  constructor(name, staff) {
    super();
    this._name = name;
    this._staff = staff;
  }
}
```
### STEP 1
여기서 공통 코드는 `this._name = name;`이라는 이름 대입 부분이다. [(2)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-3.md#2) `Employee`에서 이 대입문을 슬라이드하여 `super()`호출 바로 아래로 옮긴다([8.6 문장 슬라이드하기(Slide Statements)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-6.md)).
```diff
class Party {

}

class Employee extends Party {
  constructor(name, id, monthlyCost) {
    super();
+   this._name = name;    
    this._id = id;
-   this._name = name;
    this._monthlyCost = monthlyCost;
  }
}

class Department extends Party {
  constructor(name, staff) {
    super();
    this._name = name;
    this._staff = staff;
  }
}
```
### STEP 2
[(3)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-3.md#3) 테스트가 성공하면 이 공통 코드를 슈퍼클래스로 옮긴다. 이 코드가 생성자의 인수인 `name`을 참조하므로 이 인수를 슈퍼클래스 생성자에 매개변수로 건넨다.
```diff
class Party {
+ constructor(name) {
+   this._name = name;
+ }
}

class Employee extends Party {
  constructor(name, id, monthlyCost) {
-   super();
+   super(name);
-   this._name = name;    
    this._id = id;
    this._monthlyCost = monthlyCost;
  }
}

class Department extends Party {
  constructor(name, staff) {
-   super();
+   super(name);
-   this._name = name;
    this._staff = staff;
  }
}
```
[(4)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-3.md#4) 테스트를 돌려 모두 통과하면 리팩터링이 끝난다.
## 예시: 공통 코드가 나중에 올 때
생성자는 대부분 (`super()`를 호출하여) 공통 작업을 먼저 처리한 다음, 각 서브클래스에 필요한 추가 작업을 처리하는 식으로 동작한다. 그런데 이따금 공통 작업이 뒤에 오는 경우도 있다. 다음 예를 보자.
```javascript
class Employee {
  constructor (name) {...}
  get isPrivileged() {...}
  assignCar() {...}
}

class Manager extends Employee {
  constructor(name, grade) {
    super(name);
    this._grade = grade;
    if (this.isPriviliged) this.assignCar();
  }

  get isPriviliged() {
    return this._grade > 4;
  }
}
```
이렇게 될 수 밖에 없는 이유는 `isPrivileged()`는 `grade` 필드에 값이 대입된 후에야 호출될 수 있고, 서브클래스만이 이 필드에 값을 대입할 수 있기 때문이다.
### STEP 1
[(5)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-3.md#5) 이런 경우라면 먼저 공통 코드를 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md) 하자.
```diff
class Employee {
  constructor (name) {...}
  get isPrivileged() {...}
  assignCar() {...}
}

class Manager extends Employee {
  constructor(name, grade) {
    super(name);
    this._grade = grade;
+   this.finishConstruction();
-   if (this.isPriviliged) this.assignCar();
  }

+ finishConstruction() {
+   if (this.isPriviliged) this.assignCar();
+ }  

  get isPriviliged() {
    return this._grade > 4;
  }
}
```
### STEP 2
그런 다음 추출한 메서드를 슈퍼클래스로 옮긴다([12.1 메서드 올리기(Pull Up Method)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-1.md)).
```diff
class Employee {
  constructor (name) {...}
  get isPrivileged() {...}
  assignCar() {...}

+ finishConstruction() {
+   if (this.isPriviliged) this.assignCar();
+ }
}

class Manager extends Employee {
  constructor(name, grade) {
    super(name);
    this._grade = grade;
    this.finishConstruction();
  }

- finishConstruction() {
-   if (this.isPriviliged) this.assignCar();
- }

  get isPriviliged() {
    return this._grade > 4;
  }
}
```