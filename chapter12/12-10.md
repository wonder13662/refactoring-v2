# 12.10 서브클래스를 위임으로 바꾸기(Replace Subclass with Delegate)
``` diff
class Order {
  get daysToShip() {
-   return this._warehouse.daysToShip;
+   return (this._priorityDelegate) ? this._priorityDelegate.daysToShip : this._warehouse.daysToShip;
  }
}

-class PriorityOrder extends Order {
+class PriorityOrderDelegate {  
  get daysToShip() {
    return this._priorityPlan.daysToShip;
  }
}
```

## 배경
속한 갈래에 따라 동작이 달라지는 객체들은 상속으로 표현하는 게 자연스럽다. 공통 데이터와 동작은 모두 슈퍼클래스에 두고 서브클래스는 자신에 맞게 기능을 추가하거나 오버라이드하면 된다. 객체 지향 언어로는 이런 형태로 구현하기가 쉽기 때문에 흔히 활용되는 매커니즘이다.

하지만 상속에는 단점이 있다. 가장 명확한 단점은 한 번만 쓸 수 있다는 카드라는 것이다. 무언가가 달라져야 하는 이유가 여러 개여도 상속에서는 그 중 단 하나의 이유만 선택해 기준으로 삼을 수 밖에 없다. 예컨대 사람 객체의 동작을 '연령대'와 '소득 수준'에 따라 달리하고 싶다면 서브클래스는 젊은이와 어르신이 되거나, 혹은 부자와 서민이 되어야 한다. 둘 다는 안된다.

또 다른 문제로, 상속은 클래스들의 관계를 아주 긴밀하게 결합한다. 부모를 수정하면 이미 존재하는 자식들의 기능을 해치기가 쉽기 때문에 각별히 주의해야 한다. 그래서 자식들이 슈퍼클래스를 어떻게 상속해 쓰는지를 이해해야 한다. 부모와 자식이 서로 다른 모듈에 속하거나 다른 팀에서 구현한다면 문제가 더 커진다.

위임(delegate)은 이상의 두 문제를 모두 해결해준다. 다양한 클래스에 서로 다른 이유로 위임할 수 있다. 위임은 객체 사이의 일반적인 관계이므로 상호작용에 필요한 인터페이스를 명확히 정의할 수 있다. 즉, 상속보다 결합도가 훨씬 약하다. 그래서 서브클래싱(상속) 관련 문제에 직면하게 되면 흔히들 서브클래스를 위임으로 바꾸곤 한다.

유명한 원칙이 하나 있다. "(클래스) 상속보다는 (객체) 컴포지션을 사용하라!". 여기서 컴포지션(composition)은 사실상 위임과 같은 말이다. 많은 사람들이 이 말을 '상속은 위험하다'고 받아들여서 상속을 사용하면 절대 안 된다고 주장하기도 한다. 하지만 나는 상속을 자주 사용하는데, 이렇게 하는 배경에는 나중에라도 필요하면 언제든 서브클래스를 위임으로 바꿀 수 있음을 알고 있다는 점이 한 몫 한다. 그래서 처음에는 상속으로 접근한 다음, 문제가 생기기 시작하면 위임으로 갈아탄다. 이 방식은 사실 앞의 원칙과도 일맥상통한다. 실제로 이 원칙을 주장한 **디자인 패턴** 책은 상속과 컴포지션을 함께 사용하는 방법을 설명해준다. 이 원칙은 상속을 쓰지 말라는 게 아니라, 과용하는 데 따른 반작용으로 나온 것이다.

**디자인 패턴** 책에 익숙한 사람이라면 이 리팩터링을 '서브클래스를 상태 패턴(State Pattern)이나 전략 패턴(Strategy Pattern)으로 대체'한다고 생각하면 도움이 될 것이다. 구조적으로 보면 이 두 패턴은 똑같이 호스트 위임 방식으로 계층구조를 분리해준다. 서브클래스를 위임으로 바꾸는 모든 경우에서 위임을 계층구조로 설계해야 하는 건 아니다(첫 번째 예시에서 설명하겠다). 하지만 상태나 전략에 계층구조를 적용하면 유용할 때가 많다.
## 절차
### (1)
생성자를 호출하는 곳이 많다면 [11.8 생성자를 팩터리 함수로 바꾸기(Replace Constructor with Factory Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-8.md) 한다.
### (2)
위임으로 활용할 빈 클래스를 만든다. 이 클래스의 생성자는 서브클래스에 특화된 데이터를 전부 받아야 하며, 보통은 슈퍼클래스를 가리키는 역참조(back-reference)도 필요하다.
### (3)
위임을 저장할 필드를 슈퍼클래스에 추가한다.
### (4)
서브클래스 생성 코드를 수정하여 위임 인스턴스를 생성하고 위임 필드에 대입해 초기화한다.
- 이 작업은 팩터리 함수가 수행한다. 혹은 생성자가 정확한 위임 인스턴스를 생성할 수 있는 게 확실하다면 생성자에서 수행할 수도 있다.
### (5)
서브클래스의 메서드 중 위임 클래스로 이동할 것을 고른다.
### (6)
[8.1 함수 옮기기(Move Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-1.md)를 적용해 위임 클래스로 옮긴다. 원래 메서드에서 위임하는 코드는 지우지 않는다.
- 이 메서드가 사용하는 원소 중 위임으로 옮겨야 하는 게 있다면 함께 옮긴다. 슈퍼클래스에 유지해야 할 원소를 참조한다면 슈퍼클래스를 참조하는 필드를 위임에 추가한다.
### (7)
서브클래스 외부에도 원래 메서드를 호출하는 코드가 있다면 서브클래스의 위임 코드를 슈퍼클래스로 옮긴다. 이때 위임이 존재하는지를 검사하는 보호 코드로 감싸야 한다. 호출하는 외부 코드가 없다면 원래 메서드는 [8.9 죽은 코드 제거하기(Remove Dead Code)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-9.md) 한다.
- 서브클래스가 둘 이상이고 서브클래스들에서 중복이 생겨나기 시작했다면 [12.8 슈퍼클래스 추출하기(Extract Subclasses)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-8.md) 한다. 이렇게 하여 기본 동작이 위임 슈퍼클래스로 옮겨졌다면 슈퍼클래스의 위임 메서드들에는 보호 코드가 필요없다.
### (8)
테스트한다.
### (9)
서브클래스의 모든 메서드가 옮겨질 때까지 [(5)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-10.md#5)~[(8)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-10.md#8) 과정을 반복한다.
### (10)
서브클래스들의 생성자를 호출하는 코드를 찾아서 슈퍼클래스의 생성자를 사용하도록 수정한다.
### (11)
테스트한다.
### (12)
서브클래스를 삭제한다([8.9 죽은 코드 제거하기(Remove Dead Code)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-9.md)).

## 예시: 서브클래스가 하나일 때
공연 예약(booking) 클래스를 준비했다.
```javascript
class Booking {
  constructor(show, date) {
    this._show = show;
    this._date = date;
  }
}
```
그리고 추가 비용을 다양하게 설정할 수 있는 프리미엄 예약용 서브클래스가 있다.
```javascript
class PremiumBooking extends Booking {
  constructor(show, date, extras) {
    super(show, date);
    this._extras = extras;
  }
}
```
프리미엄 예약은 슈퍼클래스를 상속해 제법 많은 걸 변경한다. 다름에 기반한 프로그래밍 방식에서 볼 수 있는 전형적인 모습으로, 서브클래스에서 슈퍼클래스의 메서드 일부를 오버라이드하거나, 몇몇 서브클래스에서 필요한 메서드를 몇 개 추가하는 식이다. 모든 경우를 다 살펴보지는 않고 재미난 부분만 몇 개 짚어 보겠다.

1. 간단한 오버라이드 메서드가 하나 있다. 다음 코드처럼 일반 예약은 공연 후 관객과의 대화(talkback) 시간을 성수기가 아닐 때만 제공한다.
```diff
class Booking {
  constructor(show, date) {
    this._show = show;
    this._date = date;
  }
+ get hasTalkback() {
+   return this._show.hasOwnProperty('talkback') && !this.isPeakDay;
+ }
}
```
프리미엄 예약은 이를 오버라이드하여 항시 관객과의 대화 시간을 마련한다.
```diff
class PremiumBooking extends Booking {
  constructor(show, date, extras) {
    super(show, date);
    this._extras = extras;
  }
+ get hasTalkback() {
+   return this._show.hasOwnProperty('talkback');
+ }  
}
```
비슷하게, 가격 결정도 슈퍼클래스의 메서드를 호출해 추가 요금을 더하는 식으로 오버라이드한다.
```diff
class Booking {
  constructor(show, date) {
    this._show = show;
    this._date = date;
  }
  get hasTalkback() {
    return this._show.hasOwnProperty('talkback') && !this.isPeakDay;
  }
+ get basePrice() {
+   let result = this._show.price;
+   if (this.isPeakDay) result += Math.round(result * 0.15);
+   return result;
+ }
}
class PremiumBooking extends Booking {
  constructor(show, date, extras) {
    super(show, date);
    this._extras = extras;
  }
  get hasTalkback() {
    return this._show.hasOwnProperty('talkback');
  }  
+ get basePrice() {
+   return Math.round(super.basePrice + this._extras.premiumFee);
+ }  
}
```
마지막은 슈퍼클래스에 없는 기능을 프리미엄 예약에서 제공하는 예다
```diff
class Booking {
  constructor(show, date) {
    this._show = show;
    this._date = date;
  }
  get hasTalkback() {
    return this._show.hasOwnProperty('talkback') && !this.isPeakDay;
  }
  get basePrice() {
    let result = this._show.price;
    if (this.isPeakDay) result += Math.round(result * 0.15);
    return result;
  }
}
class PremiumBooking extends Booking {
  constructor(show, date, extras) {
    super(show, date);
    this._extras = extras;
  }
  get hasTalkback() {
    return this._show.hasOwnProperty('talkback');
  }  
  get basePrice() {
    return Math.round(super.basePrice + this._extras.premiumFee);
  }  
+ get hasDinner() {
+   return this._extras.hasOwnProperty('dinner') && !this.isPeakDay;
+ }
}
```
이 예에는 상속이 잘 들어맞는다. 서브클래스에 대한 지식 없이도 기반 클래스(슈퍼클래스)를 이해할 수 있고, 서브클래스는 기반 클래스와 무엇이 다른지를 설명하는 방식으로 정의되었다. 중복도 줄이고 서브클래스가 추가한 차이가 무엇인지 분명하게 알려주고 있다.

현실은 방금 설명한 것만큼 완벽하지만은 않다. 슈퍼클래스에는 서브클래스에 의해 완성되는, 즉 서브클래스 없이는 불완전한 어떤 구조가 존재할 수 있다. 예컨대 일련의 큰 동작의 일부를 서브클래스에서 오버라이드하여 빈 곳을 메꿔주도록 설계된 메서드가 여기 속한다. 슈퍼클래스를 수정할 때 굳이 서브클래스까지 고려할 필요가 없는 게 보통이지만, 이 무지로 인해 서브클래스의 동작을 망가뜨리는 상황이 닥칠 수 있다. 하지만 이런 경우가 흔치 않다면 (그리고 서브클래스가 망가지는지를 확인하는 테스트를 만들어두면) 상속은 충분한 값어치를 한다.

그렇다면 이런 행복한 상황에서 나는 왜 서브클래스를 위임으로 바꾸려 할까? 상속은 한 번만 사용할 수 있는 도구다. 따라서 상속을 사용해야 할 다른 이유가 생긴다면, 그리고 그 이유가 프리미엄 예약 서브클래스보다 가치가 크다고 생각된다면 프리미엄 예약을 (상속이 아닌) 다른 방식으로 표현해야 할 것이다. 또한, 기본 예약에서 프리미엄 예약으로 동적으로 전환할 수 있도록 해야 할 수도 있다. 예컨대 `aBooking.bePremium()`같은 메서드를 추가하는 식으로 말이다. 완전히 새로운 객체를 만들어서 이런 상황을 피해갈 수 있는 경우도 있을 것이다. 흔한 예로, HTTP 요청을 통해 서버로부터 새로운 데이터를 받아올 수 있다. 하지만 처음부터 새로 만드는 방법을 사용할 수 없고, 대신 데이터 구조를 수정해야 할 때도 있다. 그런데 이 방식으로는 수많은 곳에서 참조되는 예약 인스턴스를 다른 것으로 교체하기 어렵다. 이런 상황이라면 기본 예약에서 프리미엄 예약으로(혹은 거꾸로) 전환할 수 있게 하면 유용하다.

이러한 요구가 커지면 서브클래스를 위임으로 바꾸는 게 좋다. 다음과 같이 두 예약 클래스의 생성자를 호출하는 클라이언트들이 있다고 해보자.
```diff
class Booking {
  constructor(show, date) {
    this._show = show;
    this._date = date;
  }
  get hasTalkback() {
    return this._show.hasOwnProperty('talkback') && !this.isPeakDay;
  }
  get basePrice() {
    let result = this._show.price;
    if (this.isPeakDay) result += Math.round(result * 0.15);
    return result;
  }
}
class PremiumBooking extends Booking {
  constructor(show, date, extras) {
    super(show, date);
    this._extras = extras;
  }
  get hasTalkback() {
    return this._show.hasOwnProperty('talkback');
  }  
  get basePrice() {
    return Math.round(super.basePrice + this._extras.premiumFee);
  }  
  get hasDinner() {
    return this._extras.hasOwnProperty('dinner') && !this.isPeakDay;
  }
}
+// 클라이언트(일반 예약)
+aBooking = new Booking(show, date);
+// 클라이언트(프리미엄 예약)
+aBooking = new PremiumBooking(show, date, extras);
```
### STEP 1-1
[(1)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-10.md#1) 서브클래스를 제러하려면 수정할 게 많으니 먼저 [11.8 생성자를 팩터리 함수로 바꾸기(Replace Constructor with Factory Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-8.md)해서 생성자 호출 부분을 캡슐화하자.
```diff
class Booking {
  constructor(show, date) {
    this._show = show;
    this._date = date;
  }
  get hasTalkback() {
    return this._show.hasOwnProperty('talkback') && !this.isPeakDay;
  }
  get basePrice() {
    let result = this._show.price;
    if (this.isPeakDay) result += Math.round(result * 0.15);
    return result;
  }
}
class PremiumBooking extends Booking {
  constructor(show, date, extras) {
    super(show, date);
    this._extras = extras;
  }
  get hasTalkback() {
    return this._show.hasOwnProperty('talkback');
  }  
  get basePrice() {
    return Math.round(super.basePrice + this._extras.premiumFee);
  }  
  get hasDinner() {
    return this._extras.hasOwnProperty('dinner') && !this.isPeakDay;
  }
}
+// 최상위
+function createBooking(show, date) {
+ return new Booking(show, date);
+}
+function createPremiumBooking(show, date, extras) {
+ return new PremiumBooking(show, date, extras);
+}
// 클라이언트(일반 예약)
-aBooking = new Booking(show, date);
+aBooking = createBooking(show, date);
// 클라이언트(프리미엄 예약)
-aBooking = new PremiumBooking(show, date, extras);
+aBooking = createPremiumBooking(show, date, extras);
```
### STEP 1-2
이제 위임클래스를 새로 만든다. 위임 클래스의 생성자는 서브클래스가 사용하던 매개변수와 예약 객체로의 역참조(back-reference)를 매개변수로 받는다. 역참조가 필요한 이유는 서브클래스 메서드 중 슈퍼클래스에 저장된 데이터를 사용하는 경우가 있기 때문이다. 상속에서는 쉽게 처리할 수 있지만, 위임에서는 역참조가 있어야 한다.
```diff
class Booking {
  constructor(show, date) {
    this._show = show;
    this._date = date;
  }
  get hasTalkback() {
    return this._show.hasOwnProperty('talkback') && !this.isPeakDay;
  }
  get basePrice() {
    let result = this._show.price;
    if (this.isPeakDay) result += Math.round(result * 0.15);
    return result;
  }
}
class PremiumBooking extends Booking {
  constructor(show, date, extras) {
    super(show, date);
    this._extras = extras;
  }
  get hasTalkback() {
    return this._show.hasOwnProperty('talkback');
  }  
  get basePrice() {
    return Math.round(super.basePrice + this._extras.premiumFee);
  }  
  get hasDinner() {
    return this._extras.hasOwnProperty('dinner') && !this.isPeakDay;
  }
}
+class PremiumBookingDelegate {
+ constructor(hostBooking, extras) {
+   this._host = hostBooking;
+   this._extras = extras;
+ }
+}
// 최상위
function createBooking(show, date) {
  return new Booking(show, date);
}
function createPremiumBooking(show, date, extras) {
  return new PremiumBooking(show, date, extras);
}
// 클라이언트(일반 예약)
aBooking = createBooking(show, date);
// 클라이언트(프리미엄 예약)
aBooking = createPremiumBooking(show, date, extras);
```
### STEP 1-3
[(3)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-10.md#3)[(4)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-10.md#4)이제 새로운 위임을 예약 객체와 연결할 차례다. 프리미엄 예약을 생성하는 팩터리 함수를 수정하면 된다.
```diff
class Booking {
  constructor(show, date) {
    this._show = show;
    this._date = date;
  }
  get hasTalkback() {
    return this._show.hasOwnProperty('talkback') && !this.isPeakDay;
  }
  get basePrice() {
    let result = this._show.price;
    if (this.isPeakDay) result += Math.round(result * 0.15);
    return result;
  }
+ _bePremium(extras) {
+   this._premiumDelegate = new PremiumBookingDelegate(this, extras);
+ }
}
class PremiumBooking extends Booking {
  constructor(show, date, extras) {
    super(show, date);
    this._extras = extras;
  }
  get hasTalkback() {
    return this._show.hasOwnProperty('talkback');
  }  
  get basePrice() {
    return Math.round(super.basePrice + this._extras.premiumFee);
  }  
  get hasDinner() {
    return this._extras.hasOwnProperty('dinner') && !this.isPeakDay;
  }
}
class PremiumBookingDelegate {
  constructor(hostBooking, extras) {
    this._host = hostBooking;
    this._extras = extras;
  }
}
// 최상위
function createBooking(show, date) {
  return new Booking(show, date);
}
function createPremiumBooking(show, date, extras) {
+ const result = new PremiumBooking(show, date, extras);
+ result._bePremium(extras);
- return new PremiumBooking(show, date, extras);
+ return result;
}
// 클라이언트(일반 예약)
aBooking = createBooking(show, date);
// 클라이언트(프리미엄 예약)
aBooking = createPremiumBooking(show, date, extras);
```
`_bePremium()` 메서드 이름 앞에 밑줄을 붙여 이 메서드가 `Booking`의 공개 인터페이스가 되어서는 안된다는 의도를 밝힌다. 만약 지금 리팩터링의 목적이 일반 예약과 프리미엄 예약을 상호 변환할 수 있게 하는 것이었다면 이 메서드는 public이어도 된다.

> 연결짓기 작업을 모두 `Booking`의 생성자에서 처리하는 방법도 있다. 이렇게 하려면 생성자에 프리미엄 예약의 존재를 알릴 수단이 필요하다. 먼저, 또 다른 매개변수를 추가하는 방법이 있다. 그리고 프리미엄 예약과 함께 쓰일 때는 언제나 `extra`가 있을 거라고 확신할 수 있다면, 그냥 `extra`를 사용할 수도 있다. 나는 명확히 드러내는 방식을 선호하므로 팩터리 함수를 이용하겠다.
### STEP 1-4
[(5)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-10.md#5)구조가 갖춰졌으니 다음은 기능을 옮길 차례다. 가장 먼저 고민할 부분은 `hasTalkback()`의 오버라이드 메서드다. 현재 코드는 다음과 같다.
```javascript
class Booking {
  ...
  get hasTalkback() {
    return this._show.hasOwnProperty('talkback') && !this.isPeakDay;
  }
  ...  
}
class PremiumBooking extends Booking {
  ...
  get hasTalkback() {
    return this._show.hasOwnProperty('talkback');
  }
  ...  
}
```
[(6)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-10.md#6) 먼저 [8.1 함수 옮기기(Move Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-1.md)를 적용해 서브클래스의 메서드를 위임으로 옮긴다. 새 보금자리에서도 잘 동작하도록 하기 위해 슈퍼클래스의 데이터를 사용하는 부분은 모두 `_host`를 통하도록 고친다.
```diff
class Booking {
  constructor(show, date) {
    this._show = show;
    this._date = date;
  }
  get hasTalkback() {
    return this._show.hasOwnProperty('talkback') && !this.isPeakDay;
  }
  get basePrice() {
    let result = this._show.price;
    if (this.isPeakDay) result += Math.round(result * 0.15);
    return result;
  }
  _bePremium(extras) {
    this._premiumDelegate = new PremiumBookingDelegate(this, extras);
  }
}
class PremiumBooking extends Booking {
  constructor(show, date, extras) {
    super(show, date);
    this._extras = extras;
  }
  get hasTalkback() {
-   return this._show.hasOwnProperty('talkback');
+   return this._premiumDelegate.hasTalkback;
  }  
  get basePrice() {
    return Math.round(super.basePrice + this._extras.premiumFee);
  }  
  get hasDinner() {
    return this._extras.hasOwnProperty('dinner') && !this.isPeakDay;
  }
}
class PremiumBookingDelegate {
  constructor(hostBooking, extras) {
    this._host = hostBooking;
    this._extras = extras;
  }
+ get hasTalkback() {
+   return this._host._show.hasOwnProperty('talkback');
+ }
}
// 최상위
function createBooking(show, date) {
  return new Booking(show, date);
}
function createPremiumBooking(show, date, extras) {
  const result = new PremiumBooking(show, date, extras);
  result._bePremium(extras);
  return result;
}
// 클라이언트(일반 예약)
aBooking = createBooking(show, date);
// 클라이언트(프리미엄 예약)
aBooking = createPremiumBooking(show, date, extras);
```
### STEP 1-5
[(7)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-10.md#7) 모든 기능이 잘 동작하는지 테스트한 후 서브클래스의 메서드를 삭제한다.
```diff
class Booking {
  constructor(show, date) {
    this._show = show;
    this._date = date;
  }
  get hasTalkback() {
    return this._show.hasOwnProperty('talkback') && !this.isPeakDay;
  }
  get basePrice() {
    let result = this._show.price;
    if (this.isPeakDay) result += Math.round(result * 0.15);
    return result;
  }
  _bePremium(extras) {
    this._premiumDelegate = new PremiumBookingDelegate(this, extras);
  }
}
class PremiumBooking extends Booking {
  constructor(show, date, extras) {
    super(show, date);
    this._extras = extras;
  }
- get hasTalkback() {
-   return this._premiumDelegate.hasTalkback;
- }  
  get basePrice() {
    return Math.round(super.basePrice + this._extras.premiumFee);
  }  
  get hasDinner() {
    return this._extras.hasOwnProperty('dinner') && !this.isPeakDay;
  }
}
class PremiumBookingDelegate {
  constructor(hostBooking, extras) {
    this._host = hostBooking;
    this._extras = extras;
  }
  get hasTalkback() {
    return this._host._show.hasOwnProperty('talkback');
  }
}
// 최상위
function createBooking(show, date) {
  return new Booking(show, date);
}
function createPremiumBooking(show, date, extras) {
  const result = new PremiumBooking(show, date, extras);
  result._bePremium(extras);
  return result;
}
// 클라이언트(일반 예약)
aBooking = createBooking(show, date);
// 클라이언트(프리미엄 예약)
aBooking = createPremiumBooking(show, date, extras);
```
### STEP 1-6
[(8)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-10.md#8) 이 시점에서 나는 지금까지 무언가 실수한 게 없는지 확인하기 위해 테스트를 수행한다.
위임이 존재하면 위임을 사용하는 분배 로직을 슈퍼클래스 메서드에 추가하고, 이것을 끝으로 이번 메서드 옮기기를 마무리한다.
```diff
class Booking {
  constructor(show, date) {
    this._show = show;
    this._date = date;
  }
  get hasTalkback() {
-   return this._show.hasOwnProperty('talkback') && !this.isPeakDay;
+   return (this._premiumDelegate) ? this._premiumDelegate.hasTalkback : this._show.hasOwnProperty('talkback') && !this.isPeakDay;
  }
  get basePrice() {
    let result = this._show.price;
    if (this.isPeakDay) result += Math.round(result * 0.15);
    return result;
  }
  _bePremium(extras) {
    this._premiumDelegate = new PremiumBookingDelegate(this, extras);
  }
}
class PremiumBooking extends Booking {
  constructor(show, date, extras) {
    super(show, date);
    this._extras = extras;
  }
  get basePrice() {
    return Math.round(super.basePrice + this._extras.premiumFee);
  }  
  get hasDinner() {
    return this._extras.hasOwnProperty('dinner') && !this.isPeakDay;
  }
}
class PremiumBookingDelegate {
  constructor(hostBooking, extras) {
    this._host = hostBooking;
    this._extras = extras;
  }
  get hasTalkback() {
    return this._host._show.hasOwnProperty('talkback');
  }
}
// 최상위
function createBooking(show, date) {
  return new Booking(show, date);
}
function createPremiumBooking(show, date, extras) {
  const result = new PremiumBooking(show, date, extras);
  result._bePremium(extras);
  return result;
}
// 클라이언트(일반 예약)
aBooking = createBooking(show, date);
// 클라이언트(프리미엄 예약)
aBooking = createPremiumBooking(show, date, extras);
```
### STEP 1-7
[(9)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-10.md#9) 이어서 살펴볼 대상은 기본 가격이다.
```javascript
class Booking {
  ...
  get basePrice() {
    let result = this._show.price;
    if (this.isPeakDay) result += Math.round(result * 0.15);
    return result;
  }
  ...  
}
class PremiumBooking extends Booking {
  ...
  get basePrice() {
    return Math.round(super.basePrice + this._extras.premiumFee);
  }
  ...  
}
```
앞서와 거의 같지만 `super`를 호출하는 성가신 부분에서 차이가 난다(이런 류의 서브클래스 확장에서 흔한 사례다). 서브클래스 코드를 위임으로 옮기려면 부모의 코드를 호출해야 하지만, 단순히 `this._host._basePrice`라고 쓰면 무한 재귀에 빠지고 만다.

선택지가 몇가지 있다.

1. 슈퍼클래스의 계산 로직을 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md)하여 가격 계산과 분배 로직을 분리하는 것이다(옮기기 작업의 나머지는 앞서와 똑같다).
```diff
class Booking {
  constructor(show, date) {
    this._show = show;
    this._date = date;
  }
  get hasTalkback() {
    return (this._premiumDelegate) ? this._premiumDelegate.hasTalkback : this._show.hasOwnProperty('talkback') && !this.isPeakDay;
  }
  get basePrice() {
-   let result = this._show.price;
-   if (this.isPeakDay) result += Math.round(result * 0.15);
-   return result;
+   return (this._premiumDelegate) ? this._premiumDelegate.basePrice : this._privateBasePrice;
  }
+ get _privateBasePrice() {
+   let result = this._show.price;
+   if (this.isPeakDay) result += Math.round(result * 0.15);
+   return result;
+ }
  _bePremium(extras) {
    this._premiumDelegate = new PremiumBookingDelegate(this, extras);
  }
}
class PremiumBooking extends Booking {
  constructor(show, date, extras) {
    super(show, date);
    this._extras = extras;
  }
  get basePrice() {
    return Math.round(super.basePrice + this._extras.premiumFee);
  }  
  get hasDinner() {
    return this._extras.hasOwnProperty('dinner') && !this.isPeakDay;
  }
}
class PremiumBookingDelegate {
  constructor(hostBooking, extras) {
    this._host = hostBooking;
    this._extras = extras;
  }
  get hasTalkback() {
    return this._host._show.hasOwnProperty('talkback');
  }
}
// 최상위
function createBooking(show, date) {
  return new Booking(show, date);
}
function createPremiumBooking(show, date, extras) {
  const result = new PremiumBooking(show, date, extras);
  result._bePremium(extras);
  return result;
}
// 클라이언트(일반 예약)
aBooking = createBooking(show, date);
// 클라이언트(프리미엄 예약)
aBooking = createPremiumBooking(show, date, extras);
```

2. 위임의 메서드를 기반 메서드의 확장 형태로 재호출한다.

```diff
class Booking {
  constructor(show, date) {
    this._show = show;
    this._date = date;
  }
  get hasTalkback() {
    return (this._premiumDelegate) ? this._premiumDelegate.hasTalkback : this._show.hasOwnProperty('talkback') && !this.isPeakDay;
  }
  get basePrice() {
    let result = this._show.price;
    if (this.isPeakDay) result += Math.round(result * 0.15);
-   return result;
+   return (this._premiumDelegate) ? this._premiumDelegate.extendBasePrice(result) : result;
  }
  _bePremium(extras) {
    this._premiumDelegate = new PremiumBookingDelegate(this, extras);
  }
}
class PremiumBooking extends Booking {
  constructor(show, date, extras) {
    super(show, date);
    this._extras = extras;
  }
  get basePrice() {
    return Math.round(super.basePrice + this._extras.premiumFee);
  }  
  get hasDinner() {
    return this._extras.hasOwnProperty('dinner') && !this.isPeakDay;
  }
}
class PremiumBookingDelegate {
  constructor(hostBooking, extras) {
    this._host = hostBooking;
    this._extras = extras;
  }
  get hasTalkback() {
    return this._host._show.hasOwnProperty('talkback');
  }
+ extendBasePrice(base) {
+   return Math.round(base + this._extras.premiumFee);
+ }
}
// 최상위
function createBooking(show, date) {
  return new Booking(show, date);
}
function createPremiumBooking(show, date, extras) {
  const result = new PremiumBooking(show, date, extras);
  result._bePremium(extras);
  return result;
}
// 클라이언트(일반 예약)
aBooking = createBooking(show, date);
// 클라이언트(프리미엄 예약)
aBooking = createPremiumBooking(show, date, extras);
```
두 선택지 모두 잘 작동하지만, 나는 살짝 더 짧다는 이유로 후자를 조금 더 선호한다.
### STEP 1-8
[(9)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-10.md#9) 마지막으로, 서브클래스에만 존재하는 메서드도 있을 것이다. 이 메서드는 위임으로 옮긴다. 그런 다음 `Booking`에 분배 로직을 추가한다.
```diff
class Booking {
  constructor(show, date) {
    this._show = show;
    this._date = date;
  }
  get hasTalkback() {
    return (this._premiumDelegate) ? this._premiumDelegate.hasTalkback : this._show.hasOwnProperty('talkback') && !this.isPeakDay;
  }
  get basePrice() {
    let result = this._show.price;
    if (this.isPeakDay) result += Math.round(result * 0.15);
    return (this._premiumDelegate) ? this._premiumDelegate.extendBasePrice(result) : result;
  }
  _bePremium(extras) {
    this._premiumDelegate = new PremiumBookingDelegate(this, extras);
  }
+ get hasDinner() {
+   return (this._premiumDelegate) ? this._premiumDelegate.hasDinner : undefined;
+ }
}
class PremiumBooking extends Booking {
  constructor(show, date, extras) {
    super(show, date);
    this._extras = extras;
  }
  get basePrice() {
    return Math.round(super.basePrice + this._extras.premiumFee);
  }  
- get hasDinner() {
-   return this._extras.hasOwnProperty('dinner') && !this.isPeakDay;
- }
}
class PremiumBookingDelegate {
  constructor(hostBooking, extras) {
    this._host = hostBooking;
    this._extras = extras;
  }
  get hasTalkback() {
    return this._host._show.hasOwnProperty('talkback');
  }
  extendBasePrice(base) {
    return Math.round(base + this._extras.premiumFee);
  }
+ get hasDinner() {
+   return this._extras.hasOwnProperty('dinner') && !this._host.isPeakDay;
+ }  
}
// 최상위
function createBooking(show, date) {
  return new Booking(show, date);
}
function createPremiumBooking(show, date, extras) {
  const result = new PremiumBooking(show, date, extras);
  result._bePremium(extras);
  return result;
}
// 클라이언트(일반 예약)
aBooking = createBooking(show, date);
// 클라이언트(프리미엄 예약)
aBooking = createPremiumBooking(show, date, extras);
```

> 자바스크립트에서는 객체에 존재하지 않는 속성에 접근하려 하면 `undefined`를 반환하므로 앞의 코드도 그렇게 처리했다. (사실 내 본능은 에러를 던지라고 소리친다. 다른 객체 지향 동적 언어였다면 에러를 던졌을 것이다.)
### STEP 1-9
[(10)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-10.md#10)서브클래스의 동작을 모두 옮겼다면 팩터리 메서드가 슈퍼클래스를 반환하도록 수정한다. [(11)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-10.md#11)그리고 모든 기능이 잘 동작하는지 테스트한 다음 [(12)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-10.md#12) 서브클래스를 삭제한다.
```diff
class Booking {
  constructor(show, date) {
    this._show = show;
    this._date = date;
  }
  get hasTalkback() {
    return (this._premiumDelegate) ? this._premiumDelegate.hasTalkback : this._show.hasOwnProperty('talkback') && !this.isPeakDay;
  }
  get basePrice() {
    let result = this._show.price;
    if (this.isPeakDay) result += Math.round(result * 0.15);
    return (this._premiumDelegate) ? this._premiumDelegate.extendBasePrice(result) : result;
  }
  _bePremium(extras) {
    this._premiumDelegate = new PremiumBookingDelegate(this, extras);
  }
  get hasDinner() {
    return (this._premiumDelegate) ? this._premiumDelegate.hasDinner : undefined;
  }
}
-class PremiumBooking extends Booking {
- constructor(show, date, extras) {
-   super(show, date);
-   this._extras = extras;
- }
- get basePrice() {
-   return Math.round(super.basePrice + this._extras.premiumFee);
- }  
-}
class PremiumBookingDelegate {
  constructor(hostBooking, extras) {
    this._host = hostBooking;
    this._extras = extras;
  }
  get hasTalkback() {
    return this._host._show.hasOwnProperty('talkback');
  }
  extendBasePrice(base) {
    return Math.round(base + this._extras.premiumFee);
  }
  get hasDinner() {
    return this._extras.hasOwnProperty('dinner') && !this._host.isPeakDay;
  }  
}
// 최상위
function createBooking(show, date) {
  return new Booking(show, date);
}
function createPremiumBooking(show, date, extras) {
- const result = new PremiumBooking(show, date, extras);
+ const result = new Booking(show, date, extras);
  result._bePremium(extras);
  return result;
}
// 클라이언트(일반 예약)
aBooking = createBooking(show, date);
// 클라이언트(프리미엄 예약)
aBooking = createPremiumBooking(show, date, extras);
```
이 리팩터링은 그 자체만으로는 코드를 개선한다고 느껴지지 않는다. 상속은 이 상황을 잘 다루고 있는데 반해, 위임을 적용하면 분배 로직과 양방향 참조가 더해지는 등 복잡도가 높아지기 때문이다. 그래도 이 리팩터링이 여전히 가치있을 수 있다. 동적으로 프리미엄 예약으로 바꿀 수 있다는 장점이 생겼고, 상속은 다른 목적으로 사용할 수 있게 되었다. 이 장점이 상속을 없애는 단점보다 클 수 있다.
## 예시: 서브클래스가 여러 개일 때
앞의 예에서는 서브클래스가 하나 뿐이었지만 서브클래스가 많을 때도 이번 리팩터링을 적용할 수 있다.
```javascript
function createBird(data) {
  switch(date.type) {
    case '유럽 제비':
      return new EuropeanSwallow(data);
    case '아프리카 제비':
      return new AfricanSwallow(data);
    case '노르웨이 파랑 앵무':
      return new NorwegianBlueParrot(data);
    default:
      return new Bird(data);
  }
}

class Bird {
  constructor(data) {
    this._name = data.name;
    this._plumage = data.plumage;
  }

  get name() {
    return this._name;
  }
  get plumage() {
    return this._plumage || '보통이다';
  }
  get airSpeedVelocity() {
    return null;
  }
}

class EuropeanSwallow extends Bird {
  get airSpeedVelocity() {
    return 35;
  }
}

class AfricanSwallow extends Bird {
  constructor(data) {
    super(data);
    this._numberOfCoconuts = data.numberOfCoconuts;
  }

  get airSpeedVelocity() {
    return 40 - 2 * this._numberOfCoconuts;
  }
}

class NorwegianBlueParrot extends Bird {
  constructor(data) {
    super(data);
    this._voltage = data.voltage;
    this._isNailed = data.isNailed;
  }

  get plumage() {
    if (this.voltage > 100) return '그을렸다';
    else return this._plumage || '예쁘다';
  }
  get airSpeedVelocity() {
    return (this._isNailed) ? 0 : 10 + this._voltage / 10;
  }
}
```
이 코드는 곧 야생(wild) 조류와 사육(captivity) 조류를 구분짓기 위해 크게 수정할 예정이다. 이 차이를 `WildBird`와 `CaptiveBird`라는 두 서브클래스로 모델링하는 방법도 있다. 하지만 상속은 한 번만 쓸 수 있으니 야생과 사육을 기준으로 나누려면 종에 따른 분류를 포기해야 한다.
### STEP 2-1
이처럼 서브클래스 여러 개가 관여된 경우라면 한 번에 하나씩, 간단한 것부터 시작한다. 지금 예에서는 유럽 제비(EuropeanSwallow)가 좋겠다. [(2)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-10.md#2) 우선 빈 위임 클래스를 만들어보자.
```diff
function createBird(data) {
  switch(date.type) {
    case '유럽 제비':
      return new EuropeanSwallow(data);
    case '아프리카 제비':
      return new AfricanSwallow(data);
    case '노르웨이 파랑 앵무':
      return new NorwegianBlueParrot(data);
    default:
      return new Bird(data);
  }
}

class Bird {
  constructor(data) {
    this._name = data.name;
    this._plumage = data.plumage;
  }

  get name() {
    return this._name;
  }
  get plumage() {
    return this._plumage || '보통이다';
  }
  get airSpeedVelocity() {
    return null;
  }
}

class EuropeanSwallow extends Bird {
  get airSpeedVelocity() {
    return 35;
  }
}

+class EuropeanSwallowDelegate {
+}

class AfricanSwallow extends Bird {
  constructor(data) {
    super(data);
    this._numberOfCoconuts = data.numberOfCoconuts;
  }

  get airSpeedVelocity() {
    return 40 - 2 * this._numberOfCoconuts;
  }
}

class NorwegianBlueParrot extends Bird {
  constructor(data) {
    super(data);
    this._voltage = data.voltage;
    this._isNailed = data.isNailed;
  }

  get plumage() {
    if (this.voltage > 100) return '그을렸다';
    else return this._plumage || '예쁘다';
  }
  get airSpeedVelocity() {
    return (this._isNailed) ? 0 : 10 + this._voltage / 10;
  }
}
```
아직은 데이터나 역참조 매개변수를 전혀 추가하지 않았다. 이번 예에서는 꼭 필요할 때만 추가할 것이다.
### STEP 2-2
[(3)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-10.md#3) 위임 필드를 어디에서 초기화해야 할지를 정해야 한다. 이 예에서는 생성자가 받는 유일한 인수인 `data`에 필요한 정보가 모두 담겨져 있으므로 생성자에서 처리하도록 하자. 그리고 위임을 여러 개 만들어야 하니 타입 코드를 기준으로 올바른 위임을 선택하는 메서드를 만든다.
```diff
function createBird(data) {
  switch(date.type) {
    case '유럽 제비':
      return new EuropeanSwallow(data);
    case '아프리카 제비':
      return new AfricanSwallow(data);
    case '노르웨이 파랑 앵무':
      return new NorwegianBlueParrot(data);
    default:
      return new Bird(data);
  }
}

class Bird {
  constructor(data) {
    this._name = data.name;
    this._plumage = data.plumage;
+   this._speciesDelegate = this.selectSpeciesDelegate(data);
  }

  get name() {
    return this._name;
  }
  get plumage() {
    return this._plumage || '보통이다';
  }
  get airSpeedVelocity() {
    return null;
  }
+ selectSpeciesDelegate(data) {
+   switch(data.type) {
+     case '유럽 제비':
+       return new EuropeanSwallowDelegate();
+     default: return null;
+   }
+ }
}

class EuropeanSwallow extends Bird {
  get airSpeedVelocity() {
    return 35;
  }
}

class EuropeanSwallowDelegate {
}

class AfricanSwallow extends Bird {
  constructor(data) {
    super(data);
    this._numberOfCoconuts = data.numberOfCoconuts;
  }

  get airSpeedVelocity() {
    return 40 - 2 * this._numberOfCoconuts;
  }
}

class NorwegianBlueParrot extends Bird {
  constructor(data) {
    super(data);
    this._voltage = data.voltage;
    this._isNailed = data.isNailed;
  }

  get plumage() {
    if (this.voltage > 100) return '그을렸다';
    else return this._plumage || '예쁘다';
  }
  get airSpeedVelocity() {
    return (this._isNailed) ? 0 : 10 + this._voltage / 10;
  }
}
```
### STEP 2-3
이제 구조가 갖춰졌으니 [(5)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-10.md#5)
[(6)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-10.md#6) 유럽 제비의 비행 속도 메서드를 위임으로 옮겨보자([8.1 함수 옮기기(Move Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-1.md))
```diff
function createBird(data) {
  switch(date.type) {
    case '유럽 제비':
      return new EuropeanSwallow(data);
    case '아프리카 제비':
      return new AfricanSwallow(data);
    case '노르웨이 파랑 앵무':
      return new NorwegianBlueParrot(data);
    default:
      return new Bird(data);
  }
}

class Bird {
  constructor(data) {
    this._name = data.name;
    this._plumage = data.plumage;
    this._speciesDelegate = this.selectSpeciesDelegate(data);
  }

  get name() {
    return this._name;
  }
  get plumage() {
    return this._plumage || '보통이다';
  }
  get airSpeedVelocity() {
    return null;
  }
  selectSpeciesDelegate(data) {
    switch(data.type) {
      case '유럽 제비':
        return new EuropeanSwallowDelegate();
      default: return null;
    }
  }
}

class EuropeanSwallow extends Bird {
  get airSpeedVelocity() {
-   return 35;
+   return this._speciesDelegate.airSpeedVelocity;
  }
}

class EuropeanSwallowDelegate {
+ get airSpeedVelocity() {
+   return 35;
+ }
}

class AfricanSwallow extends Bird {
  constructor(data) {
    super(data);
    this._numberOfCoconuts = data.numberOfCoconuts;
  }

  get airSpeedVelocity() {
    return 40 - 2 * this._numberOfCoconuts;
  }
}

class NorwegianBlueParrot extends Bird {
  constructor(data) {
    super(data);
    this._voltage = data.voltage;
    this._isNailed = data.isNailed;
  }

  get plumage() {
    if (this.voltage > 100) return '그을렸다';
    else return this._plumage || '예쁘다';
  }
  get airSpeedVelocity() {
    return (this._isNailed) ? 0 : 10 + this._voltage / 10;
  }
}
```
### STEP 2-4
다음으로 슈퍼클래스의 `airSpeecVelocity()`를 수정하여, 위임이 존재하면 위임의 메서드를 호출하도록 한다.
```diff
function createBird(data) {
  switch(date.type) {
    case '유럽 제비':
      return new EuropeanSwallow(data);
    case '아프리카 제비':
      return new AfricanSwallow(data);
    case '노르웨이 파랑 앵무':
      return new NorwegianBlueParrot(data);
    default:
      return new Bird(data);
  }
}

class Bird {
  constructor(data) {
    this._name = data.name;
    this._plumage = data.plumage;
    this._speciesDelegate = this.selectSpeciesDelegate(data);
  }

  get name() {
    return this._name;
  }
  get plumage() {
    return this._plumage || '보통이다';
  }
  get airSpeedVelocity() {
-   return null;
+   return this._speciesDelegate ? this._speciesDelegate.airSpeedVelocity : null;
  }
  selectSpeciesDelegate(data) {
    switch(data.type) {
      case '유럽 제비':
        return new EuropeanSwallowDelegate();
      default: return null;
    }
  }
}

class EuropeanSwallow extends Bird {
  get airSpeedVelocity() {
    return this._speciesDelegate.airSpeedVelocity;
  }
}

class EuropeanSwallowDelegate {
  get airSpeedVelocity() {
    return 35;
  }
}

class AfricanSwallow extends Bird {
  constructor(data) {
    super(data);
    this._numberOfCoconuts = data.numberOfCoconuts;
  }

  get airSpeedVelocity() {
    return 40 - 2 * this._numberOfCoconuts;
  }
}

class NorwegianBlueParrot extends Bird {
  constructor(data) {
    super(data);
    this._voltage = data.voltage;
    this._isNailed = data.isNailed;
  }

  get plumage() {
    if (this.voltage > 100) return '그을렸다';
    else return this._plumage || '예쁘다';
  }
  get airSpeedVelocity() {
    return (this._isNailed) ? 0 : 10 + this._voltage / 10;
  }
}
```
### STEP 2-5
[(12)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-10.md#12) 그리고 유럽 제비 서브클래스를 제거한다.
```diff
function createBird(data) {
  switch(date.type) {
-   case '유럽 제비':
-     return new EuropeanSwallow(data);
    case '아프리카 제비':
      return new AfricanSwallow(data);
    case '노르웨이 파랑 앵무':
      return new NorwegianBlueParrot(data);
    default:
      return new Bird(data);
  }
}

class Bird {
  constructor(data) {
    this._name = data.name;
    this._plumage = data.plumage;
    this._speciesDelegate = this.selectSpeciesDelegate(data);
  }

  get name() {
    return this._name;
  }
  get plumage() {
    return this._plumage || '보통이다';
  }
  get airSpeedVelocity() {
    return this._speciesDelegate ? this._speciesDelegate.airSpeedVelocity : null;
  }
  selectSpeciesDelegate(data) {
    switch(data.type) {
      case '유럽 제비':
        return new EuropeanSwallowDelegate();
      default: return null;
    }
  }
}

-class EuropeanSwallow extends Bird {
- get airSpeedVelocity() {
-   return this._speciesDelegate.airSpeedVelocity;
- }
-}

class EuropeanSwallowDelegate {
  get airSpeedVelocity() {
    return 35;
  }
}

class AfricanSwallow extends Bird {
  constructor(data) {
    super(data);
    this._numberOfCoconuts = data.numberOfCoconuts;
  }

  get airSpeedVelocity() {
    return 40 - 2 * this._numberOfCoconuts;
  }
}

class NorwegianBlueParrot extends Bird {
  constructor(data) {
    super(data);
    this._voltage = data.voltage;
    this._isNailed = data.isNailed;
  }

  get plumage() {
    if (this.voltage > 100) return '그을렸다';
    else return this._plumage || '예쁘다';
  }
  get airSpeedVelocity() {
    return (this._isNailed) ? 0 : 10 + this._voltage / 10;
  }
}
```
### STEP 2-6
[(2)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-10.md#2) 다음은 아프리카 제비(African swallow) 차례다. 역시 위임 클래스를 만드는데, 이번에는 생성자에서 데이터를 받도록 한다.
```diff
function createBird(data) {
  switch(date.type) {
    case '아프리카 제비':
      return new AfricanSwallow(data);
    case '노르웨이 파랑 앵무':
      return new NorwegianBlueParrot(data);
    default:
      return new Bird(data);
  }
}

class Bird {
  constructor(data) {
    this._name = data.name;
    this._plumage = data.plumage;
    this._speciesDelegate = this.selectSpeciesDelegate(data);
  }

  get name() {
    return this._name;
  }
  get plumage() {
    return this._plumage || '보통이다';
  }
  get airSpeedVelocity() {
    return this._speciesDelegate ? this._speciesDelegate.airSpeedVelocity : null;
  }
  selectSpeciesDelegate(data) {
    switch(data.type) {
      case '유럽 제비':
        return new EuropeanSwallowDelegate();
+     case '아프리카 제비':
+       return new AfricanSwallowDelegate(data);
      default: return null;
    }
  }
}

class EuropeanSwallowDelegate {
  get airSpeedVelocity() {
    return 35;
  }
}

class AfricanSwallow extends Bird {
  constructor(data) {
    super(data);
    this._numberOfCoconuts = data.numberOfCoconuts;
  }

  get airSpeedVelocity() {
    return 40 - 2 * this._numberOfCoconuts;
  }
}

+class AfricanSwallowDelegate {
+ constructor(data) {
+   this._numberOfCoconuts = data.numberOfCoconuts;
+ }
+}

class NorwegianBlueParrot extends Bird {
  constructor(data) {
    super(data);
    this._voltage = data.voltage;
    this._isNailed = data.isNailed;
  }

  get plumage() {
    if (this.voltage > 100) return '그을렸다';
    else return this._plumage || '예쁘다';
  }
  get airSpeedVelocity() {
    return (this._isNailed) ? 0 : 10 + this._voltage / 10;
  }
}
```
### STEP 2-7
[(5)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-10.md#5)[(6)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-10.md#6) 역시 `airSpeedVelocity()` 함수를 [8.1 함수 옮기기(Move Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-1.md) 한다.
```diff
function createBird(data) {
  switch(date.type) {
    case '아프리카 제비':
      return new AfricanSwallow(data);
    case '노르웨이 파랑 앵무':
      return new NorwegianBlueParrot(data);
    default:
      return new Bird(data);
  }
}

class Bird {
  constructor(data) {
    this._name = data.name;
    this._plumage = data.plumage;
    this._speciesDelegate = this.selectSpeciesDelegate(data);
  }

  get name() {
    return this._name;
  }
  get plumage() {
    return this._plumage || '보통이다';
  }
  get airSpeedVelocity() {
    return this._speciesDelegate ? this._speciesDelegate.airSpeedVelocity : null;
  }
  selectSpeciesDelegate(data) {
    switch(data.type) {
      case '유럽 제비':
        return new EuropeanSwallowDelegate();
      case '아프리카 제비':
        return new AfricanSwallowDelegate(data);
      default: return null;
    }
  }
}

class EuropeanSwallowDelegate {
  get airSpeedVelocity() {
    return 35;
  }
}

class AfricanSwallow extends Bird {
  constructor(data) {
    super(data);
    this._numberOfCoconuts = data.numberOfCoconuts;
  }

  get airSpeedVelocity() {
-   return 40 - 2 * this._numberOfCoconuts;
+   return this._speciesDelegate.airSpeedVelocity;
  }
}

class AfricanSwallowDelegate {
  constructor(data) {
    this._numberOfCoconuts = data.numberOfCoconuts;
  }

+ get airSpeedVelocity() {
+   return 40 - 2 * this._numberOfCoconuts;
+ }  
}

class NorwegianBlueParrot extends Bird {
  constructor(data) {
    super(data);
    this._voltage = data.voltage;
    this._isNailed = data.isNailed;
  }

  get plumage() {
    if (this.voltage > 100) return '그을렸다';
    else return this._plumage || '예쁘다';
  }
  get airSpeedVelocity() {
    return (this._isNailed) ? 0 : 10 + this._voltage / 10;
  }
}
```
### STEP 2-8
[(12)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-10.md#12) 이제 아프리카 제비 서브클래스를 제거한다.
```diff
function createBird(data) {
  switch(date.type) {
-   case '아프리카 제비':
-     return new AfricanSwallow(data);
    case '노르웨이 파랑 앵무':
      return new NorwegianBlueParrot(data);
    default:
      return new Bird(data);
  }
}

class Bird {
  constructor(data) {
    this._name = data.name;
    this._plumage = data.plumage;
    this._speciesDelegate = this.selectSpeciesDelegate(data);
  }

  get name() {
    return this._name;
  }
  get plumage() {
    return this._plumage || '보통이다';
  }
  get airSpeedVelocity() {
    return this._speciesDelegate ? this._speciesDelegate.airSpeedVelocity : null;
  }
  selectSpeciesDelegate(data) {
    switch(data.type) {
      case '유럽 제비':
        return new EuropeanSwallowDelegate();
      case '아프리카 제비':
        return new AfricanSwallowDelegate(data);
      default: return null;
    }
  }
}

class EuropeanSwallowDelegate {
  get airSpeedVelocity() {
    return 35;
  }
}

-class AfricanSwallow extends Bird {
- constructor(data) {
-   super(data);
-   this._numberOfCoconuts = data.numberOfCoconuts;
- }

- get airSpeedVelocity() {
-   return this._speciesDelegate.airSpeedVelocity;
- }
-}

class AfricanSwallowDelegate {
  constructor(data) {
    this._numberOfCoconuts = data.numberOfCoconuts;
  }

  get airSpeedVelocity() {
    return 40 - 2 * this._numberOfCoconuts;
  }  
}

class NorwegianBlueParrot extends Bird {
  constructor(data) {
    super(data);
    this._voltage = data.voltage;
    this._isNailed = data.isNailed;
  }

  get plumage() {
    if (this.voltage > 100) return '그을렸다';
    else return this._plumage || '예쁘다';
  }
  get airSpeedVelocity() {
    return (this._isNailed) ? 0 : 10 + this._voltage / 10;
  }
}
```
### STEP 2-9
[(2)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-10.md#2) 이번엔 노르웨이 파랑 앵무(Norwegian Blue Parrot) 차례다. 똑같은 순서로 위임 클래스를 만들고 [(5)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-10.md#5)[(6)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-10.md#6) 비행 속도 함수를 옮긴다. 결과는 다음과 같다.
```diff
function createBird(data) {
  switch(date.type) {
    case '노르웨이 파랑 앵무':
      return new NorwegianBlueParrot(data);
    default:
      return new Bird(data);
  }
}

class Bird {
  constructor(data) {
    this._name = data.name;
    this._plumage = data.plumage;
    this._speciesDelegate = this.selectSpeciesDelegate(data);
  }

  get name() {
    return this._name;
  }
  get plumage() {
    return this._plumage || '보통이다';
  }
  get airSpeedVelocity() {
    return this._speciesDelegate ? this._speciesDelegate.airSpeedVelocity : null;
  }
  selectSpeciesDelegate(data) {
    switch(data.type) {
      case '유럽 제비':
        return new EuropeanSwallowDelegate();
      case '아프리카 제비':
        return new AfricanSwallowDelegate(data);
+     case '노르웨이 파랑 앵무:
+       return new NorwegianBlueParrotDelegate(data);
      default: return null;
    }
  }
}

class EuropeanSwallowDelegate {
  get airSpeedVelocity() {
    return 35;
  }
}

class AfricanSwallowDelegate {
  constructor(data) {
    this._numberOfCoconuts = data.numberOfCoconuts;
  }

  get airSpeedVelocity() {
    return 40 - 2 * this._numberOfCoconuts;
  }  
}

class NorwegianBlueParrot extends Bird {
  constructor(data) {
    super(data);
    this._voltage = data.voltage;
    this._isNailed = data.isNailed;
  }

  get plumage() {
    if (this.voltage > 100) return '그을렸다';
    else return this._plumage || '예쁘다';
  }
  get airSpeedVelocity() {
    return (this._isNailed) ? 0 : 10 + this._voltage / 10;
  }
}

+class NorwegianBlueParrotDelegate {
+ constructor(data) {
+   this._voltage = data.voltage;
+   this._isNailed = data.isNailed;
+ }
+ get airSpeedVelocity() {
+   return (this._isNailed) ? 0 : 10 + this._voltage / 10;
+ }
+}
```
### STEP 2-10
모두 잘 된 듯 보이지만 다른 서브클래스 때는 다루지 않은 부분이 보인다. [(5)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-10.md#5) 바로 노르웨이 파랑 앵무는 깃털 상태, 즉 `plumage()`를 오버라이드한다는 점이다. [(6)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-10.md#6) 이 메서드를 옮기는 작업의 초반은 여전히 간단하다. 생성자에 `Bird`로의 역참조를 추가해야 한다는 점 정도만 다르다.
```diff
function createBird(data) {
  switch(date.type) {
    case '노르웨이 파랑 앵무':
      return new NorwegianBlueParrot(data);
    default:
      return new Bird(data);
  }
}

class Bird {
  constructor(data) {
    this._name = data.name;
    this._plumage = data.plumage;
    this._speciesDelegate = this.selectSpeciesDelegate(data);
  }

  get name() {
    return this._name;
  }
  get plumage() {
    return this._plumage || '보통이다';
  }
  get airSpeedVelocity() {
    return this._speciesDelegate ? this._speciesDelegate.airSpeedVelocity : null;
  }
  selectSpeciesDelegate(data) {
    switch(data.type) {
      case '유럽 제비':
        return new EuropeanSwallowDelegate();
      case '아프리카 제비':
        return new AfricanSwallowDelegate(data);
      case '노르웨이 파랑 앵무:
-       return new NorwegianBlueParrotDelegate(data);
+       return new NorwegianBlueParrotDelegate(data, this);
      default: return null;
    }
  }
}

class EuropeanSwallowDelegate {
  get airSpeedVelocity() {
    return 35;
  }
}

class AfricanSwallowDelegate {
  constructor(data) {
    this._numberOfCoconuts = data.numberOfCoconuts;
  }

  get airSpeedVelocity() {
    return 40 - 2 * this._numberOfCoconuts;
  }  
}

class NorwegianBlueParrot extends Bird {
  constructor(data) {
    super(data);
    this._voltage = data.voltage;
    this._isNailed = data.isNailed;
  }

  get plumage() {
-   if (this.voltage > 100) return '그을렸다';
-   else return this._plumage || '예쁘다';
+   return this._speciesDelegate.plumage;
  }
  get airSpeedVelocity() {
    return (this._isNailed) ? 0 : 10 + this._voltage / 10;
  }
}

class NorwegianBlueParrotDelegate {
- constructor(data) {
+ constructor(data, bird) {
+   this._bird = bird;
    this._voltage = data.voltage;
    this._isNailed = data.isNailed;
  }
  get airSpeedVelocity() {
    return (this._isNailed) ? 0 : 10 + this._voltage / 10;
  }
+ get plumage() {
+   if (this.voltage > 100) return '그을렸다';
+   else return this._plumage || '예쁘다';
+ }
}
```
### STEP 2-11
[(7)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-10.md#7) 까다로운 단계는 서브클래스에서 `plumage()` 메서드를 어떻게 제거하느냐다. 다음처럼 시도하면 다른 종의 위임에서는 이 속성이 없기 때문에 다수의 오류가 발생할 것이다.
```diff
function createBird(data) {
  switch(date.type) {
    case '노르웨이 파랑 앵무':
      return new NorwegianBlueParrot(data);
    default:
      return new Bird(data);
  }
}

class Bird {
  constructor(data) {
    this._name = data.name;
    this._plumage = data.plumage;
    this._speciesDelegate = this.selectSpeciesDelegate(data);
  }

  get name() {
    return this._name;
  }
  get plumage() {
-   return this._plumage || '보통이다';
+   if (this._speciesDelegate)
+     return this._speciesDelegate.plumage;
+   else
+     return this._plumage || '보통이다';
  }
  get airSpeedVelocity() {
    return this._speciesDelegate ? this._speciesDelegate.airSpeedVelocity : null;
  }
  selectSpeciesDelegate(data) {
    switch(data.type) {
      case '유럽 제비':
        return new EuropeanSwallowDelegate();
      case '아프리카 제비':
        return new AfricanSwallowDelegate(data);
      case '노르웨이 파랑 앵무:
        return new NorwegianBlueParrotDelegate(data, this);
      default: return null;
    }
  }
}

class EuropeanSwallowDelegate {
  get airSpeedVelocity() {
    return 35;
  }
}

class AfricanSwallowDelegate {
  constructor(data) {
    this._numberOfCoconuts = data.numberOfCoconuts;
  }

  get airSpeedVelocity() {
    return 40 - 2 * this._numberOfCoconuts;
  }  
}

class NorwegianBlueParrot extends Bird {
  constructor(data) {
    super(data);
    this._voltage = data.voltage;
    this._isNailed = data.isNailed;
  }

  get plumage() {
    return this._speciesDelegate.plumage;
  }
  get airSpeedVelocity() {
    return (this._isNailed) ? 0 : 10 + this._voltage / 10;
  }
}

class NorwegianBlueParrotDelegate {
  constructor(data, bird) {
    this._bird = bird;
    this._voltage = data.voltage;
    this._isNailed = data.isNailed;
  }
  get airSpeedVelocity() {
    return (this._isNailed) ? 0 : 10 + this._voltage / 10;
  }
  get plumage() {
    if (this.voltage > 100) return '그을렸다';
    else return this._plumage || '예쁘다';
  }
}
```
### STEP 2-12
다음처럼 조건을 더 정교하게 검사하는 방법도 있다.
```diff
function createBird(data) {
  switch(date.type) {
    case '노르웨이 파랑 앵무':
      return new NorwegianBlueParrot(data);
    default:
      return new Bird(data);
  }
}

class Bird {
  constructor(data) {
    this._name = data.name;
    this._plumage = data.plumage;
    this._speciesDelegate = this.selectSpeciesDelegate(data);
  }

  get name() {
    return this._name;
  }
  get plumage() {
-   return this._plumage || '보통이다';
+   if (this._speciesDelegate instanceof NorwegianBlueParrotDelegate)
+     return this._speciesDelegate.plumage;
+   else
+     return this._plumage || '보통이다';
  }
  get airSpeedVelocity() {
    return this._speciesDelegate ? this._speciesDelegate.airSpeedVelocity : null;
  }
  selectSpeciesDelegate(data) {
    switch(data.type) {
      case '유럽 제비':
        return new EuropeanSwallowDelegate();
      case '아프리카 제비':
        return new AfricanSwallowDelegate(data);
      case '노르웨이 파랑 앵무:
        return new NorwegianBlueParrotDelegate(data, this);
      default: return null;
    }
  }
}

class EuropeanSwallowDelegate {
  get airSpeedVelocity() {
    return 35;
  }
}

class AfricanSwallowDelegate {
  constructor(data) {
    this._numberOfCoconuts = data.numberOfCoconuts;
  }

  get airSpeedVelocity() {
    return 40 - 2 * this._numberOfCoconuts;
  }  
}

class NorwegianBlueParrot extends Bird {
  constructor(data) {
    super(data);
    this._voltage = data.voltage;
    this._isNailed = data.isNailed;
  }

  get plumage() {
    return this._speciesDelegate.plumage;
  }
  get airSpeedVelocity() {
    return (this._isNailed) ? 0 : 10 + this._voltage / 10;
  }
}

class NorwegianBlueParrotDelegate {
  constructor(data, bird) {
    this._bird = bird;
    this._voltage = data.voltage;
    this._isNailed = data.isNailed;
  }
  get airSpeedVelocity() {
    return (this._isNailed) ? 0 : 10 + this._voltage / 10;
  }
  get plumage() {
    if (this.voltage > 100) return '그을렸다';
    else return this._plumage || '예쁘다';
  }
}
```
여러분도 이 코드에서 악취를 맡았기를 바란다. 이처럼 클래스의 종류를 꼭 집어서 검사하는 것은 절대 좋은 생각이 아니다.
### STEP 2-13
또 다른 선택지로, 기본값을 두고 노르웨이 파랑 앵무만 특별히 취급하는 방식도 있다.
```diff
function createBird(data) {
  switch(date.type) {
    case '노르웨이 파랑 앵무':
      return new NorwegianBlueParrot(data);
    default:
      return new Bird(data);
  }
}

class Bird {
  constructor(data) {
    this._name = data.name;
    this._plumage = data.plumage;
    this._speciesDelegate = this.selectSpeciesDelegate(data);
  }

  get name() {
    return this._name;
  }
  get plumage() {
-   return this._plumage || '보통이다';
+   if (this._speciesDelegate)
+     return this._speciesDelegate.plumage;
+   else
+     return this._plumage || '보통이다';
  }
  get airSpeedVelocity() {
    return this._speciesDelegate ? this._speciesDelegate.airSpeedVelocity : null;
  }
  selectSpeciesDelegate(data) {
    switch(data.type) {
      case '유럽 제비':
        return new EuropeanSwallowDelegate();
      case '아프리카 제비':
        return new AfricanSwallowDelegate(data);
      case '노르웨이 파랑 앵무:
        return new NorwegianBlueParrotDelegate(data, this);
      default: return null;
    }
  }
}

class EuropeanSwallowDelegate {
  get airSpeedVelocity() {
    return 35;
  }
+ get plumage() {
+   return this._bird._plumage || '보통이다';
+ }
}

class AfricanSwallowDelegate {
  constructor(data) {
    this._numberOfCoconuts = data.numberOfCoconuts;
  }

  get airSpeedVelocity() {
    return 40 - 2 * this._numberOfCoconuts;
  }
+ get plumage() {
+   return this._bird._plumage || '보통이다';
+ }    
}

class NorwegianBlueParrot extends Bird {
  constructor(data) {
    super(data);
    this._voltage = data.voltage;
    this._isNailed = data.isNailed;
  }

  get plumage() {
    return this._speciesDelegate.plumage;
  }
  get airSpeedVelocity() {
    return (this._isNailed) ? 0 : 10 + this._voltage / 10;
  }
}

class NorwegianBlueParrotDelegate {
  constructor(data, bird) {
    this._bird = bird;
    this._voltage = data.voltage;
    this._isNailed = data.isNailed;
  }
  get airSpeedVelocity() {
    return (this._isNailed) ? 0 : 10 + this._voltage / 10;
  }
  get plumage() {
    if (this.voltage > 100) return '그을렸다';
    else return this._plumage || '예쁘다';
  }
}
```
하지만 `plumage()`의 기본 메서드가 여러 클래스에 중복되어 들어가는 결과를 낳는다. 여기에 더해서 몇몇 생성자에서 역참조를 대입하는 코드 역시 중복될 수 있다.

### STEP 2-14
이 중복을 해결하는 자연스러운 방법은 바로 '상속'이다. 지금까지 만든 종 분류용 위임들에서 [12.8 슈퍼클래스 추출하기(Extract Subclasses)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-8.md) 해보자.

```diff
function createBird(data) {
  switch(date.type) {
    case '노르웨이 파랑 앵무':
      return new NorwegianBlueParrot(data);
    default:
      return new Bird(data);
  }
}

class Bird {
  constructor(data) {
    this._name = data.name;
    this._plumage = data.plumage;
    this._speciesDelegate = this.selectSpeciesDelegate(data);
  }

  get name() {
    return this._name;
  }
  get plumage() {
    return this._plumage || '보통이다';
  }
  get airSpeedVelocity() {
    return this._speciesDelegate ? this._speciesDelegate.airSpeedVelocity : null;
  }
  selectSpeciesDelegate(data) {
    switch(data.type) {
      case '유럽 제비':
        return new EuropeanSwallowDelegate();
      case '아프리카 제비':
        return new AfricanSwallowDelegate(data);
      case '노르웨이 파랑 앵무:
        return new NorwegianBlueParrotDelegate(data, this);
      default: return null;
    }
  }
}

+class SpeciesDelegate {
+ constructor(data, bird) {
+   this._bird = bird;
+ }
+ get plumage() {
+   return this._bird.plumage || '보통이다';
+ }
+}

-class EuropeanSwallowDelegate {
+class EuropeanSwallowDelegate extends SpeciesDelegate {  
  get airSpeedVelocity() {
    return 35;
  }
}

-class AfricanSwallowDelegate {
+class AfricanSwallowDelegate extends SpeciesDelegate {  
- constructor(data) {  
+ constructor(data, bird) {
+   super(data, bird);    
    this._numberOfCoconuts = data.numberOfCoconuts;
  }

  get airSpeedVelocity() {
    return 40 - 2 * this._numberOfCoconuts;
  }
}

class NorwegianBlueParrot extends Bird {
  constructor(data) {
    super(data);
    this._voltage = data.voltage;
    this._isNailed = data.isNailed;
  }

  get plumage() {
    return this._speciesDelegate.plumage;
  }
  get airSpeedVelocity() {
    return (this._isNailed) ? 0 : 10 + this._voltage / 10;
  }
}

-class NorwegianBlueParrotDelegate {
+class NorwegianBlueParrotDelegate extends SpeciesDelegate {  
  constructor(data, bird) {
-   this._bird = bird;
+   super(data, bird);        
    this._voltage = data.voltage;
    this._isNailed = data.isNailed;
  }
  get airSpeedVelocity() {
    return (this._isNailed) ? 0 : 10 + this._voltage / 10;
  }
  get plumage() {
    if (this.voltage > 100) return '그을렸다';
    else return this._plumage || '예쁘다';
  }
}
```
### STEP 2-15
슈퍼클래스가 생겼으니 `Bird`의 기본 동작 모두를 `SpeciesDelegate` 클래스로 옮길 수 있다. 그리고 `SpeciesDelegate` 필드에는 언제나 값이 들어 있음이 보장된다.
```diff
function createBird(data) {
  switch(date.type) {
    case '노르웨이 파랑 앵무':
      return new NorwegianBlueParrot(data);
    default:
      return new Bird(data);
  }
}

class Bird {
  constructor(data) {
    this._name = data.name;
    this._plumage = data.plumage;
    this._speciesDelegate = this.selectSpeciesDelegate(data);
  }

  get name() {
    return this._name;
  }
  get plumage() {
-   return this._plumage || '보통이다';
+   return this._speciesDelegate.plumage;
  }
  get airSpeedVelocity() {
-   return this._speciesDelegate ? this._speciesDelegate.airSpeedVelocity : null;
+   return this._speciesDelegate.airSpeedVelocity;
  }
  selectSpeciesDelegate(data) {
    switch(data.type) {
      case '유럽 제비':
        return new EuropeanSwallowDelegate();
      case '아프리카 제비':
        return new AfricanSwallowDelegate(data);
      case '노르웨이 파랑 앵무:
        return new NorwegianBlueParrotDelegate(data, this);
-     default: return null;
+     default: return new SpeciesDelegate(data, this);
    }
  }
}

class SpeciesDelegate {
  constructor(data, bird) {
    this._bird = bird;
  }
  get plumage() {
    return this._bird.plumage || '보통이다';
  }
+ get airSpeedVelocity() {
+   return null;
+ }
}

class EuropeanSwallowDelegate extends SpeciesDelegate {  
  get airSpeedVelocity() {
    return 35;
  }
}

class AfricanSwallowDelegate extends SpeciesDelegate {  
  constructor(data, bird) {
    super(data, bird);    
    this._numberOfCoconuts = data.numberOfCoconuts;
  }

  get airSpeedVelocity() {
    return 40 - 2 * this._numberOfCoconuts;
  }
}

class NorwegianBlueParrot extends Bird {
  constructor(data) {
    super(data);
    this._voltage = data.voltage;
    this._isNailed = data.isNailed;
  }

  get plumage() {
    return this._speciesDelegate.plumage;
  }
  get airSpeedVelocity() {
    return (this._isNailed) ? 0 : 10 + this._voltage / 10;
  }
}

class NorwegianBlueParrotDelegate extends SpeciesDelegate {  
  constructor(data, bird) {
    super(data, bird);        
    this._voltage = data.voltage;
    this._isNailed = data.isNailed;
  }
  get airSpeedVelocity() {
    return (this._isNailed) ? 0 : 10 + this._voltage / 10;
  }
  get plumage() {
    if (this.voltage > 100) return '그을렸다';
    else return this._plumage || '예쁘다';
  }
}
```
### STEP 2-16
`Bird`의 위임 메서드가 간결해지기 때문에 나는 이 방식을 좋아한다. 이 방식에서는 어떤 동작이 `SpeciesDelegate`로 위임되었고, 무엇이 남겨졌는지를 쉽게 확인할 수 있다.

다음은 이 클래스들의 최종 모습이다.
```javascript
function createBird(data) {
  return new Bird(data);
}

class Bird {
  constructor(data) {
    this._name = data.name;
    this._plumage = data.plumage;
    this._speciesDelegate = this.selectSpeciesDelegate(data);
  }

  get name() {
    return this._name;
  }
  get plumage() {
    return this._speciesDelegate.plumage;
  }
  get airSpeedVelocity() {
    return this._speciesDelegate.airSpeedVelocity;
  }
  selectSpeciesDelegate(data) {
    switch(data.type) {
      case '유럽 제비':
        return new EuropeanSwallowDelegate(data, this);
      case '아프리카 제비':
        return new AfricanSwallowDelegate(data, this);
      case '노르웨이 파랑 앵무:
        return new NorwegianBlueParrotDelegate(data, this);
      default: return new SpeciesDelegate(data, this);
    }
  }
}

class SpeciesDelegate {
  constructor(data, bird) {
    this._bird = bird;
  }
  get plumage() {
    return this._bird.plumage || '보통이다';
  }
  get airSpeedVelocity() {
    return null;
  }
}

class EuropeanSwallowDelegate extends SpeciesDelegate {  
  get airSpeedVelocity() {
    return 35;
  }
}

class AfricanSwallowDelegate extends SpeciesDelegate {  
  constructor(data, bird) {
    super(data, bird);    
    this._numberOfCoconuts = data.numberOfCoconuts;
  }

  get airSpeedVelocity() {
    return 40 - 2 * this._numberOfCoconuts;
  }
}

class NorwegianBlueParrotDelegate extends SpeciesDelegate {  
  constructor(data, bird) {
    super(data, bird);        
    this._voltage = data.voltage;
    this._isNailed = data.isNailed;
  }
  get airSpeedVelocity() {
    return (this._isNailed) ? 0 : 10 + this._voltage / 10;
  }
  get plumage() {
    if (this.voltage > 100) return '그을렸다';
    else return this._plumage || '예쁘다';
  }
}
```
이 예시는 원래의 서브클래스들을 위임으로 교체했지만 `SpeciesDelegate`에는 여전히 처음 구조와 매우 비슷한 계층구조가 존재한다. `Bird`를 상속으로부터 구제한 것 외에 이 리팩터링에서 얻은 것은 무엇일까? 위임으로 옮겨진 종 계층구조는 더 엄격하게 종과 관련한 내용만을 다루게 되었다. 다시 말해, 위임 클래스들은 종에 따라 달라지는 데이터와 메서드만을 담게 되고 종과 상관없는 공통코드는 `Bird` 자체와 미래의 서브클래스들에 남는다.

위임에서 슈퍼클래스를 추출해 상속구조로 만드는 방식을 앞서의 예약 예시에도 적용할 수 있었다. 그렇게 했다면 분배 로직을 처리하는 `Booking`의 메서드들을 위임을 호출하는 간단한 코드를 대체할 수 있다(분배는 상속으로 처리한다).

- [12.9 계층 합치기(Collapse Hierarchy)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-9.md)
- [12.11 슈퍼클래스를 위임으로 바꾸기(Replace Superclass with Delegate)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-11.md)