# 12.7 서브클래스 제거하기(Remove Subclasses)
- 반대 리팩터링: [12.6 타입 코드를 서브클래스로 바꾸기(Replace Type Code with Subclasses)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-6.md)
- 1판에서의 이름: 하위클래스를 필드로 전환
``` diff
class Person {
  get genderCode() {
-   return "X";
+   return this._genderCode;
  }
}
-class Male extends Person {
- get genderCode() {
-   return "M";
- }
-}
-class Female extends Person {
- get genderCode() {
-   return "F";
- }
-}
```

## 배경
서브클래싱은 원래 데이터 구조와 다른 변종을 만들거나 종류에 따라 동작이 달라지게 할 수 있는 유용한 메커니즘이다. 다름을 프로그래밍하는 멋진 수단인 것이다. 하지만 소프트웨어 시스템이 성장함에 따라 서브클래스로 만든 변종이 다른 모듈로 이동하거나 완전히 사라지기도 하면서 가치가 바래기도 한다. 서브클래스는 결국 한 번도 활용되지 않기도 하며, 때론 서브클래스를 필요로 하지 않는 방식으로 만들어진 기능에서만 쓰이기도 한다.

더 이상 쓰이지 않는 서브클래스와 마주하는 프로그래머는 가치 없는 것을 이해하느라 에너지를 낭비할 것이다. 이런 정도까지 되면 서브클래스를 슈퍼클래스의 필드로 대체해 제거하는 게 최선이다.
## 절차
### (1)
서브클래스의 생성자를 [11.8 생성자를 팩터리 함수로 바꾸기(Replace Constructor with Factory Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-8.md) 한다.
- 생성자를 사용하는 측에서 데이터 필드를 이용해 어떤 서브클래스를 생성할지 결정한다면 그 결정 로직을 슈퍼클래스의 팩터리 메서드에 넣는다.
### (2)
서브클래스의 타입을 검사하는 코드가 있다면 그 검사 코드에 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md)와 [8.1 함수 옮기기(Move Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-1.md)를 차례로 적용하여 슈퍼클래스로 옮긴다. 하나 변경할 때마다 테스트한다.
### (3)
서브클래스의 타입을 나타내는 필드를 슈퍼클래스에 만든다.
### (4)
서브클래스를 참조하는 메서드가 방금 만든 타입 필드를 이용하도록 수정한다.
### (5)
서브클래스를 지운다.
### (6)
테스트한다.

이 리팩터링은 다수의 서브클래스에 한꺼번에 적용할 때가 많다. 그럴 때는 팩터리 함수를 추가하고 타입 검사 코드를 옮기는 캡슐화 단계들([(1)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-7.md#1)과 [(2)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-7.md#2))을 먼저 실행한 다음 개별 서브클래스를 하나씩 슈퍼클래스로 흡수시킨다.
## 예시
다음의 서브클래스들을 살펴보자.
```javascript
class Person {
  constructor(name) {
    this._name = name;
  }
  get name() {
    return this._name;
  }
  get genderCode() {
    return "X";
  }
}

class Male extends Person {
  get genderCode() {
    return "M";
  }
}

class Female extends Person {
  get genderCode() {
    return "F";
  }
}
```
서브클래스가 하는 일이 이게 다라면 굳이 존재할 이유가 없다. 하지만 바로 제거하지 말고 혹시라도 이 클래스들을 사용하는 클라이언트가 있는지 살펴봐야 한다. 지금 예에서는 그런 코드를 찾지 못했다고 치자.
```javascript
// 클라이언트
const numberOfMales = people.filter(p => p instanceof Male).length;
```
### STEP 1
[(1)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-7.md#1) 나는 무언가의 표현 방법을 바꾸려 할 때면 먼저 현재의 표현을 캡슐화하여 이 변화가 클라이언트 코드에 주는 영향을 최소화한다. 서브클래스 만들기를 캡슐화하는 방법은 바로 [11.8 생성자를 팩터리 함수로 바꾸기(Replace Constructor with Factory Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-8.md)다. 지금의 예라면 팩터리를 만드는 방법이 여러 가지다.

가장 직관적인 방법은 팩터리 메서드를 생성자 하나당 하나씩 만드는 것이다.

```diff
class Person {
  constructor(name) {
    this._name = name;
  }
  get name() {
    return this._name;
  }
  get genderCode() {
    return "X";
  }
}

class Male extends Person {
  get genderCode() {
    return "M";
  }
}

class Female extends Person {
  get genderCode() {
    return "F";
  }
}

+function createPerson(name) {
+ return new Person(name);
+}

+function createMale(name) {
+ return new Male(name);
+}

+function createFemale(name) {
+ return new Female(name);
+}

// 클라이언트
const numberOfMales = people.filter(p => p instanceof Male).length;
```

### STEP 2
직관적이긴 해도 이런 류의 객체는 성별(gender) 코드를 사용하는 곳에서 직접 생성될 가능성이 크다.
```javascript
function loadFromInput(data) {
  const result = [];
  data.forEach(aRecord => {
    let p;
    switch (aRecord.gender) {
      case 'M': 
        p = new Male(aRecord.name);
        break;
      case 'F':
        p = new Female(aRecord.name);
        break;
      default:
        p = new Person(aRecord.name);
    }
    result.push(p);
  });
  return result;
}
```
그렇다면 생성할 클래스를 선택하는 로직을 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md)하고, 그 함수를 팩터리 함수로 삼는 편이 낫다.
```diff
class Person {
  constructor(name) {
    this._name = name;
  }
  get name() {
    return this._name;
  }
  get genderCode() {
    return "X";
  }
}

class Male extends Person {
  get genderCode() {
    return "M";
  }
}

class Female extends Person {
  get genderCode() {
    return "F";
  }
}

-function createPerson(name) {
- return new Person(name);
-}
+function createPerson(aRecord) {
+ let p;
+ switch (aRecord.gender) {
+   case 'M': 
+     p = new Male(aRecord.name);
+     break;
+   case 'F':
+     p = new Female(aRecord.name);
+     break;
+   default:
+     p = new Person(aRecord.name);
+ }
+ return p;
+}

function createMale(name) {
  return new Male(name);
}

function createFemale(name) {
  return new Female(name);
}

function loadFromInput(data) {
  const result = [];
  data.forEach(aRecord => {
-   let p;
-   switch (aRecord.gender) {
-     case 'M': 
-       p = new Male(aRecord.name);
-       break;
-     case 'F':
-       p = new Female(aRecord.name);
-       break;
-     default:
-       p = new Person(aRecord.name);
-   }
-   result.push(p);
+   result.push(createPerson(aRecord));
  });
  return result;
}

// 클라이언트
const numberOfMales = people.filter(p => p instanceof Male).length;
```
### STEP 3
이제 두 함수를 깔끔히 청소해보자. `createPerson()`에서 변수 `p`를 [6.4 변수 인라인하기(Inline Variable)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-4.md)한다.
```diff
class Person {
  constructor(name) {
    this._name = name;
  }
  get name() {
    return this._name;
  }
  get genderCode() {
    return "X";
  }
}

class Male extends Person {
  get genderCode() {
    return "M";
  }
}

class Female extends Person {
  get genderCode() {
    return "F";
  }
}

function createPerson(aRecord) {
  let p;
  switch (aRecord.gender) {
    case 'M': 
-     p = new Male(aRecord.name);
-     break;
+     return new Male(aRecord.name);
    case 'F':
-     p = new Female(aRecord.name);
-     break;
+     return new Female(aRecord.name);
    default:
-     p = new Person(aRecord.name);
+     return new Person(aRecord.name);
  }
  return p;
}

function createMale(name) {
  return new Male(name);
}

function createFemale(name) {
  return new Female(name);
}

function loadFromInput(data) {
  const result = [];
  data.forEach(aRecord => {
    result.push(createPerson(aRecord));
  });
  return result;
}

// 클라이언트
const numberOfMales = people.filter(p => p instanceof Male).length;
```
### STEP 4
그런 다음 `loadFromInput()`의 반복문을 [8.8 반복문을 파이프라인으로 바꾸기(Replace Loop with Pipeline)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-8.md) 한다.
```diff
class Person {
  constructor(name) {
    this._name = name;
  }
  get name() {
    return this._name;
  }
  get genderCode() {
    return "X";
  }
}

class Male extends Person {
  get genderCode() {
    return "M";
  }
}

class Female extends Person {
  get genderCode() {
    return "F";
  }
}

function createPerson(aRecord) {
  let p;
  switch (aRecord.gender) {
    case 'M': 
      return new Male(aRecord.name);
    case 'F':
      return new Female(aRecord.name);
    default:
      return new Person(aRecord.name);
  }
  return p;
}

function createMale(name) {
  return new Male(name);
}

function createFemale(name) {
  return new Female(name);
}

function loadFromInput(data) {
  const result = [];
- data.forEach(aRecord => {
-   result.push(createPerson(aRecord));
- });
+ data.map(aRecord => createPerson(aRecord));
  return result;
}

// 클라이언트
const numberOfMales = people.filter(p => p instanceof Male).length;
```
### STEP 5
[(2)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-7.md#2) 이 팩터리가 서브클래스 생성을 캡슐화해주지만 코드의 다른 부분에선 `instanceof`를 사용하는 모습이 눈에 띈다. 결코 향기롭지 않은 냄새다. 이 타입 검사 코드를 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md) 한다.
```diff
class Person {
  constructor(name) {
    this._name = name;
  }
  get name() {
    return this._name;
  }
  get genderCode() {
    return "X";
  }
}

class Male extends Person {
  get genderCode() {
    return "M";
  }
}

class Female extends Person {
  get genderCode() {
    return "F";
  }
}

function createPerson(aRecord) {
  let p;
  switch (aRecord.gender) {
    case 'M': 
      return new Male(aRecord.name);
    case 'F':
      return new Female(aRecord.name);
    default:
      return new Person(aRecord.name);
  }
  return p;
}

function createMale(name) {
  return new Male(name);
}

function createFemale(name) {
  return new Female(name);
}

function loadFromInput(data) {
  const result = [];
  data.map(aRecord => createPerson(aRecord));
  return result;
}

// 클라이언트
-const numberOfMales = people.filter(p => p instanceof Male).length;
+const numberOfMales = people.filter(p => isMale(p)).length;
+function isMale(aPerson) {
+ return aPerson instanceOf Male;
+}
```
### STEP 6
그런 다음 추출한 함수를 `Person`으로 옮긴다([8.1 함수 옮기기(Move Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-1.md)).
```diff
class Person {
  constructor(name) {
    this._name = name;
  }
  get name() {
    return this._name;
  }
  get genderCode() {
    return "X";
  }
+ get isMale() {
+   return this instanceof Male;
+ }
}

class Male extends Person {
  get genderCode() {
    return "M";
  }
}

class Female extends Person {
  get genderCode() {
    return "F";
  }
}

function createPerson(aRecord) {
  let p;
  switch (aRecord.gender) {
    case 'M': 
      return new Male(aRecord.name);
    case 'F':
      return new Female(aRecord.name);
    default:
      return new Person(aRecord.name);
  }
  return p;
}

function createMale(name) {
  return new Male(name);
}

function createFemale(name) {
  return new Female(name);
}

// 클라이언트
-const numberOfMales = people.filter(p => isMale(p)).length;
+const numberOfMales = people.filter(p => p.isMale(p)).length;
-function isMale(aPerson) {
- return aPerson instanceOf Male;
-}
```
이상으로 서브클래스 관련 정보 모두를 슈퍼클래스와 팩터리 함수로 안전하게 담아냈다(서브클래스를 참조하는 슈퍼클래스는 지양해야 하지만 지금 코드는 바로 다음 단계에서 정리될 것이므로 신경쓰지 않기로 하자).
### STEP 7
[(3)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-7.md#3)이제 서브클래스들의 차이(성별)를 나타낼 필드를 추가한다. 성별 정보는 `Person` 클래스의 외부에서 정해 전달하는 방식이나 생성자에서 매개변수로 받아 설정하도록 작성한다.
```diff
class Person {
- constructor(name) {
+ constructor(name, genderCode) {  
    this._name = name;
+   this._genderCode = genderCode || "X";
  }
  get name() {
    return this._name;
  }
  get genderCode() {
-   return "X";
+   return this._genderCode;
  }
  get isMale() {
    return this instanceof Male;
  }
}

class Male extends Person {
  get genderCode() {
    return "M";
  }
}

class Female extends Person {
  get genderCode() {
    return "F";
  }
}

function createPerson(aRecord) {
  let p;
  switch (aRecord.gender) {
    case 'M': 
      return new Male(aRecord.name);
    case 'F':
      return new Female(aRecord.name);
    default:
      return new Person(aRecord.name);
  }
  return p;
}

function createMale(name) {
  return new Male(name);
}

function createFemale(name) {
  return new Female(name);
}

// 클라이언트
const numberOfMales = people.filter(p => p.isMale(p)).length;
```
초기화할 때는 기본값으로 설정한다(사람들 대다수가 남성 혹은 여성에 속하지만 그렇지 않은 이도 있다. 지금 코드는 이를 고려하지 못하고 모델링했다).
### STEP 8
[(4)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-7.md#4) 그런 다음 남성인 경우의 로직을 슈퍼클래스로 옮긴다. 이를 위해 팩터리는 `Person`을 반환하도록 수정하고 `instanceof`를 사용해 검사하던 코드는 성별 코드 필드를 이용하도록 수정한다.
```diff
class Person {
  constructor(name, genderCode) {  
    this._name = name;
    this._genderCode = genderCode || "X";
  }
  get name() {
    return this._name;
  }
  get genderCode() {
    return this._genderCode;
  }
  get isMale() {
-   return this instanceof Male;
+   return 'M' === this._genderCode ;
  }
}

class Male extends Person {
  get genderCode() {
    return "M";
  }
}

class Female extends Person {
  get genderCode() {
    return "F";
  }
}

function createPerson(aRecord) {
  let p;
  switch (aRecord.gender) {
    case 'M': 
-     return new Male(aRecord.name);
+     return new Person(aRecord.name, 'M');
    case 'F':
      return new Female(aRecord.name);
    default:
      return new Person(aRecord.name);
  }
  return p;
}

function createMale(name) {
  return new Male(name);
}

function createFemale(name) {
  return new Female(name);
}

// 클라이언트
const numberOfMales = people.filter(p => p.isMale(p)).length;
```
### STEP 9
[(5)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-7.md#5) 테스트에 성공하면 남성 서브클래스를 제거한다. [(6)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-7.md#6) 또 테스트하여 성공하면 [(4)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-7.md#4)[(5)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-7.md#5) 여성 서브클래스도 같은 방식으로 제거한다.
```diff
class Person {
  constructor(name, genderCode) {  
    this._name = name;
    this._genderCode = genderCode || "X";
  }
  get name() {
    return this._name;
  }
  get genderCode() {
    return this._genderCode;
  }
  get isMale() {
    return 'M' === this._genderCode ;
  }
}

class Male extends Person {
  get genderCode() {
    return "M";
  }
}

class Female extends Person {
  get genderCode() {
    return "F";
  }
}

function createPerson(aRecord) {
  let p;
  switch (aRecord.gender) {
    case 'M': 
      return new Person(aRecord.name, 'M');
    case 'F':
-     return new Female(aRecord.name);
+     return new Female(aRecord.name, 'F');
    default:
      return new Person(aRecord.name);
  }
  return p;
}

function createMale(name) {
  return new Male(name);
}

function createFemale(name) {
  return new Female(name);
}

// 클라이언트
const numberOfMales = people.filter(p => p.isMale(p)).length;
```
### STEP 10
성별 코드를 건네는 곳도 있고 안 그런 곳도 있는 게 거슬린다. 나중에 이 코드를 읽는 사람도 왜 일관되지 않은지 궁금할 것이다. 그러니 코드가 더 복잡해지지 않는다면 일관되게 고치는 게 좋다. 지금 예는 다음처럼 고치면 된다.
```diff
class Person {
  constructor(name, genderCode) {  
    this._name = name;
-   this._genderCode = genderCode || "X";
+   this._genderCode = genderCode;
  }
  get name() {
    return this._name;
  }
  get genderCode() {
    return this._genderCode;
  }
  get isMale() {
    return 'M' === this._genderCode ;
  }
}

class Male extends Person {
  get genderCode() {
    return "M";
  }
}

class Female extends Person {
  get genderCode() {
    return "F";
  }
}

function createPerson(aRecord) {
  let p;
  switch (aRecord.gender) {
    case 'M': 
      return new Person(aRecord.name, 'M');
    case 'F':
      return new Female(aRecord.name, 'F');
    default:
-     return new Person(aRecord.name);
+     return new Person(aRecord.name, 'X');
  }
  return p;
}

function createMale(name) {
  return new Male(name);
}

function createFemale(name) {
  return new Female(name);
}

// 클라이언트
const numberOfMales = people.filter(p => p.isMale(p)).length;
```

- [목차](https://github.com/wonder13662/refactoring-v2/blob/writing)
- [12 상속 다루기](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12)
- [12.6 타입 코드를 서브클래스로 바꾸기(Replace Type Code with Subclasses)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-6.md)
- [12.8 슈퍼클래스 추출하기(Extract Subclasses)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-8.md)
