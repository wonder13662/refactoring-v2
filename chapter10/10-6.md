# 10.6 어서션 추가하기(Introduce Assertion)
``` diff
+assert(this.discountRate >= 0);
if (this.discountRate)
  base = base - (this.discountRate * base);
```
## 배경
특정 조건이 참일 때만 제대로 동작하는 코드 영역이 있을 수 있다. 단순한 예로, 제곱근 계산은 입력이 양수일 때만 정상 동작한다. 객체로 눈을 돌리면 여러 필드 중 최소 하나에는 값이 들어 있어야 동작하는 경우를 생각할 수 있다.

이런 가정이 코드에 항상 명시적으로 기술되어 있지는 않아서 알고리즘을 보고 연역해서 알아내야 할 때도 있다. 주석에라도 적혀 있다면 그나마 형편이 좀 낫다. 더 나은 방법은 어서션(assertion)을 이용해서 코드 자체에 삽입해놓는 것이다.

어서션은 항상 참이라고 가정하는 조건부 문장으로, 어서션이 실패했다는 건 프로그래머가 잘못했다는 뜻이다. 어서션 실패는 시스템의 다른 부분에서는 절대 검사하지 않아야 하며, 어서션이 있고 없고가 프로그램 기능의 정상 동작에 아무런 영향을 주지 않도록 작성되어야 한다. 그래서 어서션을 컴파일타임에 켜고 끌 수 있는 스위치를 제공하는 프로그래밍 언어도 있다.

어서션을 오류 찾기에 활용하라고 추천하는 사람도 왕왕 본다. 몰론 좋은 일이긴 하지만 어서션의 쓰임은 여기서 끝나지 않는다. 어서션은 프로그램이 어떤 상태임을 가정한 채 실행되는지를 다른 개발자에게 알려주는 훌륭한 소통 도구인 것이다. 디버깅하기도 편하고 이런 소통 수단으로서의 가치도 있어서, 나는 추적하던 버그를 잡은 뒤에도 어서션을 코드에 남겨두곤 한다. 한편, 테스트 코드가 있다면 어서션의 디버깅 용도로서의 효용은 줄어든다. 단위 테스트를 꾸준히 추가하여 사각을 좁히면 어서션보다 나을 때가 많다. 하지만 소통 측면에서는 어서션이 여전히 매력적이다.
## 절차

### (1)
참이라고 가정하는 조건이 보이면 그 조건을 명시하는 어서션을 추가한다.
> 어서션은 시스템 운영에 영향을 주면 안 되므로 어서션을 추가한다고 해서 동작이 달라지지는 않는다.

## 예시
할인과 관련한 간단한 예를 준비했다. 다음과 같이 고객은 상품 구입 시 할인율을 적용받는다.
``` javascript
class Customer {
  applyDiscount(aNumber) {
    return (this.discountRate) ? aNumber - (this.discountRate * aNumber) : aNumber;
  }
  set discountRate(aNumber) {
    this._discountRate = aNumber;
  }
}
```
### STEP 1
이 코드에는 할인율이 항상 양수라는 가정이 깔려 있다. 어서션을 이용해 이 가정을 명시해보자. 그런데 3항 표현식에는 어서션을 넣을 장소가 적당치 않으니, 먼저 `if-then` 문장으로 재구성하자.
``` diff
class Customer {
  applyDiscount(aNumber) {
-   return (this.discountRate) ? aNumber - (this.discountRate * aNumber) : aNumber;
+   if (!this.discountRate) return aNumber;
+   else return aNumber - (this.discountRate * aNumber);
  }
  set discountRate(aNumber) {
    this._discountRate = aNumber;
  }
}
```
### STEP 2
[(1)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-6.md#1)이제 간단히 어서션을 추가할 수 있다.
``` diff
class Customer {
  applyDiscount(aNumber) {
    if (!this.discountRate) return aNumber;
-   else return aNumber - (this.discountRate * aNumber);
+   else {
+     assert(this.discountRate >= 0);
+     return aNumber - (this.discountRate * aNumber);
+   }
  }
  set discountRate(aNumber) {
    this._discountRate = aNumber;
  }
}
```
### STEP 3
이번 예에서는 어서션을 세터 메서드에 추가하는 게 나아 보인다. 어서션이 `applyDiscount()`에서 실패한다면 이 문제가 언제 처음 발생했는지를 찾는 문제를 다시 풀어야 하기 때문이다.
``` diff
class Customer {
  applyDiscount(aNumber) {
    if (!this.discountRate) return aNumber;
    else {
      assert(this.discountRate >= 0);
      return aNumber - (this.discountRate * aNumber);
    }
  }
  set discountRate(aNumber) {
+   assert(null === aNumber || aNumber >= 0);
    this._discountRate = aNumber;
  }
}
```
이런 어서션은 오류의 출처를 특정하기 어려울 때 특히 제값을 한다. 이 예에서라면 입력 데이터가 잘못됐거나 코드의 다른 어딘가에서 부호를 반전시켰을 수도 있을 것이다.
> 한편, 어서션을 남발하는 것 역시 위험하다. 나는 참이라고 생각하는 가정 모두에 어서션을 달지는 않는다. '반드시 참이어야 하는' 것만 검사한다. 이런 종류의 조건(가정)은 미세하게 자주 조정되기 때문에 중복된 코드가 있다면 큰 문제가 된다. 그래서 이런 조건들에서의 중복은 반드시 남김없이 제거해야 하며, 이때 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md)가 아주 효과적이다. 나는 프로그래머가 일으킬만한 오류에만 어서션을 사용한다. 데이터를 외부에서 읽어온다면 그 값을 검사하는 작업은 (어서션의 대상인) 가정이 아니라 (예외 처리로 대응해야 하는) 프로그램 로직의 일부로 다뤄야 한다. 외부 데이터 출처를 전적으로 신뢰할 수 있는 상황이 아니라면 말이다. 어서션은 버그 추적을 돕는 최후의 수단이다. 하지만 모순되게도 나는 절대 실패하지 않으리라 믿는 곳에만 사용한다.

- [목차](https://github.com/wonder13662/refactoring-v2/blob/writing/README.md)
- [10 조건부 로직 간소화](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10)
- [10.5 특이 케이스 추가하기(Introduce Special Case)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-5.md)
- [10.7 제어 플래그를 탈출문으로 바꾸기(Replace Control Flag with Break)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-7.md)