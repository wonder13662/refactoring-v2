# 10.4 조건부 로직을 다형성으로 바꾸기(Replace Conditional with Polymorphism)
#### BEFORE
``` javascript
switch (bird.type) {
  case '유럽 제비':
    return "보통이다";
  case '아프라카 제비':
    return (bird.numberOfCoconuts > 2) ? "지쳤다" : "보통이다";
  case '노르웨이 파랑 앵무':
    return (bird.voltage > 100) ? "그을렸다" : "예쁘다";
  default:
    return "알 수 없다";
}
```
#### AFTER
``` javascript
class EuropeanSwallow {
  get plumage() { // plumage는 깃털을 뜻함
    return "보통이다";
  }
  ...
}
class AfricanSwallow {
  get plumage() {
    return (this.numberOfCoconuts > 2) ? "지쳤다" : "보통이다";
  }
  ...
}
class NorwegianBlueParrot {
  get plumage() {
    return (this.voltage > 100) ? "그을렸다" : "예쁘다";
  }
  ...
}
```
## 배경
복잡한 조건부 로직은 프로그래밍에서 해석하기 가장 난해한 대상에 속한다. 그래서 나는 조건부 로직을 직관적으로 구조화할 방법을 항상 고민한다. 종종 더 높은 수준의 개념을 도입해 이 조건들을 분리해낼 수 있다. 조건문 구조를 그대로 둔 채 해결될 때도 있지만, 클래스와 다형성을 이용하면 더 확실하게 분리할 수도 있다.

흔한 예로, 타입을 여러 개 만들고 각 타입이 조건부 로직을 자신만의 방식으로 처리하도록 구성하는 방법이 있다. 책, 음악, 음식은 다르게 처리해야 한다. 왜? 타입이 다르니까! 타입을 기준으로 분기하는 `switch` 문이 포함된 함수가 여러 개 보인다면 분명 이러한 상황이다. 이런 경우 `case`별로 클래스를 하나씩 만들어 공통 `switch` 로직의 중복을 없앨 수 있다. 다형성을 활용하여 어떻게 동작할지를 각 타입이 알아서 처리하도록 하면 된다.

또 다른 예로, 기본 동작을 위한 `case` 문과 그 변형 동작으로 구성된 로직을 떠올릴 수 있다. 기본 동작은 가장 일반적이거나 가장 직관적인 동작일 것이다. 먼저 이 로직을 슈퍼클래스로 넣어서 변형 동작에 신경 쓰지 않고 기본에 집중하게 한다. 그런 다음 변형 동작을 뜻하는 `case`들을 각각의 서브 클래스로 만든다. 이 서브클래스들은 기본 동작과의 차이를 표현하는 코드로 채워질 것이다.

다형성은 객체 지향 프로그래밍의 핵심이다. 하지만 (유용한 기능들이 늘 그렇듯) 남용하기 쉽다. 실제로 모든 조건부 로직을 다형성으로 대체해야 한다고 주장하는 사람도 만난 적이 있다. 나는 그 견해에는 동의하지 않는다. 조건부 로직 대부분은 기본 조건문인 `if/else`와  `switch/case`로 이뤄지기 때문이다. 하지만 앞서 이야기한 방법들로 개선할 수 있는 복잡한 조건부 로직을 발견하면 다형성이 막강한 도구임을 깨닫게 된다.
## 절차
### (1)
다형적 동작을 표현하는 클래스들이 아직 없다면 만들어 준다. 이왕이면 적합한 인스턴스를 알아서 만들어 반환하는 팩터리 함수도 만든다.
### (2)
호출하는 코드에서 팩터리 함수를 사용하게 한다.
### (3)
조건부 로직 함수를 슈퍼클래스로 옮긴다.
- 조건부 로직이 온전한 함수로 분리되어 있지 않다면 먼저 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md) 한다.
### (4)
서브클래스 중 하나를 선택한다. 서브클래스에서 슈퍼클래스의 조건부 로직 메서드를 오버라이드한다. 조건부 문장 중 선택된 서브클래스에 해당하는 조건절을 서브클래스 메서드로 복사한 다음 적절히 수정한다.
### (5)
같은 방식으로 각 조건절을 해당 서브클래스에서 메서드로 구현한다.
### (6)
슈퍼클래스 메서드에는 기본 동작 부분만 남긴다. 혹은 슈퍼클래스가 추상 클래스여야 한다면, 이 메서드를 추상으로 선언하거나 서브클래스에서 처리해야 함을 알리는 에러를 던진다.
## 예시
다양한 새를 키우는 친구가 있는데, 새의 종에 따른 비행 속도와 깃털 상태를 알고 싶어 한다. 그래서 이 정보를 알려주는 작은 프로그램을 짜봤다.
``` javascript
function plumages(birds) {
  return new Map(birds.map(b => [b.name, plumage(b)]));
}

function speeds(birds) {
  return new Map(birds.map(b => [b.name, airSpeedVelocity(b)]));
}

function plumage(bird) { // 깃털 상태
  switch (bird.type) {
    case '유럽 제비':
      return "보통이다";
    case '아프라카 제비':
      return (bird.numberOfCoconuts > 2) ? "지쳤다" : "보통이다";
    case '노르웨이 파랑 앵무':
      return (bird.voltage > 100) ? "그을렸다" : "예쁘다";
    default:
      return "알 수 없다";
  }
}

function airSpeedVelocity(bird) { // 비행 속도
  switch (bird.type) {
    case '유럽 제비':
      return 35;
    case '아프라카 제비':
      return 40 - 2 * bird.numberOfCoconuts;
    case '노르웨이 파랑 앵무':
      return (bird.isNailed) ? 0 : 10 + bird.voltage / 10;
    default:
      return null;
  }
}
```
배경 이야기를 모른 채 이 코드를 보면 무슨 의미인지 도통 이해되지 않을 것이다. '코코넛 수나 전압이 깃털과 무슨 관계가?' '못(Nail) 이야기는 또 뭔가?'의 의문을 풀려면 두 가지 이야기를 알아야 한다.

**<몬티 파이튼과 성배>** - 영국의 전설적인 코미디 그룹 몬티 파이튼(Monty Python)이 제작한 유럽 중세 배경의 영화다. 특수효과가 미비하던 시절이라 라디오에서 말발굽 소리가 필요할 때 빈 코코넛 껍데기 두개를 부딪쳐 흉내 냈다고 하는데, 이 영화는 어차피 코미디 장르이기도 하고 제작비도 줄일 겸 하여 등장인물들이 실제로 코코넛 껍데기를 흔들고 다니며 말을 타는 척한다. 이 점을 작중에서 재미 요소로 활용하여, 성을 찾은 아서왕에게 경비병이 "열대작물인 코코넛이 어디서 났냐"고 묻고, "제비가 물어왔다", "코코넛을 물고 비행 속도를 유지하는 것이 가능하겠냐", "유럽 제비는 안 되겠지만 아프리카 제비라면 되지 않을까" 등의 엉뚱한 이야기가 이어진다. [동영상 클립](https://youtu.be/liIlW-ovx0Y) [대사](https://montycasinos.com/montypython/grailmm1.php.html)

**<죽은 앵무새>** - 몬티 파이튼이 등장한 영국 TV 쇼 <몬티 파이튼의 비행 서커스>에서 가장 유명한 에피소드로, 애완동물 가게에서 병든 앵무를 팔아서 금세 죽어버렸다며 항의하는 고객과 온갖 핑계를 대며 앵무가 살아 있다고 우기는 점원의 이야기다. 예시 코드와 관련한 대사만 추려보면 "앵무가 움직이지 않는다", "쉬는 중이다. 깃털도 예쁘고", "처음에 어떻게 서 있었나 봤더니 못으로 고정되어(nailed) 있더라", "당연하다. 그러지 않으면 난리를 치다가 펑 터져버린다", "4백만 볼트를 걸지 않는 이상 터질 일 없다. 그냥 죽은거다" 등의 이야기를 주고 받는다. [동영상 클립](https://youtu.be/vnciwwsvNcc) [대사](https://montycasinos.com/montypython/scripts/petshop.php.html) [대사(한국어 번역)](https://m.blog.naver.com/PostView.nhn?blogId=dhnam0502&logNo=221614363213&proxyReferer=https:%2F%2Fwww.google.com%2F)
### STEP 1-1
새 종류에 따라 다르게 동작하는 함수가 몇 개 보이니 종류별 클래스를 만들어서 각각에 맞는 동작을 표현하면 좋을 것 같다.
[(3)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-4.md#3) 가장 먼저 `airSpeedVelocity()`와 `plumage()`를 `Bird`라는 클래스로 묶어보자([6.9 여러 함수를 클래스로 묶기(Combine Functions into Class)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-9.md))
``` diff
function plumages(birds) {
  return new Map(birds.map(b => [b.name, plumage(b)]));
}

function speeds(birds) {
  return new Map(birds.map(b => [b.name, airSpeedVelocity(b)]));
}

function plumage(bird) { // 깃털 상태
- switch (bird.type) {
-   case '유럽 제비':
-     return "보통이다";
-   case '아프라카 제비':
-     return (bird.numberOfCoconuts > 2) ? "지쳤다" : "보통이다";
-   case '노르웨이 파랑 앵무':
-     return (bird.voltage > 100) ? "그을렸다" : "예쁘다";
-   default:
-     return "알 수 없다";
- }
+ return new Bird(bird).plumage;
}

function airSpeedVelocity(bird) { // 비행 속도
- switch (bird.type) {
-   case '유럽 제비':
-     return 35;
-   case '아프라카 제비':
-     return 40 - 2 * bird.numberOfCoconuts;
-   case '노르웨이 파랑 앵무':
-     return (bird.isNailed) ? 0 : 10 + bird.voltage / 10;
-   default:
-     return null;
- }
+ return new Bird(bird).airSpeedVelocity;
}

+class Bird {
+ constructor(birdObject) {
+   Object.assign(this, birdObject);
+ }

+ get plumage() {
+   switch (this.type) {
+     case '유럽 제비':
+       return "보통이다";
+     case '아프라카 제비':
+       return (this.numberOfCoconuts > 2) ? "지쳤다" : "보통이다";
+     case '노르웨이 파랑 앵무':
+       return (this.voltage > 100) ? "그을렸다" : "예쁘다";
+     default:
+       return "알 수 없다";
+   }
+ }

+ get airSpeedVelocity() {
+   switch (this.type) {
+     case '유럽 제비':
+       return 35;
+     case '아프라카 제비':
+       return 40 - 2 * this.numberOfCoconuts;
+     case '노르웨이 파랑 앵무':
+       return (this.isNailed) ? 0 : 10 + this.voltage / 10;
+     default:
+       return null;
+   }
+ }
+}
```
### STEP 1-2
[(1)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-4.md#1) 이제 종별 서브 클래스를 만든다. 적합한 서브클래스의 인스턴스를 만들어 줄 팩터리 함수도 잊지 말자. [(2)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-4.md#2) 그러고 나서 객체를 얻을 때 팩터리 함수를 사용하도록 수정한다.
``` diff
function plumages(birds) {
  return new Map(birds.map(b => [b.name, plumage(b)]));
}

function speeds(birds) {
  return new Map(birds.map(b => [b.name, airSpeedVelocity(b)]));
}

function plumage(bird) { // 깃털 상태
- return new Bird(bird).plumage;
+ return createBird(bird).plumage;
}

function airSpeedVelocity(bird) { // 비행 속도
- return new Bird(bird).airSpeedVelocity;
+ return createBird(bird).airSpeedVelocity;
}

+function createBird(bird) {
+ switch (bird.type) {
+   case '유럽 제비':
+     return new EuropeanSwallow(bird);
+   case '아프라카 제비':
+     return new AfricanSwallow(bird);
+   case '노르웨이 파랑 앵무':
+     return new NorwegianBlueParrot(bird);
+   default:
+     return new Bird(bird);
+ }
+}

class Bird {
  constructor(birdObject) {
    Object.assign(this, birdObject);
  }

  get plumage() {
    switch (this.type) {
      case '유럽 제비':
        return "보통이다";
      case '아프라카 제비':
        return (this.numberOfCoconuts > 2) ? "지쳤다" : "보통이다";
      case '노르웨이 파랑 앵무':
        return (this.voltage > 100) ? "그을렸다" : "예쁘다";
      default:
        return "알 수 없다";
    }
  }

  get airSpeedVelocity() {
    switch (this.type) {
      case '유럽 제비':
        return 35;
      case '아프라카 제비':
        return 40 - 2 * this.numberOfCoconuts;
      case '노르웨이 파랑 앵무':
        return (this.isNailed) ? 0 : 10 + this.voltage / 10;
      default:
        return null;
    } 
  }
}

+class EuropeanSwallow extends Bird {
+}

+class AfricanSwallow extends Bird {
+}

+class NorwegianBlueParrot extends Bird {
+}
```
### STEP 1-3
필요한 클래스 구조가 준비되었으니 두 조건부 메서드를 처리할 차례다. `plumage()`부터 시작하자. [(4)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-4.md#4) `switch` 문의 절 하나를 선택해 해당 서브 클래스에서 오버라이드한다. 첫 번째 절의 유럽 제비를 선택해봤다.
``` diff
function plumages(birds) {
  return new Map(birds.map(b => [b.name, plumage(b)]));
}

function speeds(birds) {
  return new Map(birds.map(b => [b.name, airSpeedVelocity(b)]));
}

function plumage(bird) { // 깃털 상태
  return createBird(bird).plumage;
}

function airSpeedVelocity(bird) { // 비행 속도
  return createBird(bird).airSpeedVelocity;
}

function createBird(bird) {
  switch (bird.type) {
    case '유럽 제비':
      return new EuropeanSwallow(bird);
    case '아프라카 제비':
      return new AfricanSwallow(bird);
    case '노르웨이 파랑 앵무':
      return new NorwegianBlueParrot(bird);
    default:
      return new Bird(bird);
  }
}

class Bird {
  constructor(birdObject) {
    Object.assign(this, birdObject);
  }

  get plumage() {
    switch (this.type) {
      case '유럽 제비':
-       return "보통이다";
+       throw "오류 발생";
      case '아프라카 제비':
        return (this.numberOfCoconuts > 2) ? "지쳤다" : "보통이다";
      case '노르웨이 파랑 앵무':
        return (this.voltage > 100) ? "그을렸다" : "예쁘다";
      default:
        return "알 수 없다";
    }
  }

  get airSpeedVelocity() {
    switch (this.type) {
      case '유럽 제비':
        return 35;
      case '아프라카 제비':
        return 40 - 2 * this.numberOfCoconuts;
      case '노르웨이 파랑 앵무':
        return (this.isNailed) ? 0 : 10 + this.voltage / 10;
      default:
        return null;
    } 
  }
}

class EuropeanSwallow extends Bird {
+ get plumage() {
+   return "보통이다";
+ }
}

class AfricanSwallow extends Bird {
}

class NorwegianBlueParrot extends Bird {
}
```
나는 완벽주의자이니 슈퍼클래스의 조건문에 `throw`문을 추가했다.

### STEP 1-4
이 시점에서 컴파일하고 테스트 해보자. [(5)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-4.md#5) 잘 동작한다면 다음 조건절을 처리한다.
``` diff
function plumages(birds) {
  return new Map(birds.map(b => [b.name, plumage(b)]));
}

function speeds(birds) {
  return new Map(birds.map(b => [b.name, airSpeedVelocity(b)]));
}

function plumage(bird) { // 깃털 상태
  return createBird(bird).plumage;
}

function airSpeedVelocity(bird) { // 비행 속도
  return createBird(bird).airSpeedVelocity;
}

function createBird(bird) {
  switch (bird.type) {
    case '유럽 제비':
      return new EuropeanSwallow(bird);
    case '아프라카 제비':
      return new AfricanSwallow(bird);
    case '노르웨이 파랑 앵무':
      return new NorwegianBlueParrot(bird);
    default:
      return new Bird(bird);
  }
}

class Bird {
  constructor(birdObject) {
    Object.assign(this, birdObject);
  }

  get plumage() {
    switch (this.type) {
      case '유럽 제비':
        throw "오류 발생";
      case '아프라카 제비':
-       return (this.numberOfCoconuts > 2) ? "지쳤다" : "보통이다";
+       throw "오류 발생";
      case '노르웨이 파랑 앵무':
        return (this.voltage > 100) ? "그을렸다" : "예쁘다";
      default:
        return "알 수 없다";
    }
  }

  get airSpeedVelocity() {
    switch (this.type) {
      case '유럽 제비':
        return 35;
      case '아프라카 제비':
        return 40 - 2 * this.numberOfCoconuts;
      case '노르웨이 파랑 앵무':
        return (this.isNailed) ? 0 : 10 + this.voltage / 10;
      default:
        return null;
    } 
  }
}

class EuropeanSwallow extends Bird {
  get plumage() {
    return "보통이다";
  }
}

class AfricanSwallow extends Bird {
+ get plumage() {
+   return (this.numberOfCoconuts > 2) ? "지쳤다" : "보통이다";
+ }  
}

class NorwegianBlueParrot extends Bird {
}
```
### STEP 1-5
마지막은 노르웨이 파랑 앵무 차례다.
``` diff
function plumages(birds) {
  return new Map(birds.map(b => [b.name, plumage(b)]));
}

function speeds(birds) {
  return new Map(birds.map(b => [b.name, airSpeedVelocity(b)]));
}

function plumage(bird) { // 깃털 상태
  return createBird(bird).plumage;
}

function airSpeedVelocity(bird) { // 비행 속도
  return createBird(bird).airSpeedVelocity;
}

function createBird(bird) {
  switch (bird.type) {
    case '유럽 제비':
      return new EuropeanSwallow(bird);
    case '아프라카 제비':
      return new AfricanSwallow(bird);
    case '노르웨이 파랑 앵무':
      return new NorwegianBlueParrot(bird);
    default:
      return new Bird(bird);
  }
}

class Bird {
  constructor(birdObject) {
    Object.assign(this, birdObject);
  }

  get plumage() {
    switch (this.type) {
      case '유럽 제비':
        throw "오류 발생";
      case '아프라카 제비':
        throw "오류 발생";
      case '노르웨이 파랑 앵무':
-       return (this.voltage > 100) ? "그을렸다" : "예쁘다";
+       throw "오류 발생";
      default:
        return "알 수 없다";
    }
  }

  get airSpeedVelocity() {
    switch (this.type) {
      case '유럽 제비':
        return 35;
      case '아프라카 제비':
        return 40 - 2 * this.numberOfCoconuts;
      case '노르웨이 파랑 앵무':
        return (this.isNailed) ? 0 : 10 + this.voltage / 10;
      default:
        return null;
    } 
  }
}

class EuropeanSwallow extends Bird {
  get plumage() {
    return "보통이다";
  }
}

class AfricanSwallow extends Bird {
  get plumage() {
    return (this.numberOfCoconuts > 2) ? "지쳤다" : "보통이다";
  }
}

class NorwegianBlueParrot extends Bird {
+ get plumage() {
+   return (this.voltage > 100) ? "그을렸다" : "예쁘다";
+ }  
}
```
### STEP 1-6
[(6)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-4.md#6) 슈퍼클래스의 메서드는 기본 동작용으로 남겨놓는다.
``` diff
function plumages(birds) {
  return new Map(birds.map(b => [b.name, plumage(b)]));
}

function speeds(birds) {
  return new Map(birds.map(b => [b.name, airSpeedVelocity(b)]));
}

function plumage(bird) { // 깃털 상태
  return createBird(bird).plumage;
}

function airSpeedVelocity(bird) { // 비행 속도
  return createBird(bird).airSpeedVelocity;
}

function createBird(bird) {
  switch (bird.type) {
    case '유럽 제비':
      return new EuropeanSwallow(bird);
    case '아프라카 제비':
      return new AfricanSwallow(bird);
    case '노르웨이 파랑 앵무':
      return new NorwegianBlueParrot(bird);
    default:
      return new Bird(bird);
  }
}

class Bird {
  constructor(birdObject) {
    Object.assign(this, birdObject);
  }

  get plumage() {
-   switch (this.type) {
-     case '유럽 제비':
-       throw "오류 발생";
-     case '아프라카 제비':
-       throw "오류 발생";
-     case '노르웨이 파랑 앵무':
-       throw "오류 발생";
-     default:
-       return "알 수 없다";
-   }
+   return "알 수 없다";
  }

  get airSpeedVelocity() {
    switch (this.type) {
      case '유럽 제비':
        return 35;
      case '아프라카 제비':
        return 40 - 2 * this.numberOfCoconuts;
      case '노르웨이 파랑 앵무':
        return (this.isNailed) ? 0 : 10 + this.voltage / 10;
      default:
        return null;
    } 
  }
}

class EuropeanSwallow extends Bird {
  get plumage() {
    return "보통이다";
  }
}

class AfricanSwallow extends Bird {
  get plumage() {
    return (this.numberOfCoconuts > 2) ? "지쳤다" : "보통이다";
  }
}

class NorwegianBlueParrot extends Bird {
  get plumage() {
    return (this.voltage > 100) ? "그을렸다" : "예쁘다";
  }  
}
```
### STEP 1-7
똑같은 과정을 `airSpeedVelocity()`에도 수행한다. 다 끝내면 코드의 모습이 다음처럼 변해 있을 것이다.(참고로 최상위 함수인 `airSpeedVelocity()`와 `plumage()`는 인라인시켰다.)
``` diff
function plumages(birds) {
  return new Map(birds.map(b => [b.name, plumage(b)]));
}

function speeds(birds) {
  return new Map(birds.map(b => [b.name, airSpeedVelocity(b)]));
}

function plumage(bird) { // 깃털 상태
  return createBird(bird).plumage;
}

function airSpeedVelocity(bird) { // 비행 속도
  return createBird(bird).airSpeedVelocity;
}

function createBird(bird) {
  switch (bird.type) {
    case '유럽 제비':
      return new EuropeanSwallow(bird);
    case '아프라카 제비':
      return new AfricanSwallow(bird);
    case '노르웨이 파랑 앵무':
      return new NorwegianBlueParrot(bird);
    default:
      return new Bird(bird);
  }
}

class Bird {
  constructor(birdObject) {
    Object.assign(this, birdObject);
  }

  get plumage() {
    return "알 수 없다";
  }

  get airSpeedVelocity() {
-   switch (this.type) {
-     case '유럽 제비':
-       return 35;
-     case '아프라카 제비':
-       return 40 - 2 * this.numberOfCoconuts;
-     case '노르웨이 파랑 앵무':
-       return (this.isNailed) ? 0 : 10 + this.voltage / 10;
-     default:
-       return null;
-   }
+   return null;
  }
}

class EuropeanSwallow extends Bird {
  get plumage() {
    return "보통이다";
  }
+ get airSpeedVelocity() {
+   return 35;
+ }
}

class AfricanSwallow extends Bird {
  get plumage() {
    return (this.numberOfCoconuts > 2) ? "지쳤다" : "보통이다";
  }
+ get airSpeedVelocity() {
+   return 40 - 2 * this.numberOfCoconuts;
+ }
}

class NorwegianBlueParrot extends Bird {
  get plumage() {
    return (this.voltage > 100) ? "그을렸다" : "예쁘다";
  }
+ get airSpeedVelocity() {
+   return (this.isNailed) ? 0 : 10 + this.voltage / 10;
+ }    
}
```
최종 코드를 보니 슈퍼클래스인 `Bird`는 없어도 괜찮아 보인다. 자바스크립트에는 타입 계층 구조 없이도 다형성을 표현할 수 있다. 객체가 적절한 이름의 메서드만 구현하고 있다면 아무 문제없이 같은 타입으로 취급하기 때문이다(이를 `덕 타이핑(duck typing)`이라 한다). 하지만 이번 예에서는 슈퍼클래스가 클래스들의 관계를 잘 설명해주기 때문에 그대로 두기로 했다.
## 예시: 변형 동작을 다형성으로 표현하기
앞의 예에서는 계층구조를 정확히 새의 종 분류에 맞게 구성했다. 많은 교재에서 서브클래싱과 다형성을 설명하는 전형적인 방식이다. 하지만 상속이 이렇게만 쓰이는 것은 아니다. 아니, 심지어 가장 흔하거나 최선인 방식도 아닐 것이다. 또 다른 쓰임새로, 거의 똑같은 객체지만 다른 부분도 있음을 표현할 때도 상속을 쓴다.

이러한 예로, 신용 평가 기관에서 선박의 항해 투자 등급을 계산하는 코드를 생각해보자. 평가 기관은 위험요소와 잠재 수익에 영향을 주는 다양한 요인을 기초로 항해 등급을 'A'와 'B'로 나눈다. 위험요소로는 항해의 경로의 자연조건과 선장의 항해 이력을 고려한다.
``` javascript
function rating(voyage, history) { // 투자 등급
  const vpf = voyageProfileFactor(voyage, history);
  const vr = voyageRisk(voyage);
  const chr = captainHistoryRisk(voyage, history);
  if (vpf * 3 > (vr + chr * 2)) return "A";
  else return "B";
}

function voyageRisk(voyage) { // 항해 경로 위험요소
  let result = 1;
  if (voyage.length > 4) result += 2;
  if (voyage.length > 8) result += voyage.length - 8;
  if (["중국", "동인도"].include(voyage.zone)) result += 4;
  return Math.max(result, 0);
}

function captainHistoryRisk(voyage, history) { // 선장의 항해 이력 위험요소
  let result = 1;
  if (history.length < 5) result += 4;
  result += history.filter(v => v.profit < 0).length;
  if (voyage.zone === "중국" && hasChina(history)) result -= 2;
  return Math.max(result, 0);
}

function hasChina(history) { // 중국을 경유하는가?
  return history.some(v => "중국" === v.zone);
}

function voyageProfitFactor(voyage, history) { // 수익 요인
  let result = 2;
  if (voyage.zone === "중국") result += 1;
  if (voyage.zone === "동인도") result += 1;
  if (voyage.zone === "중국" && hasChina(history)) {
    result += 3;
    if (history.length > 10) result += 1;
    if (voyage.length > 12) result += 1;
    if (voyage.length > 18) result -= 1;
  } else {
    if (history.length > 8) result += 1;
    if (voyage.length > 14) result -= 1;
  }
  return result;
}

// 호출하는 쪽의 코드
const voyage = { zone: "서인도", length: 10 };
const history = [
  { zone: "동인도", profit: 5 },
  { zone: "서인도", profit: 15 },
  { zone: "중국", profit: -2 },
  { zone: "서아프리카", profit: 7 },
];

const myRating = rating(voyage, history);
```
`voyageRisk()`와 `captainHistoryRisk()` 함수의 점수는 위험요소에, `voyageProfitFactor()` 점수는 잠재 수익에 반영된다. `rating()` 함수는 두 값을 종합하여 요청한 항해의 최종 등급을 계산한다.

여기서 주목할 부분은 두 곳으로, 중국까지 항해해본 선장이 중국을 경유해 항해할 때를 다루는 조건부 로직들이다(`rating()`, `voyageRisk()`, `captainHistoryRisk()`, `hasChina()`, `voyageProfitFactor()`).

이 특수한 상황들을 다루는 로직들을 기본 동작에서 분리하기 위해 상속과 다형성을 이용할 것이다. 다녀온 바 있는 중국으로의 항해 시 추가될 특별한 로직이 더 많았다면 이번 리팩토링의 효과가 더욱 컸겠지만, 지금 상황에서도 이 특수 상황을 검사하는 로직이 반복되어 기본 동작을 이해하는 데 방해가 되고 있다.
### STEP 2-1
함수가 많은데, 세부 계산을 수행하는 함수들을 먼저 처리해보자. 다형성을 적용하려면 클래스를 만들어야 하니 [6.9 여러 함수를 클래스로 묶기(Combine Functions into Class)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-9.md)부터 적용할 것이다. 그러면 코드가 다음처럼 변한다.
``` diff
function rating(voyage, history) { // 투자 등급
- const vpf = voyageProfileFactor(voyage, history);
- const vr = voyageRisk(voyage);
- const chr = captainHistoryRisk(voyage, history);
- if (vpf * 3 > (vr + chr * 2)) return "A";
- else return "B";
+ return new Rating(voyage, history).value;
}

+class Rating { // 함수들을 Rating 클래스로 묶었다.
+ constructor(voyage, history) {
+   this.voyage = voyage;
+   this.history = history;
+ }
+
+ get value() {
+   const vpf = this.voyageProfileFactor;
+   const vr = this.voyageRisk;
+   const chr = this.captainHistoryRisk;
+   if (vpf * 3 > (vr + chr * 2)) return "A";
+   else return "B";
+ }
+
+ get voyageRisk() {
+   let result = 1;
+   if (this.voyage.length > 4) result += 2;
+   if (this.voyage.length > 8) result += this.voyage.length - 8;
+   if (["중국", "동인도"].include(this.voyage.zone)) result += 4;
+   return Math.max(result, 0);
+ }
+
+ get captainHistoryRisk() {
+   let result = 1;
+   if (this.history.length < 5) result += 4;
+   result += this.history.filter(v => v.profit < 0).length;
+   if (this.voyage.zone === "중국" && this.hasChinaHistory) result -= 2;
+   return Math.max(result, 0);
+ }
+
+ get voyageProfitFactor() {
+   let result = 2;
+
+   if (this.voyage.zone === "중국") result += 1;
+   if (this.voyage.zone === "동인도") result += 1;
+   if (this.voyage.zone === "중국" && this.hasChinaHistory) {
+     result += 3;
+     if (this.history.length > 10) result += 1;
+     if (this.voyage.length > 12) result += 1;
+     if (this.voyage.length > 18) result -= 1;
+   } else {
+     if (this.history.length > 8) result += 1;
+     if (this.voyage.length > 14) result -= 1;
+   }
+   return result;
+ }
+
+ hasChinaHistory() {
+   return this.history.some(v => "중국" === v.zone);
+ }
+}

function voyageRisk(voyage) { // 항해 경로 위험요소
  let result = 1;
  if (voyage.length > 4) result += 2;
  if (voyage.length > 8) result += voyage.length - 8;
  if (["중국", "동인도"].include(voyage.zone)) result += 4;
  return Math.max(result, 0);
}

function captainHistoryRisk(voyage, history) { // 선장의 항해 이력 위험요소
  let result = 1;
  if (history.length < 5) result += 4;
  result += history.filter(v => v.profit < 0).length;
  if (voyage.zone === "중국" && hasChina(history)) result -= 2;
  return Math.max(result, 0);
}

function hasChina(history) { // 중국을 경유하는가?
  return history.some(v => "중국" === v.zone);
}

function voyageProfitFactor(voyage, history) { // 수익 요인
  let result = 2;
  if (voyage.zone === "중국") result += 1;
  if (voyage.zone === "동인도") result += 1;
  if (voyage.zone === "중국" && hasChina(history)) {
    result += 3;
    if (history.length > 10) result += 1;
    if (voyage.length > 12) result += 1;
    if (voyage.length > 18) result -= 1;
  } else {
    if (history.length > 8) result += 1;
    if (voyage.length > 14) result -= 1;
  }
  return result;
}

// 호출하는 쪽의 코드
const voyage = { zone: "서인도", length: 10 };
const history = [
  { zone: "동인도", profit: 5 },
  { zone: "서인도", profit: 15 },
  { zone: "중국", profit: -2 },
  { zone: "서아프리카", profit: 7 },
];

const myRating = rating(voyage, history);
```
### STEP 2-2
기본 동작을 담당할 클래스가 만들어 졌다. 다음 차례는 변형 동작을 담을 빈 서브클래스를 만들기다.
``` diff
function rating(voyage, history) { // 투자 등급
  return new Rating(voyage, history).value;
}

class Rating {
  constructor(voyage, history) {
    this.voyage = voyage;
    this.history = history;
  }

  get value() {
    const vpf = this.voyageProfileFactor;
    const vr = this.voyageRisk;
    const chr = this.captainHistoryRisk;
    if (vpf * 3 > (vr + chr * 2)) return "A";
    else return "B";
  }

  get voyageRisk() {
    let result = 1;
    if (this.voyage.length > 4) result += 2;
    if (this.voyage.length > 8) result += this.voyage.length - 8;
    if (["중국", "동인도"].include(this.voyage.zone)) result += 4;
    return Math.max(result, 0);
  }

  get captainHistoryRisk() {
    let result = 1;
    if (this.history.length < 5) result += 4;
    result += this.history.filter(v => v.profit < 0).length;
    if (this.voyage.zone === "중국" && this.hasChinaHistory) result -= 2;
    return Math.max(result, 0);
  }

  get voyageProfitFactor() {
    let result = 2;

    if (this.voyage.zone === "중국") result += 1;
    if (this.voyage.zone === "동인도") result += 1;
    if (this.voyage.zone === "중국" && this.hasChinaHistory) {
      result += 3;
      if (this.history.length > 10) result += 1;
      if (this.voyage.length > 12) result += 1;
      if (this.voyage.length > 18) result -= 1;
    } else {
      if (this.history.length > 8) result += 1;
      if (this.voyage.length > 14) result -= 1;
    }
    return result;
  }

  hasChinaHistory() {
    return this.history.some(v => "중국" === v.zone);
  }
}

+class ExperienceChinaRating extends Rating {
+}

function voyageRisk(voyage) { // 항해 경로 위험요소
  let result = 1;
  if (voyage.length > 4) result += 2;
  if (voyage.length > 8) result += voyage.length - 8;
  if (["중국", "동인도"].include(voyage.zone)) result += 4;
  return Math.max(result, 0);
}

function captainHistoryRisk(voyage, history) { // 선장의 항해 이력 위험요소
  let result = 1;
  if (history.length < 5) result += 4;
  result += history.filter(v => v.profit < 0).length;
  if (voyage.zone === "중국" && hasChina(history)) result -= 2;
  return Math.max(result, 0);
}

function hasChina(history) { // 중국을 경유하는가?
  return history.some(v => "중국" === v.zone);
}

function voyageProfitFactor(voyage, history) { // 수익 요인
  let result = 2;
  if (voyage.zone === "중국") result += 1;
  if (voyage.zone === "동인도") result += 1;
  if (voyage.zone === "중국" && hasChina(history)) {
    result += 3;
    if (history.length > 10) result += 1;
    if (voyage.length > 12) result += 1;
    if (voyage.length > 18) result -= 1;
  } else {
    if (history.length > 8) result += 1;
    if (voyage.length > 14) result -= 1;
  }
  return result;
}

// 호출하는 쪽의 코드
const voyage = { zone: "서인도", length: 10 };
const history = [
  { zone: "동인도", profit: 5 },
  { zone: "서인도", profit: 15 },
  { zone: "중국", profit: -2 },
  { zone: "서아프리카", profit: 7 },
];

const myRating = rating(voyage, history);
```
### STEP 2-3
그런 다음 적절한 변형 클래스를 반환해주 팩터리 함수를 만든다.
``` diff
function rating(voyage, history) { // 투자 등급
  return new Rating(voyage, history).value;
}

class Rating {
  constructor(voyage, history) {
    this.voyage = voyage;
    this.history = history;
  }

  get value() {
    const vpf = this.voyageProfileFactor;
    const vr = this.voyageRisk;
    const chr = this.captainHistoryRisk;
    if (vpf * 3 > (vr + chr * 2)) return "A";
    else return "B";
  }

  get voyageRisk() {
    let result = 1;
    if (this.voyage.length > 4) result += 2;
    if (this.voyage.length > 8) result += this.voyage.length - 8;
    if (["중국", "동인도"].include(this.voyage.zone)) result += 4;
    return Math.max(result, 0);
  }

  get captainHistoryRisk() {
    let result = 1;
    if (this.history.length < 5) result += 4;
    result += this.history.filter(v => v.profit < 0).length;
    if (this.voyage.zone === "중국" && this.hasChinaHistory) result -= 2;
    return Math.max(result, 0);
  }

  get voyageProfitFactor() {
    let result = 2;

    if (this.voyage.zone === "중국") result += 1;
    if (this.voyage.zone === "동인도") result += 1;
    if (this.voyage.zone === "중국" && this.hasChinaHistory) {
      result += 3;
      if (this.history.length > 10) result += 1;
      if (this.voyage.length > 12) result += 1;
      if (this.voyage.length > 18) result -= 1;
    } else {
      if (this.history.length > 8) result += 1;
      if (this.voyage.length > 14) result -= 1;
    }
    return result;
  }

  hasChinaHistory() {
    return this.history.some(v => "중국" === v.zone);
  }
}

class ExperienceChinaRating extends Rating {
}

+function createRating(voyage, history) {
+ if (voyage.zone === "중국" && history.some(v => "중국" === v.zone))
+   return new ExperienceChinaRating(voyage, history);
+ else return new Rating(voyage, history);
+}

function voyageRisk(voyage) { // 항해 경로 위험요소
  let result = 1;
  if (voyage.length > 4) result += 2;
  if (voyage.length > 8) result += voyage.length - 8;
  if (["중국", "동인도"].include(voyage.zone)) result += 4;
  return Math.max(result, 0);
}

function captainHistoryRisk(voyage, history) { // 선장의 항해 이력 위험요소
  let result = 1;
  if (history.length < 5) result += 4;
  result += history.filter(v => v.profit < 0).length;
  if (voyage.zone === "중국" && hasChina(history)) result -= 2;
  return Math.max(result, 0);
}

function hasChina(history) { // 중국을 경유하는가?
  return history.some(v => "중국" === v.zone);
}

function voyageProfitFactor(voyage, history) { // 수익 요인
  let result = 2;
  if (voyage.zone === "중국") result += 1;
  if (voyage.zone === "동인도") result += 1;
  if (voyage.zone === "중국" && hasChina(history)) {
    result += 3;
    if (history.length > 10) result += 1;
    if (voyage.length > 12) result += 1;
    if (voyage.length > 18) result -= 1;
  } else {
    if (history.length > 8) result += 1;
    if (voyage.length > 14) result -= 1;
  }
  return result;
}

// 호출하는 쪽의 코드
const voyage = { zone: "서인도", length: 10 };
const history = [
  { zone: "동인도", profit: 5 },
  { zone: "서인도", profit: 15 },
  { zone: "중국", profit: -2 },
  { zone: "서아프리카", profit: 7 },
];

const myRating = rating(voyage, history);
```
### STEP 2-4
이제 생성자를 호출하는 코드를 모두 찾아서 이 팩터리 함수를 대신 사용하도록 수정한다. 지금 예에서는 `rating()` 함수 하나 뿐이다.
``` diff
function rating(voyage, history) { // 투자 등급
- return new Rating(voyage, history).value;
+ return createRating(voyage, history).value;
}

class Rating {
  constructor(voyage, history) {
    this.voyage = voyage;
    this.history = history;
  }

  get value() {
    const vpf = this.voyageProfileFactor;
    const vr = this.voyageRisk;
    const chr = this.captainHistoryRisk;
    if (vpf * 3 > (vr + chr * 2)) return "A";
    else return "B";
  }

  get voyageRisk() {
    let result = 1;
    if (this.voyage.length > 4) result += 2;
    if (this.voyage.length > 8) result += this.voyage.length - 8;
    if (["중국", "동인도"].include(this.voyage.zone)) result += 4;
    return Math.max(result, 0);
  }

  get captainHistoryRisk() {
    let result = 1;
    if (this.history.length < 5) result += 4;
    result += this.history.filter(v => v.profit < 0).length;
    if (this.voyage.zone === "중국" && this.hasChinaHistory) result -= 2;
    return Math.max(result, 0);
  }

  get voyageProfitFactor() {
    let result = 2;

    if (this.voyage.zone === "중국") result += 1;
    if (this.voyage.zone === "동인도") result += 1;
    if (this.voyage.zone === "중국" && this.hasChinaHistory) {
      result += 3;
      if (this.history.length > 10) result += 1;
      if (this.voyage.length > 12) result += 1;
      if (this.voyage.length > 18) result -= 1;
    } else {
      if (this.history.length > 8) result += 1;
      if (this.voyage.length > 14) result -= 1;
    }
    return result;
  }

  hasChinaHistory() {
    return this.history.some(v => "중국" === v.zone);
  }
}

class ExperienceChinaRating extends Rating {
}

function createRating(voyage, history) {
  if (voyage.zone === "중국" && history.some(v => "중국" === v.zone))
    return new ExperienceChinaRating(voyage, history);
  else return new Rating(voyage, history);
}

function voyageRisk(voyage) { // 항해 경로 위험요소
  let result = 1;
  if (voyage.length > 4) result += 2;
  if (voyage.length > 8) result += voyage.length - 8;
  if (["중국", "동인도"].include(voyage.zone)) result += 4;
  return Math.max(result, 0);
}

function captainHistoryRisk(voyage, history) { // 선장의 항해 이력 위험요소
  let result = 1;
  if (history.length < 5) result += 4;
  result += history.filter(v => v.profit < 0).length;
  if (voyage.zone === "중국" && hasChina(history)) result -= 2;
  return Math.max(result, 0);
}

function hasChina(history) { // 중국을 경유하는가?
  return history.some(v => "중국" === v.zone);
}

function voyageProfitFactor(voyage, history) { // 수익 요인
  let result = 2;
  if (voyage.zone === "중국") result += 1;
  if (voyage.zone === "동인도") result += 1;
  if (voyage.zone === "중국" && hasChina(history)) {
    result += 3;
    if (history.length > 10) result += 1;
    if (voyage.length > 12) result += 1;
    if (voyage.length > 18) result -= 1;
  } else {
    if (history.length > 8) result += 1;
    if (voyage.length > 14) result -= 1;
  }
  return result;
}

// 호출하는 쪽의 코드
const voyage = { zone: "서인도", length: 10 };
const history = [
  { zone: "동인도", profit: 5 },
  { zone: "서인도", profit: 15 },
  { zone: "중국", profit: -2 },
  { zone: "서아프리카", profit: 7 },
];

const myRating = rating(voyage, history);
```
### STEP 2-5
서브클래스로 옮길 동작은 두 가지다. `captainHistoryRisk()` 안의 로직부터 시작하자. 서브클래스에서 이 메서드를 오버라이드한다.
``` diff
function rating(voyage, history) { // 투자 등급
  return createRating(voyage, history).value;
}

class Rating {
  constructor(voyage, history) {
    this.voyage = voyage;
    this.history = history;
  }

  get value() {
    const vpf = this.voyageProfileFactor;
    const vr = this.voyageRisk;
    const chr = this.captainHistoryRisk;
    if (vpf * 3 > (vr + chr * 2)) return "A";
    else return "B";
  }

  get voyageRisk() {
    let result = 1;
    if (this.voyage.length > 4) result += 2;
    if (this.voyage.length > 8) result += this.voyage.length - 8;
    if (["중국", "동인도"].include(this.voyage.zone)) result += 4;
    return Math.max(result, 0);
  }

  get captainHistoryRisk() {
    let result = 1;
    if (this.history.length < 5) result += 4;
    result += this.history.filter(v => v.profit < 0).length;
-   if (this.voyage.zone === "중국" && this.hasChinaHistory) result -= 2;
    return Math.max(result, 0);
  }

  get voyageProfitFactor() {
    let result = 2;

    if (this.voyage.zone === "중국") result += 1;
    if (this.voyage.zone === "동인도") result += 1;
    if (this.voyage.zone === "중국" && this.hasChinaHistory) {
      result += 3;
      if (this.history.length > 10) result += 1;
      if (this.voyage.length > 12) result += 1;
      if (this.voyage.length > 18) result -= 1;
    } else {
      if (this.history.length > 8) result += 1;
      if (this.voyage.length > 14) result -= 1;
    }
    return result;
  }

  hasChinaHistory() {
    return this.history.some(v => "중국" === v.zone);
  }
}

class ExperienceChinaRating extends Rating {
+ get captainHistoryRisk() {
+   const result = super.captainHistoryRisk - 2;
+   return Math.max(result, 0);
+ }
}

function createRating(voyage, history) {
  if (voyage.zone === "중국" && history.some(v => "중국" === v.zone))
    return new ExperienceChinaRating(voyage, history);
  else return new Rating(voyage, history);
}

function voyageRisk(voyage) { // 항해 경로 위험요소
  let result = 1;
  if (voyage.length > 4) result += 2;
  if (voyage.length > 8) result += voyage.length - 8;
  if (["중국", "동인도"].include(voyage.zone)) result += 4;
  return Math.max(result, 0);
}

function captainHistoryRisk(voyage, history) { // 선장의 항해 이력 위험요소
  let result = 1;
  if (history.length < 5) result += 4;
  result += history.filter(v => v.profit < 0).length;
  if (voyage.zone === "중국" && hasChina(history)) result -= 2;
  return Math.max(result, 0);
}

function hasChina(history) { // 중국을 경유하는가?
  return history.some(v => "중국" === v.zone);
}

function voyageProfitFactor(voyage, history) { // 수익 요인
  let result = 2;
  if (voyage.zone === "중국") result += 1;
  if (voyage.zone === "동인도") result += 1;
  if (voyage.zone === "중국" && hasChina(history)) {
    result += 3;
    if (history.length > 10) result += 1;
    if (voyage.length > 12) result += 1;
    if (voyage.length > 18) result -= 1;
  } else {
    if (history.length > 8) result += 1;
    if (voyage.length > 14) result -= 1;
  }
  return result;
}

// 호출하는 쪽의 코드
const voyage = { zone: "서인도", length: 10 };
const history = [
  { zone: "동인도", profit: 5 },
  { zone: "서인도", profit: 15 },
  { zone: "중국", profit: -2 },
  { zone: "서아프리카", profit: 7 },
];

const myRating = rating(voyage, history);
```
### STEP 2-6
`voyageProfitFactor()`에서 변형 동작을 분리하는 작업은 살짝 더 복잡하다. 이 함수에는 다른 경로가 존재하므로, 단순히 변형 동작을 제거하고 슈퍼클래스의 메서드를 호출하는 방식은 적용할 수 없다. 또한 슈퍼 클래스의 메서드를 통째로 서브클래스로 복사하고 싶지도 않다. 그래서 내 해답은 먼저 해당 조건부 블록 전체를 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md) 하는 것이다.
``` diff
function rating(voyage, history) { // 투자 등급
  return createRating(voyage, history).value;
}

class Rating {
  constructor(voyage, history) {
    this.voyage = voyage;
    this.history = history;
  }

  get value() {
    const vpf = this.voyageProfileFactor;
    const vr = this.voyageRisk;
    const chr = this.captainHistoryRisk;
    if (vpf * 3 > (vr + chr * 2)) return "A";
    else return "B";
  }

  get voyageRisk() {
    let result = 1;
    if (this.voyage.length > 4) result += 2;
    if (this.voyage.length > 8) result += this.voyage.length - 8;
    if (["중국", "동인도"].include(this.voyage.zone)) result += 4;
    return Math.max(result, 0);
  }

  get captainHistoryRisk() {
    let result = 1;
    if (this.history.length < 5) result += 4;
    result += this.history.filter(v => v.profit < 0).length;
    return Math.max(result, 0);
  }

  get voyageProfitFactor() {
    let result = 2;

    if (this.voyage.zone === "중국") result += 1;
    if (this.voyage.zone === "동인도") result += 1;
-   if (this.voyage.zone === "중국" && this.hasChinaHistory) {
-     result += 3;
-     if (this.history.length > 10) result += 1;
-     if (this.voyage.length > 12) result += 1;
-     if (this.voyage.length > 18) result -= 1;
-   } else {
-     if (this.history.length > 8) result += 1;
-     if (this.voyage.length > 14) result -= 1;
-   }
+   result += this.voyageAndHistoryLengthFactor;
    return result;
  }

+ get voyageAndHistoryLengthFactor() {
+   let result = 0;
+   if (this.voyage.zone === "중국" && this.hasChinaHistory) {
+     result += 3;
+     if (this.history.length > 10) result += 1;
+     if (this.voyage.length > 12) result += 1;
+     if (this.voyage.length > 18) result -= 1;
+   } else {
+     if (this.history.length > 8) result += 1;
+     if (this.voyage.length > 14) result -= 1;
+   }
+   return result;
+ }

  hasChinaHistory() {
    return this.history.some(v => "중국" === v.zone);
  }
}

class ExperienceChinaRating extends Rating {
  get captainHistoryRisk() {
    const result = super.captainHistoryRisk - 2;
    return Math.max(result, 0);
  }
}

function createRating(voyage, history) {
  if (voyage.zone === "중국" && history.some(v => "중국" === v.zone))
    return new ExperienceChinaRating(voyage, history);
  else return new Rating(voyage, history);
}

function voyageRisk(voyage) { // 항해 경로 위험요소
  let result = 1;
  if (voyage.length > 4) result += 2;
  if (voyage.length > 8) result += voyage.length - 8;
  if (["중국", "동인도"].include(voyage.zone)) result += 4;
  return Math.max(result, 0);
}

function captainHistoryRisk(voyage, history) { // 선장의 항해 이력 위험요소
  let result = 1;
  if (history.length < 5) result += 4;
  result += history.filter(v => v.profit < 0).length;
  if (voyage.zone === "중국" && hasChina(history)) result -= 2;
  return Math.max(result, 0);
}

function hasChina(history) { // 중국을 경유하는가?
  return history.some(v => "중국" === v.zone);
}

function voyageProfitFactor(voyage, history) { // 수익 요인
  let result = 2;
  if (voyage.zone === "중국") result += 1;
  if (voyage.zone === "동인도") result += 1;
  if (voyage.zone === "중국" && hasChina(history)) {
    result += 3;
    if (history.length > 10) result += 1;
    if (voyage.length > 12) result += 1;
    if (voyage.length > 18) result -= 1;
  } else {
    if (history.length > 8) result += 1;
    if (voyage.length > 14) result -= 1;
  }
  return result;
}

// 호출하는 쪽의 코드
const voyage = { zone: "서인도", length: 10 };
const history = [
  { zone: "동인도", profit: 5 },
  { zone: "서인도", profit: 15 },
  { zone: "중국", profit: -2 },
  { zone: "서아프리카", profit: 7 },
];

const myRating = rating(voyage, history);
```
### STEP 2-7
함수 이름에 "그리고"를 뜻하는 "And"가 들어 있어서 악취가 꽤 나지만, 서브클래스 구성을 마무리하는 잠깐 동안만 견뎌보기로 하자.
``` diff
function rating(voyage, history) { // 투자 등급
  return createRating(voyage, history).value;
}

class Rating {
  constructor(voyage, history) {
    this.voyage = voyage;
    this.history = history;
  }

  get value() {
    const vpf = this.voyageProfileFactor;
    const vr = this.voyageRisk;
    const chr = this.captainHistoryRisk;
    if (vpf * 3 > (vr + chr * 2)) return "A";
    else return "B";
  }

  get voyageRisk() {
    let result = 1;
    if (this.voyage.length > 4) result += 2;
    if (this.voyage.length > 8) result += this.voyage.length - 8;
    if (["중국", "동인도"].include(this.voyage.zone)) result += 4;
    return Math.max(result, 0);
  }

  get captainHistoryRisk() {
    let result = 1;
    if (this.history.length < 5) result += 4;
    result += this.history.filter(v => v.profit < 0).length;
    return Math.max(result, 0);
  }

  get voyageProfitFactor() {
    let result = 2;

    if (this.voyage.zone === "중국") result += 1;
    if (this.voyage.zone === "동인도") result += 1;
    result += this.voyageAndHistoryLengthFactor;
    return result;
  }

  get voyageAndHistoryLengthFactor() {
    let result = 0;
-   if (this.voyage.zone === "중국" && this.hasChinaHistory) {
-     result += 3;
-     if (this.history.length > 10) result += 1;
-     if (this.voyage.length > 12) result += 1;
-     if (this.voyage.length > 18) result -= 1;
-   } else {
      if (this.history.length > 8) result += 1;
      if (this.voyage.length > 14) result -= 1;
-   }
    return result;
  }

  hasChinaHistory() {
    return this.history.some(v => "중국" === v.zone);
  }
}

class ExperienceChinaRating extends Rating {
  get captainHistoryRisk() {
    const result = super.captainHistoryRisk - 2;
    return Math.max(result, 0);
  }

+ get voyageAndHistoryLengthFactor() {
+   let result = 0;
+   result += 3;
+   if (this.history.length > 10) result += 1;
+   if (this.voyage.length > 12) result += 1;
+   if (this.voyage.length > 18) result -= 1;
+   return result;
+ }
}

function createRating(voyage, history) {
  if (voyage.zone === "중국" && history.some(v => "중국" === v.zone))
    return new ExperienceChinaRating(voyage, history);
  else return new Rating(voyage, history);
}

function voyageRisk(voyage) { // 항해 경로 위험요소
  let result = 1;
  if (voyage.length > 4) result += 2;
  if (voyage.length > 8) result += voyage.length - 8;
  if (["중국", "동인도"].include(voyage.zone)) result += 4;
  return Math.max(result, 0);
}

function captainHistoryRisk(voyage, history) { // 선장의 항해 이력 위험요소
  let result = 1;
  if (history.length < 5) result += 4;
  result += history.filter(v => v.profit < 0).length;
  if (voyage.zone === "중국" && hasChina(history)) result -= 2;
  return Math.max(result, 0);
}

function hasChina(history) { // 중국을 경유하는가?
  return history.some(v => "중국" === v.zone);
}

function voyageProfitFactor(voyage, history) { // 수익 요인
  let result = 2;
  if (voyage.zone === "중국") result += 1;
  if (voyage.zone === "동인도") result += 1;
  if (voyage.zone === "중국" && hasChina(history)) {
    result += 3;
    if (history.length > 10) result += 1;
    if (voyage.length > 12) result += 1;
    if (voyage.length > 18) result -= 1;
  } else {
    if (history.length > 8) result += 1;
    if (voyage.length > 14) result -= 1;
  }
  return result;
}

// 호출하는 쪽의 코드
const voyage = { zone: "서인도", length: 10 };
const history = [
  { zone: "동인도", profit: 5 },
  { zone: "서인도", profit: 15 },
  { zone: "중국", profit: -2 },
  { zone: "서아프리카", profit: 7 },
];

const myRating = rating(voyage, history);
```
## 예시: 변형 동작을 다형성으로 표현하기 - 더 가다듬기
변형 동작을 서브클래스로 뽑아냈으니 공식적으로는 여기까지가 리팩터링의 끝이다. 슈퍼클래스의 로직은 간소화되어 이해하기 다루기 더 쉬워졌다. 변형 동작은 슈퍼클래스와의 차이를 표현해야 하는 서브클래스에서만 신경 쓰면 된다. 

하지만 악취를 풍기는 메서드를 새로 만들었으니 처리 방법을 대략으로나마 설명해줘야 할 것 같다. 이번 예와 같이 '기본 동작-변형 동작' 상속에서는 서브클래스에서 순전히 오버라이드만을 위해 메서드를 추가하는 일이 흔하다. 하지만 이런 조잡한 메서드는 로직을 부각하기보다는 일의 진행 과정을 모호하게 만들곤 한다.
### STEP 3-1
메서드 이름의 "And"는 이 메서드가 두 가지 독립된 일을 수행한다고 소리친다. 그러니 둘을 분리하는 것이 현명할 것이다. 이력 길이를 수정하는 부분을 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md) 하면 해결되는데, 이때 슈퍼클래스와 서브클래스 모두에 적용해야 한다. 슈퍼클래스부터 보자.
``` diff
function rating(voyage, history) { // 투자 등급
  return createRating(voyage, history).value;
}

class Rating {
  constructor(voyage, history) {
    this.voyage = voyage;
    this.history = history;
  }

  get value() {
    const vpf = this.voyageProfileFactor;
    const vr = this.voyageRisk;
    const chr = this.captainHistoryRisk;
    if (vpf * 3 > (vr + chr * 2)) return "A";
    else return "B";
  }

  get voyageRisk() {
    let result = 1;
    if (this.voyage.length > 4) result += 2;
    if (this.voyage.length > 8) result += this.voyage.length - 8;
    if (["중국", "동인도"].include(this.voyage.zone)) result += 4;
    return Math.max(result, 0);
  }

  get captainHistoryRisk() {
    let result = 1;
    if (this.history.length < 5) result += 4;
    result += this.history.filter(v => v.profit < 0).length;
    return Math.max(result, 0);
  }

  get voyageProfitFactor() {
    let result = 2;

    if (this.voyage.zone === "중국") result += 1;
    if (this.voyage.zone === "동인도") result += 1;
    result += this.voyageAndHistoryLengthFactor;
    return result;
  }

  get voyageAndHistoryLengthFactor() {
    let result = 0;
-   if (this.history.length > 8) result += 1;
+   result += this.historyLengthFactor;
    if (this.voyage.length > 14) result -= 1;
    return result;
  }

+ get historyLengthFactor() {
+   return (this.history.length > 8) ? 1 : 0;
+ }

  hasChinaHistory() {
    return this.history.some(v => "중국" === v.zone);
  }
}

class ExperienceChinaRating extends Rating {
  get captainHistoryRisk() {
    const result = super.captainHistoryRisk - 2;
    return Math.max(result, 0);
  }

  get voyageAndHistoryLengthFactor() {
    let result = 0;
    result += 3;
    if (this.history.length > 10) result += 1;
    if (this.voyage.length > 12) result += 1;
    if (this.voyage.length > 18) result -= 1;
    return result;
  }
}

// 호출하는 쪽의 코드
const voyage = { zone: "서인도", length: 10 };
const history = [
  { zone: "동인도", profit: 5 },
  { zone: "서인도", profit: 15 },
  { zone: "중국", profit: -2 },
  { zone: "서아프리카", profit: 7 },
];

const myRating = rating(voyage, history);
```
### STEP 3-2
같은 작업을 서브클래스에도 해준다.
``` diff
function rating(voyage, history) { // 투자 등급
  return createRating(voyage, history).value;
}

class Rating {
  constructor(voyage, history) {
    this.voyage = voyage;
    this.history = history;
  }

  get value() {
    const vpf = this.voyageProfileFactor;
    const vr = this.voyageRisk;
    const chr = this.captainHistoryRisk;
    if (vpf * 3 > (vr + chr * 2)) return "A";
    else return "B";
  }

  get voyageRisk() {
    let result = 1;
    if (this.voyage.length > 4) result += 2;
    if (this.voyage.length > 8) result += this.voyage.length - 8;
    if (["중국", "동인도"].include(this.voyage.zone)) result += 4;
    return Math.max(result, 0);
  }

  get captainHistoryRisk() {
    let result = 1;
    if (this.history.length < 5) result += 4;
    result += this.history.filter(v => v.profit < 0).length;
    return Math.max(result, 0);
  }

  get voyageProfitFactor() {
    let result = 2;

    if (this.voyage.zone === "중국") result += 1;
    if (this.voyage.zone === "동인도") result += 1;
    result += this.voyageAndHistoryLengthFactor;
    return result;
  }

  get voyageAndHistoryLengthFactor() {
    let result = 0;
    result += this.historyLengthFactor;
    if (this.voyage.length > 14) result -= 1;
    return result;
  }

  get historyLengthFactor() {
    return (this.history.length > 8) ? 1 : 0;
  }

  hasChinaHistory() {
    return this.history.some(v => "중국" === v.zone);
  }
}

class ExperienceChinaRating extends Rating {
  get captainHistoryRisk() {
    const result = super.captainHistoryRisk - 2;
    return Math.max(result, 0);
  }

  get voyageAndHistoryLengthFactor() {
    let result = 0;
    result += 3;
-   if (this.history.length > 8) result += 1;
+   result += this.historyLengthFactor;
    if (this.voyage.length > 12) result += 1;
    if (this.voyage.length > 18) result -= 1;
    return result;
  }

+ get historyLengthFactor() {
+   return (this.history.length > 8) ? 1 : 0;
+ }
}

// 호출하는 쪽의 코드
const voyage = { zone: "서인도", length: 10 };
const history = [
  { zone: "동인도", profit: 5 },
  { zone: "서인도", profit: 15 },
  { zone: "중국", profit: -2 },
  { zone: "서아프리카", profit: 7 },
];

const myRating = rating(voyage, history);
```
### STEP 3-3
이제 슈퍼클래스에는 [8.4 문장을 호출한 곳으로 옮기기(Move Statements to Caller)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-4.md)를 적용할 수 있다.
``` diff
function rating(voyage, history) { // 투자 등급
  return createRating(voyage, history).value;
}

class Rating {
  constructor(voyage, history) {
    this.voyage = voyage;
    this.history = history;
  }

  get value() {
    const vpf = this.voyageProfileFactor;
    const vr = this.voyageRisk;
    const chr = this.captainHistoryRisk;
    if (vpf * 3 > (vr + chr * 2)) return "A";
    else return "B";
  }

  get voyageRisk() {
    let result = 1;
    if (this.voyage.length > 4) result += 2;
    if (this.voyage.length > 8) result += this.voyage.length - 8;
    if (["중국", "동인도"].include(this.voyage.zone)) result += 4;
    return Math.max(result, 0);
  }

  get captainHistoryRisk() {
    let result = 1;
    if (this.history.length < 5) result += 4;
    result += this.history.filter(v => v.profit < 0).length;
    return Math.max(result, 0);
  }

  get voyageProfitFactor() {
    let result = 2;

    if (this.voyage.zone === "중국") result += 1;
    if (this.voyage.zone === "동인도") result += 1;
+   result += this.historyLengthFactor;
    result += this.voyageAndHistoryLengthFactor;
    return result;
  }

  get voyageAndHistoryLengthFactor() {
    let result = 0;
-   result += this.historyLengthFactor;
    if (this.voyage.length > 14) result -= 1;
    return result;
  }

  get historyLengthFactor() {
    return (this.history.length > 8) ? 1 : 0;
  }

  hasChinaHistory() {
    return this.history.some(v => "중국" === v.zone);
  }
}

class ExperienceChinaRating extends Rating {
  get captainHistoryRisk() {
    const result = super.captainHistoryRisk - 2;
    return Math.max(result, 0);
  }

  get voyageAndHistoryLengthFactor() {
    let result = 0;
    result += 3;
-   result += this.historyLengthFactor;
    if (this.voyage.length > 12) result += 1;
    if (this.voyage.length > 18) result -= 1;
    return result;
  }

  get historyLengthFactor() {
    return (this.history.length > 10) ? 1 : 0;
  }
}

// 호출하는 쪽의 코드
const voyage = { zone: "서인도", length: 10 };
const history = [
  { zone: "동인도", profit: 5 },
  { zone: "서인도", profit: 15 },
  { zone: "중국", profit: -2 },
  { zone: "서아프리카", profit: 7 },
];

const myRating = rating(voyage, history);
```
### STEP 3-4
이어서 함수 이름을 바꿔준다([6.5 함수 선언 바꾸기(Change Function Declaration)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-5.md)). 그리고 3항 연산자를 써서 `voyageLengthFactor()`를 간소화한다.
``` diff
function rating(voyage, history) { // 투자 등급
  return createRating(voyage, history).value;
}

class Rating {
  constructor(voyage, history) {
    this.voyage = voyage;
    this.history = history;
  }

  get value() {
    const vpf = this.voyageProfileFactor;
    const vr = this.voyageRisk;
    const chr = this.captainHistoryRisk;
    if (vpf * 3 > (vr + chr * 2)) return "A";
    else return "B";
  }

  get voyageRisk() {
    let result = 1;
    if (this.voyage.length > 4) result += 2;
    if (this.voyage.length > 8) result += this.voyage.length - 8;
    if (["중국", "동인도"].include(this.voyage.zone)) result += 4;
    return Math.max(result, 0);
  }

  get captainHistoryRisk() {
    let result = 1;
    if (this.history.length < 5) result += 4;
    result += this.history.filter(v => v.profit < 0).length;
    return Math.max(result, 0);
  }

  get voyageProfitFactor() {
    let result = 2;

    if (this.voyage.zone === "중국") result += 1;
    if (this.voyage.zone === "동인도") result += 1;
    result += this.historyLengthFactor;
-   result += this.voyageAndHistoryLengthFactor;
+   result += this.voyageLengthFactor;
    return result;
  }

- get voyageAndHistoryLengthFactor() {
+ get voyageLengthFactor() {      
-   let result = 0;
-   if (this.voyage.length > 14) result -= 1;
-   return result;
+   return (this.voyage.length > 14) ? -1 : 0;
  }

  get historyLengthFactor() {
    return (this.history.length > 8) ? 1 : 0;
  }

  hasChinaHistory() {
    return this.history.some(v => "중국" === v.zone);
  }
}

class ExperienceChinaRating extends Rating {
  get captainHistoryRisk() {
    const result = super.captainHistoryRisk - 2;
    return Math.max(result, 0);
  }

- get voyageAndHistoryLengthFactor() {
+ get voyageLengthFactor() {      
    let result = 0;
    result += 3;
    if (this.voyage.length > 12) result += 1;
    if (this.voyage.length > 18) result -= 1;
    return result;
  }

  get historyLengthFactor() {
    return (this.history.length > 10) ? 1 : 0;
  }
}

// 호출하는 쪽의 코드
const voyage = { zone: "서인도", length: 10 };
const history = [
  { zone: "동인도", profit: 5 },
  { zone: "서인도", profit: 15 },
  { zone: "중국", profit: -2 },
  { zone: "서아프리카", profit: 7 },
];

const myRating = rating(voyage, history);
```
### STEP 3-5
마지막 하나가 남았다. 항해 거리 요인을 계산할 때 3점을 더하고 있는데, 이 로직은 전체 결과를 계산하는 쪽으로 옮기는 게 좋아 보인다.
``` diff
function rating(voyage, history) { // 투자 등급
  return createRating(voyage, history).value;
}

class Rating {
  constructor(voyage, history) {
    this.voyage = voyage;
    this.history = history;
  }

  get value() {
    const vpf = this.voyageProfileFactor;
    const vr = this.voyageRisk;
    const chr = this.captainHistoryRisk;
    if (vpf * 3 > (vr + chr * 2)) return "A";
    else return "B";
  }

  get voyageRisk() {
    let result = 1;
    if (this.voyage.length > 4) result += 2;
    if (this.voyage.length > 8) result += this.voyage.length - 8;
    if (["중국", "동인도"].include(this.voyage.zone)) result += 4;
    return Math.max(result, 0);
  }

  get captainHistoryRisk() {
    let result = 1;
    if (this.history.length < 5) result += 4;
    result += this.history.filter(v => v.profit < 0).length;
    return Math.max(result, 0);
  }

  get voyageProfitFactor() {
    let result = 2;

    if (this.voyage.zone === "중국") result += 1;
    if (this.voyage.zone === "동인도") result += 1;
    result += this.historyLengthFactor;
    result += this.voyageLengthFactor;
    return result;
  }

  get voyageLengthFactor() {      
    return (this.voyage.length > 14) ? -1 : 0;
  }

  get historyLengthFactor() {
    return (this.history.length > 8) ? 1 : 0;
  }

  hasChinaHistory() {
    return this.history.some(v => "중국" === v.zone);
  }
}

class ExperienceChinaRating extends Rating {
  get captainHistoryRisk() {
    const result = super.captainHistoryRisk - 2;
    return Math.max(result, 0);
  }

+ get voyageProfitFactor() {
+   return super.voyageProfitFactor + 3;
+ }

  get voyageLengthFactor() {      
    let result = 0;
-   result += 3;
    if (this.voyage.length > 12) result += 1;
    if (this.voyage.length > 18) result -= 1;
    return result;
  }

  get historyLengthFactor() {
    return (this.history.length > 10) ? 1 : 0;
  }
}

// 호출하는 쪽의 코드
const voyage = { zone: "서인도", length: 10 };
const history = [
  { zone: "동인도", profit: 5 },
  { zone: "서인도", profit: 15 },
  { zone: "중국", profit: -2 },
  { zone: "서아프리카", profit: 7 },
];

const myRating = rating(voyage, history);
```
### STEP 3-6
리팩터링 결과로 다음 코드를 얻었다. 중국 항해 경험이 있는지와 관련한 복잡한 코드에서 벗어난 기본 `Rating` 클래스를 먼저 만나보자.
``` javascript
class Rating {
  constructor(voyage, history) {
    this.voyage = voyage;
    this.history = history;
  }

  get value() {
    const vpf = this.voyageProfileFactor;
    const vr = this.voyageRisk;
    const chr = this.captainHistoryRisk;
    if (vpf * 3 > (vr + chr * 2)) return "A";
    else return "B";
  }

  get voyageRisk() {
    let result = 1;
    if (this.voyage.length > 4) result += 2;
    if (this.voyage.length > 8) result += this.voyage.length - 8;
    if (["중국", "동인도"].include(this.voyage.zone)) result += 4;
    return Math.max(result, 0);
  }

  get captainHistoryRisk() {
    let result = 1;
    if (this.history.length < 5) result += 4;
    result += this.history.filter(v => v.profit < 0).length;
    return Math.max(result, 0);
  }

  get voyageProfitFactor() {
    let result = 2;

    if (this.voyage.zone === "중국") result += 1;
    if (this.voyage.zone === "동인도") result += 1;
    result += this.historyLengthFactor;
    result += this.voyageLengthFactor;
    return result;
  }

  get voyageLengthFactor() {      
    return (this.voyage.length > 14) ? -1 : 0;
  }

  get historyLengthFactor() {
    return (this.history.length > 8) ? 1 : 0;
  }

  hasChinaHistory() {
    return this.history.some(v => "중국" === v.zone);
  }
}
```
중국 항해 경험이 있을 때를 담당하는 다음 클래스는 기본 클래스와의 차이만 담고 있다.
``` javascript
class ExperienceChinaRating extends Rating {
  get captainHistoryRisk() {
    const result = super.captainHistoryRisk - 2;
    return Math.max(result, 0);
  }

  get voyageProfitFactor() {
    return super.voyageProfitFactor + 3;
  }

  get voyageLengthFactor() {      
    let result = 0;
    if (this.voyage.length > 12) result += 1;
    if (this.voyage.length > 18) result -= 1;
    return result;
  }

  get historyLengthFactor() {
    return (this.history.length > 10) ? 1 : 0;
  }
}
```

- [10.3 중첩 조건문을 보호 구문으로 바꾸기(Replace Nested Conditional with Guard Clauses)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-3.md)
- [10.5 특이 케이스 추가하기(Introduce Special Case)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-5.md)