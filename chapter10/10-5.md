### 10.5 특이 케이스 추가하기(Introduce Special Case)
``` diff
-if (aCustomer === "미확인 고객") customerName = "거주자";
+class UnknownCustomer {
+ get name() { return "거주자"; }
```
#### 배경
데이터 구조의 특정 값을 확인한 후 똑같은 동작을 수행하는 코드가 곳곳에 등장하는 경우가 더러 있는데, 흔히 볼 수 있는 중복 코드 중 하나다. 이처럼 코드베이스에서 특정 값에 대해 똑같이 반응하는 코드가 여러 곳이라면 그 반응들을 한 데로 모으는 게 효율적이다.

특수한 경우의 공통 동작을 요소 하나에 모아서 사용하는 특이 케이스 패턴(Special Case Pattern)이라는 것이 있는데, 바로 이럴 때 적용하면 좋은 매커니즘이다. 이 패턴을 활용하면 특이 케이스를 확인하는 코드 대부분을 단순한 함수 호출로 바꿀 수 있다.

특이 케이스는 여러 형태로 표현할 수 있다. 특이 케이스 객체에서 단순히 데이터를 읽기만 한다면 반환할 값들을 담은 리터럴 객체 형태로 준비하면 된다. 그 이상의 어떤 동작을 수행해야 한다면 필요한 메서드를 담은 객체를 생성하면 된다. 특이 케이스 객체는 이를 캡슐화한 클래스가 반환하도록 만들 수도 있고, 변환(transform)을 거쳐 데이터 구조에 추가시키는 형태도 될 수 있다.

널(null)은 특이 케이스로 처리할 때가 많다. 그래서 이 패턴을 "널 객체 패턴(Null Object Pattern)"이라고도 한다. 하지만 널 외의 다른 특이 케이스에도 같은 패턴을 적용할 수 있으니, 널 객체가 특이 케이스의 특수한 예라고 보는 게 맞을 것이다.
#### 절차
이번 리팩터링의 대상이 될 속성을 담은 데이터 구조(혹은 클래스)에서 시작하자. 이 데이터 구조를 컨테이너라고 하겠다. 컨테이너를 사용하는 코드에서는 해당 속성이 특이한 값인지를 검사한다. 우리는 이 대상이 가질 수 있는 값 중 특별하게 다뤄야 할 값을 특이 케이스 클래스(혹은 데이터 구조)로 대체하고자 한다.
##### (1)
컨테이너에 특이 케이스인지를 검사하는 속성을 추가하고, `false`를 반환하게 한다.
##### (2)
특이 케이스 객체를 만든다. 이 객체는 특이 케이스인지를 검사하는 속성만 포함되며, 이 속성은 `true`를 반환하게 한다.

##### (3)
클라이언트에서 특이 케이스인지를 검사하는 코드를 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md) 한다. 모든 클라이언트가 값을 직접 비교하는 대신 방금 추출한 함수를 사용하도록 고친다.
##### (4)
코드에 새로운 특이 케이스 대상을 추가한다. 함수의 반환 값으로 받거나 변환 함수를 적용하면 된다.
##### (5)
특이 케이스를 검사하는 함수 본문을 수정하여 특이 케이스 객체의 속성을 사용하도록 한다.
##### (6)
테스트한다.
##### (7)
[6.9 여러 함수를 클래스로 묶기(Combine Functions into Class)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-9.md)나 [6.10 여러 함수를 변환 함수로 묶기(Combine Functions into Transform)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-10.md)를 적용하여 특이 케이스를 처리하는 공통 동작을 새로운 요소로 옮긴다.
- 특이 케이스 클래스는 간단한 요청에는 항상 같은 값을 반환하는 게 보통이므로, 해당 특이 케이스의 리터럴 레코드를 만들어 활용할 수 있을 것이다.
##### (8)
아직도 특이 케이스 검사 함수를 이용하는 곳이 남아 있다면 검사 함수를 [6.2 함수 인라인하기(Inline Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-2.md) 한다.
#### 예시
##### STEP 1-1
전력 회사는 전력이 필요한 현장(site)에 인프라를 설치해 서비스를 제공한다.
``` javascript
class Site {
  get customer() { return this._customer; }
}
```
##### STEP 1-2
고객(customer) 클래스에는 수많은 속성이 있겠지만, 그 중 다음 세 가지만 고려해보자.
``` javascript
class Customer {
  get name() {...} // 고객 이름
  get billingPlan() {...} // 요금제
  set billingPlan(arg) {...}
  get paymentHistory() {...} // 납부 이력
}
```
##### STEP 1-3
일반적으로 현장에는 고객이 거주하는 게 보통이지만 꼭 그렇지만은 않다. 누군가 이사를 나가고 (아직 누구인지 모르는) 다른 누군가가 이사왔을 수도 있다. 이럴 때는 데이터 레코드의 고객 필드를 **미확인 고객**이란 문자열로 채운다. 이런 상황을 감안하여 `Site` 클래스를 사용하는 클라이언트 코드들은 알려지지 않은 미확인 고객도 처리할 수 있어야 한다. 이런 코드의 예를 몇 개 가져와봤다.
``` javascript
// 클라이언트 1
const aCustomer = site.customer;
// ... 수많은 코드
let customerName;
if (aCustomer === "미확인 고객") customerName = "거주자";
else customerName = aCustomer.name;

// 클라이언트 2
const plan = (aCustomer === "미확인 고객") ? registry.billingPlan.basic : aCustomer.billingPlan;

// 클라이언트 3
if (aCustomer !== "미확인 고객") aCustomer.billingPlan = newPlan;

// 클라이언트 4
const weeksDeliquent = (aCustomer === "미확인 고객") ? 0 : aCustomer.paymentHistory.weeksDeliquentInLastYear;
```
코드 베이스를 훑어보니 미확인 고객을 처리해야 하는 클라이언트가 여러 개 발견됐고, 그 대부분에서 똑같은 방식으로 처리했다. 고객 이름으로는 **거주자**를 사용하고, 기본 요금제(billing plan)를 청구하고, 연체(delinquent) 기간은 0주(week)로 분류한 것이다. 많은 곳에서 이뤄지는 이 특이 케이스 검사와 공통된 반응이 우리에게 특이 케이스 객체를 도입할 때임을 말해준다.
##### STEP 1-4
[(1)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-5.md#1) 먼저 미확인 고객인지를 나타내는 메서드를 고객 클래스에 추가한다.
``` diff
class Site {
  get customer() { return this._customer; }
}

class Customer {
  get name() {...} // 고객 이름
  get billingPlan() {...} // 요금제
  set billingPlan(arg) {...}
  get paymentHistory() {...} // 납부 이력
+ get isUnknown() { return false; }
}

// 클라이언트 1
const aCustomer = site.customer;
// ... 수많은 코드
let customerName;
if (aCustomer === "미확인 고객") customerName = "거주자";
else customerName = aCustomer.name;

// 클라이언트 2
const plan = (aCustomer === "미확인 고객") ? registry.billingPlan.basic : aCustomer.billingPlan;

// 클라이언트 3
if (aCustomer !== "미확인 고객") aCustomer.billingPlan = newPlan;

// 클라이언트 4
const weeksDeliquent = (aCustomer === "미확인 고객") ? 0 : aCustomer.paymentHistory.weeksDeliquentInLastYear;
```
##### STEP 1-5
[(2)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-5.md#2) 그런 다음 미확인 고객 전용 클래스를 만든다.
``` diff
class Site {
  get customer() { return this._customer; }
}

class Customer {
  get name() {...} // 고객 이름
  get billingPlan() {...} // 요금제
  set billingPlan(arg) {...}
  get paymentHistory() {...} // 납부 이력
  get isUnknown() { return false; }
}

+class UnknownCustomer {
+ get isUnknown() { return true; }
+}

// 클라이언트 1
const aCustomer = site.customer;
// ... 수많은 코드
let customerName;
if (aCustomer === "미확인 고객") customerName = "거주자";
else customerName = aCustomer.name;

// 클라이언트 2
const plan = (aCustomer === "미확인 고객") ? registry.billingPlan.basic : aCustomer.billingPlan;

// 클라이언트 3
if (aCustomer !== "미확인 고객") aCustomer.billingPlan = newPlan;

// 클라이언트 4
const weeksDeliquent = (aCustomer === "미확인 고객") ? 0 : aCustomer.paymentHistory.weeksDeliquentInLastYear;
```
> `UnknownCustomer`를 `Customer`의 서브클래스로 만들지 않았음에 주목하자. 다른 언어, 특히 정적 타입 언어였다면 서브클래스로 만들었을 것이다. 하지만 자바스크립트의 서브클래스 규칙과 동적 타이핑 능력 덕분에 이 경우엔 지금 예처럼 만드는 편이 낫다.
##### STEP 1-6
[(3)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-5.md#3) 지금부터는 좀 까다롭다. **미확인 고객**을 기대하는 모두에 새로 만든 특이 케이스 객체(`UnknownCustomer`)를 반환하도록 하고, 역시 값이 **미확인 고객**인지를 검사하는 곳 모두에서 새로운 `isUnknown()` 메서드를 사용하도록 고쳐야 한다. 한 번에 조금씩만 변경하고 테스트할 수 있는 잘 정돈된 코드가 필요해 보인다. 그런데 `Customer` 클래스를 수정하여 **미확인 고객** 문자열 대신 `UnknownCustomer` 객체를 반환하게 한다면, 클라이언트들 각각에서 **미확인 고객**인지를 확인하는 코드 모두를 `isUnknown()` 호출로 바꾸는 작업을 한 번에 해야만 한다. 다시 말해, 전혀 매력적이지 않다.

이런 상황에 봉착할 때마다 내가 자주 사용하는 기법이 있다. 여러 곳에서 똑같이 수정해야만 하는 코드를 별도 함수로 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md)하여 한데로 모으는 것이다. 지금 예에서는 특이 케이스인지 확인하는 코드가 추출 대상이다.
``` diff
class Site {
  get customer() { return this._customer; }
}

class Customer {
  get name() {...} // 고객 이름
  get billingPlan() {...} // 요금제
  set billingPlan(arg) {...}
  get paymentHistory() {...} // 납부 이력
  get isUnknown() { return false; }
}

class UnknownCustomer {
  get isUnknown() { return true; }
}

+function isUnknown(arg) {
+ if (!((arg instanceof Customer) || (arg === '미확인 고객')))
+   throw new Error(`잘못된 값과 비교: <${arg}>`);
+ return (arg === '미확인 고객');
+}

// 클라이언트 1
const aCustomer = site.customer;
// ... 수많은 코드
let customerName;
if (aCustomer === "미확인 고객") customerName = "거주자";
else customerName = aCustomer.name;

// 클라이언트 2
const plan = (aCustomer === "미확인 고객") ? registry.billingPlan.basic : aCustomer.billingPlan;

// 클라이언트 3
if (aCustomer !== "미확인 고객") aCustomer.billingPlan = newPlan;

// 클라이언트 4
const weeksDeliquent = (aCustomer === "미확인 고객") ? 0 : aCustomer.paymentHistory.weeksDeliquentInLastYear;
```
> 의도치 않은 값이 입력되면 에러를 던지도록 한다. 이렇게 하면 리팩터링 도중 실수를 저지르거나, 혹은 이상하게 동작하는 위치를 찾는 데 도움이 된다.
##### STEP 1-7
이제 이 `isUnknown()` 함수를 이용해 미확인 고객인지를 확인할 수 있다. 이 변경을 한 번에 하나씩만 적용하고 테스트해보자.
``` diff
class Site {
  get customer() { return this._customer; }
}

class Customer {
  get name() {...} // 고객 이름
  get billingPlan() {...} // 요금제
  set billingPlan(arg) {...}
  get paymentHistory() {...} // 납부 이력
  get isUnknown() { return false; }
}

class UnknownCustomer {
  get isUnknown() { return true; }
}

function isUnknown(arg) {
  if (!((arg instanceof Customer) || (arg === '미확인 고객')))
    throw new Error(`잘못된 값과 비교: <${arg}>`);
  return (arg === '미확인 고객');
}

// 클라이언트 1
const aCustomer = site.customer;
// ... 수많은 코드
let customerName;
-if (aCustomer === "미확인 고객") customerName = "거주자";
+if (isUnknown(aCustomer)) customerName = "거주자";
else customerName = aCustomer.name;

// 클라이언트 2
const plan = (aCustomer === "미확인 고객") ? registry.billingPlan.basic : aCustomer.billingPlan;

// 클라이언트 3
if (aCustomer !== "미확인 고객") aCustomer.billingPlan = newPlan;

// 클라이언트 4
const weeksDeliquent = (aCustomer === "미확인 고객") ? 0 : aCustomer.paymentHistory.weeksDeliquentInLastYear;
```
##### STEP 1-8
다른 코드들도 모두 수정한다.
``` diff
class Site {
  get customer() { return this._customer; }
}

class Customer {
  get name() {...} // 고객 이름
  get billingPlan() {...} // 요금제
  set billingPlan(arg) {...}
  get paymentHistory() {...} // 납부 이력
  get isUnknown() { return false; }
}

class UnknownCustomer {
  get isUnknown() { return true; }
}

function isUnknown(arg) {
  if (!((arg instanceof Customer) || (arg === '미확인 고객')))
    throw new Error(`잘못된 값과 비교: <${arg}>`);
  return (arg === '미확인 고객');
}

// 클라이언트 1
const aCustomer = site.customer;
// ... 수많은 코드
let customerName;
if (isUnknown(aCustomer)) customerName = "거주자";
else customerName = aCustomer.name;

// 클라이언트 2
-const plan = (aCustomer === "미확인 고객") ? registry.billingPlan.basic : aCustomer.billingPlan;
+const plan = (isUnknown(aCustomer)) ? registry.billingPlan.basic : aCustomer.billingPlan;

// 클라이언트 3
-if (aCustomer !== "미확인 고객") aCustomer.billingPlan = newPlan;
+if (!isUnknown(aCustomer)) aCustomer.billingPlan = newPlan;

// 클라이언트 4
-const weeksDeliquent = (aCustomer === "미확인 고객") ? 0 : aCustomer.paymentHistory.weeksDeliquentInLastYear;
+const weeksDeliquent = (isUnknown(aCustomer)) ? 0 : aCustomer.paymentHistory.weeksDeliquentInLastYear;
```
##### STEP 1-9
호출하는 곳 모두에서 `isUnknown()` 함수를 사용하도록 수정했다면 [(4)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-5.md#4) 특이 케이스일 때 `Site` 클래스가 `UnknownCustomer` 객체를 반환하도록 수정하자.
``` diff
class Site {
- get customer() { return this._customer; }
+ get customer() {
+   return (this._customer === "미확인 고객") ? new UnknownCustomer() : this._customer;
+ }
}

class Customer {
  get name() {...} // 고객 이름
  get billingPlan() {...} // 요금제
  set billingPlan(arg) {...}
  get paymentHistory() {...} // 납부 이력
  get isUnknown() { return false; }
}

class UnknownCustomer {
  get isUnknown() { return true; }
}

function isUnknown(arg) {
  if (!((arg instanceof Customer) || (arg === '미확인 고객')))
    throw new Error(`잘못된 값과 비교: <${arg}>`);
  return (arg === '미확인 고객');
}

// 클라이언트 1
const aCustomer = site.customer;
// ... 수많은 코드
let customerName;
if (isUnknown(aCustomer)) customerName = "거주자";
else customerName = aCustomer.name;

// 클라이언트 2
const plan = (isUnknown(aCustomer)) ? registry.billingPlan.basic : aCustomer.billingPlan;

// 클라이언트 3
if (!isUnknown(aCustomer)) aCustomer.billingPlan = newPlan;

// 클라이언트 4
const weeksDeliquent = (isUnknown(aCustomer)) ? 0 : aCustomer.paymentHistory.weeksDeliquentInLastYear;
```
##### STEP 1-10
[(5)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-5.md#5) `isUnknown()` 함수를 수정하여 고객 객체의 속성을 사용하도록 하면 **"미확인 고객"** 문자열을 사용하던 코드는 완전히 사라진다.
``` diff
class Site {
  get customer() {
    return (this._customer === "미확인 고객") ? new UnknownCustomer() : this._customer;
  }
}

class Customer {
  get name() {...} // 고객 이름
  get billingPlan() {...} // 요금제
  set billingPlan(arg) {...}
  get paymentHistory() {...} // 납부 이력
  get isUnknown() { return false; }
}

class UnknownCustomer {
  get isUnknown() { return true; }
}

function isUnknown(arg) {
- if (!((arg instanceof Customer) || (arg === '미확인 고객')))
+ if (!(arg instanceof Customer || arg instanceof UnknownCustomer))
    throw new Error(`잘못된 값과 비교: <${arg}>`);
- return (arg === '미확인 고객');
+ return arg.isUnknown;
}

// 클라이언트 1
const aCustomer = site.customer;
// ... 수많은 코드
let customerName;
if (isUnknown(aCustomer)) customerName = "거주자";
else customerName = aCustomer.name;

// 클라이언트 2
const plan = (isUnknown(aCustomer)) ? registry.billingPlan.basic : aCustomer.billingPlan;

// 클라이언트 3
if (!isUnknown(aCustomer)) aCustomer.billingPlan = newPlan;

// 클라이언트 4
const weeksDeliquent = (isUnknown(aCustomer)) ? 0 : aCustomer.paymentHistory.weeksDeliquentInLastYear;
```
##### STEP 1-11
[(6)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-5.md#6) 모든 기능이 잘 동작하는지 테스트한다.

##### STEP 1-12
[(7)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-5.md#7) 이제부터가 재미있다. 각 클라이언트에서 수행하는 특이 케이스 검사를 일반적인 기본값으로 대체할 수 있다면 이 검사 코드에 여러 함수를 [6.9 여러 함수를 클래스로 묶기(Combine Functions into Class)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-9.md)를 적용할 수 있다. 지금 예에서는 미확인 고객의 이름으로 **"거주자"**를 사용하는 코드가 많다. 다음 코드처럼 말이다.
``` javascript
// 클라이언트 1
const aCustomer = site.customer;
// ... 수많은 코드
let customerName;
if (isUnknown(aCustomer)) customerName = "거주자";
else customerName = aCustomer.name;
```
다음과 같이 적절한 메서드를 `UnknownCustomer` 클래스에 추가하자. 그러면 조건부 코드는 지워도 된다.
``` diff
class Site {
  get customer() {
    return (this._customer === "미확인 고객") ? new UnknownCustomer() : this._customer;
  }
}

class Customer {
  get name() {...} // 고객 이름
  get billingPlan() {...} // 요금제
  set billingPlan(arg) {...}
  get paymentHistory() {...} // 납부 이력
  get isUnknown() { return false; }
}

class UnknownCustomer {
  get isUnknown() { return true; }
+ get name() { return "거주자"; }  
}

function isUnknown(arg) {
  if (!(arg instanceof Customer || arg instanceof UnknownCustomer))
    throw new Error(`잘못된 값과 비교: <${arg}>`);
  return arg.isUnknown;
}

// 클라이언트 1
const aCustomer = site.customer;
// ... 수많은 코드
let customerName;
-if (isUnknown(aCustomer)) customerName = "거주자";
-else customerName = aCustomer.name;
+customerName = aCustomer.name;

// 클라이언트 2
const plan = (isUnknown(aCustomer)) ? registry.billingPlan.basic : aCustomer.billingPlan;

// 클라이언트 3
if (!isUnknown(aCustomer)) aCustomer.billingPlan = newPlan;

// 클라이언트 4
const weeksDeliquent = (isUnknown(aCustomer)) ? 0 : aCustomer.paymentHistory.weeksDeliquentInLastYear;
```
##### STEP 1-13
지금까지의 코드가 동작하는지 테스트한다. 그리고 나라면 이 변수를 [6.4 변수 인라인하기(Inline Variable)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-4.md) 할 것이다. 다음은 요금제 속성 차례다.
``` javascript
// 클라이언트 2
const plan = (isUnknown(aCustomer)) ? registry.billingPlan.basic : aCustomer.billingPlan;

// 클라이언트 3
if (!isUnknown(aCustomer)) aCustomer.billingPlan = newPlan;
```
요금제 속성을 읽는 동작은 앞서 이름 속성을 처리한 과정을 그대로 반복할 것이다. 즉, 일반적인 기본값을 반환한다. 쓰는 동작은 조금 다르다. 현재 코드에서는 미확인 고객에 대해서는 세터를 호출하지 않는다. 겉보기 동작을 똑같게 만들어야 하므로 특이 케이스에서도 세터가 호출되도록 하되, 세터에서는 아무런 일도 하지 않는다.
``` diff
class Site {
  get customer() {
    return (this._customer === "미확인 고객") ? new UnknownCustomer() : this._customer;
  }
}

class Customer {
  get name() {...} // 고객 이름
  get billingPlan() {...} // 요금제
  set billingPlan(arg) {...}
  get paymentHistory() {...} // 납부 이력
  get isUnknown() { return false; }
}

class UnknownCustomer {
  get isUnknown() { return true; }  
  get name() { return "거주자"; }  
+ get billingPlan() { return registry.billingPlans.basic; }
+ set billingPlan() { /* 무시한다 */ }
}

function isUnknown(arg) {
  if (!(arg instanceof Customer || arg instanceof UnknownCustomer))
    throw new Error(`잘못된 값과 비교: <${arg}>`);
  return arg.isUnknown;
}

// 클라이언트 1
const aCustomer = site.customer;
// ... 수많은 코드
let customerName;
customerName = aCustomer.name;

// 클라이언트 2
-const plan = (isUnknown(aCustomer)) ? registry.billingPlan.basic : aCustomer.billingPlan;
+const plan = aCustomer.billingPlan;

// 클라이언트 3
-if (!isUnknown(aCustomer)) aCustomer.billingPlan = newPlan;
+aCustomer.billingPlan = newPlan;

// 클라이언트 4
const weeksDeliquent = (isUnknown(aCustomer)) ? 0 : aCustomer.paymentHistory.weeksDeliquentInLastYear;
```
특이 케이스 객체는 값 객체다. 따라서 항상 불변이어야 한다. 대체하려는 값이 가변이더라도 마찬가지다.
##### STEP 1-14
마지막 상황은 좀 더 복잡하다. 특이 케이스가 자신만의 속성을 갖는 또 다른 객체(지불 이력)를 반환해야 하기 때문이다.
``` javascript
// 클라이언트 4
const weeksDeliquent = (isUnknown(aCustomer)) ? 0 : aCustomer.paymentHistory.weeksDeliquentInLastYear;
```
특이 케이스 객체가 다른 객체를 반환해야 한다면 그 객체 역시 특이 케이스여야 하는 것이 일반적이다. 그래서 `NullPaymentHistory`를 만들기로 했다.
``` diff
class Site {
  get customer() {
    return (this._customer === "미확인 고객") ? new UnknownCustomer() : this._customer;
  }
}

class Customer {
  get name() {...} // 고객 이름
  get billingPlan() {...} // 요금제
  set billingPlan(arg) {...}
  get paymentHistory() {...} // 납부 이력
  get isUnknown() { return false; }
}

class UnknownCustomer {
  get isUnknown() { return true; }  
  get name() { return "거주자"; }  
  get billingPlan() { return registry.billingPlans.basic; }
  set billingPlan() { /* 무시한다 */ }
+ get paymentHistory() { return new NullPaymentHistory(); }
}

+class NullPaymentHistory() {
+ get weeksDeliquentInLastYear() { return 0; }
+}

function isUnknown(arg) {
  if (!(arg instanceof Customer || arg instanceof UnknownCustomer))
    throw new Error(`잘못된 값과 비교: <${arg}>`);
  return arg.isUnknown;
}

// 클라이언트 1
const aCustomer = site.customer;
// ... 수많은 코드
let customerName;
customerName = aCustomer.name;

// 클라이언트 2
const plan = aCustomer.billingPlan;

// 클라이언트 3
aCustomer.billingPlan = newPlan;

// 클라이언트 4
-const weeksDeliquent = (isUnknown(aCustomer)) ? 0 : aCustomer.paymentHistory.weeksDeliquentInLastYear;
+const weeksDeliquent = aCustomer.paymentHistory.weeksDeliquentInLastYear;
```
##### STEP 1-15
[(8)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-5.md#8) 계속해서 모든 클라이언트의 코드를 이 다형적 행위(타입에 따라 동작이 달라진다는 뜻)로 대체할 수 있는지를 살펴본다. 예외가 있을 수 있기 때문이다. 특이 케이스로부터 다른 클라이언트와는 다른 무언가를 원하는 독특한 클라이언트가 있을 수 있다. 예컨대 미확인 고객의 이름으로 **"거주자"** 를 사용하는 클라이언트가 23개나 되더라도 튀는 클라이언트가 하나쯤은 있을 수 있다. 다음 클라이언트처럼 말이다.
``` javascript
// 튀는 클라이언트
const name = !isUnknown(aCustomer) ? aCustomer.name : "미확인 거주자";
```
이런 경우엔 원래의 특이 케이스 검사 코드를 유지해야 한다. 이 코드는 `Customer`에 선언된 메서드를 사용하도록 수정하면 되는데, 구체적으로는 `isUnknown()` 함수를 [6.2 함수 인라인하기(Inline Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-2.md)하면 된다.
``` diff
// 튀는 클라이언트
-const name = !isUnknown(aCustomer) ? aCustomer.name : "미확인 거주자";
+const name = aCustomer.isUnknown ? "미확인 거주자" : aCustomer.name;
```
##### STEP 1-16
모든 클라이언트를 수정했다면, 호출하는 곳이 없어진 전역 `isUnknown()` 함수를 [8.9 죽은 코드 제거하기(Remove Dead Code)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-9.md)로 없애준다.
``` diff
class Site {
  get customer() {
    return (this._customer === "미확인 고객") ? new UnknownCustomer() : this._customer;
  }
}

class Customer {
  get name() {...} // 고객 이름
  get billingPlan() {...} // 요금제
  set billingPlan(arg) {...}
  get paymentHistory() {...} // 납부 이력
  get isUnknown() { return false; }
}

class UnknownCustomer {
  get isUnknown() { return true; }  
  get name() { return "거주자"; }  
  get billingPlan() { return registry.billingPlans.basic; }
  set billingPlan() { /* 무시한다 */ }
  get paymentHistory() { return new NullPaymentHistory(); }
}

class NullPaymentHistory() {
  get weeksDeliquentInLastYear() { return 0; }
}

-function isUnknown(arg) {
- if (!(arg instanceof Customer || arg instanceof UnknownCustomer))
-   throw new Error(`잘못된 값과 비교: <${arg}>`);
- return arg.isUnknown;
-}

// 클라이언트 1
const aCustomer = site.customer;
// ... 수많은 코드
let customerName;
customerName = aCustomer.name;

// 클라이언트 2
const plan = aCustomer.billingPlan;

// 클라이언트 3
aCustomer.billingPlan = newPlan;

// 클라이언트 4
const weeksDeliquent = aCustomer.paymentHistory.weeksDeliquentInLastYear;
```
#### 예시: 객체 리터럴 이용하기
앞의 예처럼 정말 단순한 값을 위해 클래스까지 동원하는 건 좀 과한 감이 있다. 하지만 고객 정보가 갱신될 수 있어서 클래스가 꼭 필요했다. 한편, 데이터 구조를 읽기만 한다면 클래스 대신 리터럴 객체를 사용해도 된다.

같은 예를 다시 살펴보자. 단, 이번에는 고객 정보를 갱신하는 클라이언트가 없다.
``` javascript
class Site { return this._customer; }

class Customer {
  get name() {...}
  get billingPlan() {...}
  set billingPlan(arg) {...}
  get paymentHistory() {...}
}

// 클라이언트 1
const aCustomer = site.customer;
// ... 수많은 코드
let customerName;
if (aCustomer === "미확인 고객") customerName = "거주자";
else customerName = aCustomer.name;

// 클라이언트 2
const plan = (aCustomer === "미확인 고객") ? registry.billingPlan.basic : aCustomer.billingPlan;

// 클라이언트 3
const weeksDeliquent = (aCustomer === "미확인 고객") ? 0 : aCustomer.paymentHistory.weeksDeliquentInLastYear;
```
##### STEP 2-1
[(1)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-5.md#1) 앞의 예와 같이, 먼저 고객에 `isUnknown()` 속성을 추가하고 [(2)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-5.md#2) 이 필드를 포함하는 특이 케이스 객체를 생성한다. 차이점이라면 이번에는 특이 케이스가 리터럴이다.
``` diff
class Site {
  get customer() { return this._customer; }
}

class Customer {
  get name() {...}
  get billingPlan() {...}
  set billingPlan(arg) {...}
  get paymentHistory() {...}
+ get isUnknown() { return false; }
}

+function createUnknownCustomer() {
+ return {
+   isUnknown: true,
+ }
+}

// 클라이언트 1
const aCustomer = site.customer;
// ... 수많은 코드
let customerName;
if (aCustomer === "미확인 고객") customerName = "거주자";
else customerName = aCustomer.name;

// 클라이언트 2
const plan = (aCustomer === "미확인 고객") ? registry.billingPlan.basic : aCustomer.billingPlan;

// 클라이언트 3
const weeksDeliquent = (aCustomer === "미확인 고객") ? 0 : aCustomer.paymentHistory.weeksDeliquentInLastYear;
```
##### STEP 2-2
[(3)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-5.md#3) 특이 케이스 조건 검사 부분을 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md) 한다.
``` diff
class Site {
  get customer() { return this._customer; }
}

class Customer {
  get name() {...}
  get billingPlan() {...}
  set billingPlan(arg) {...}
  get paymentHistory() {...}
  get isUnknown() { return false; }
}

function createUnknownCustomer() {
  return {
    isUnknown: true,
  }
}

+function isUnknown(arg) {
+ return (arg === "미확인 고객");
+}

// 클라이언트 1
const aCustomer = site.customer;
// ... 수많은 코드
let customerName;
-if (aCustomer === "미확인 고객") customerName = "거주자";
+if (isUnknown(aCustomer)) customerName = "거주자";
else customerName = aCustomer.name;

// 클라이언트 2
-const plan = (aCustomer === "미확인 고객") ? registry.billingPlan.basic : aCustomer.billingPlan;
+const plan = (isUnknown(aCustomer)) ? registry.billingPlan.basic : aCustomer.billingPlan;

// 클라이언트 3
-const weeksDeliquent = (aCustomer === "미확인 고객") ? 0 : aCustomer.paymentHistory.weeksDeliquentInLastYear;
+const weeksDeliquent = (isUnknown(aCustomer)) ? 0 : aCustomer.paymentHistory.weeksDeliquentInLastYear;
```
##### STEP 2-3
[(4)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-5.md#4) 조건을 검사하는 코드와 `Site` 클래스에서 이 특이 케이스를 이용하도록 수정한다.
``` diff
class Site {
- get customer() { return this._customer; }
+ get customer() {
+   return (this._customer === "미확인 고객") ? createUnknownCustomer() : this._customer;
+ }
}

class Customer {
  get name() {...}
  get billingPlan() {...}
  set billingPlan(arg) {...}
  get paymentHistory() {...}
  get isUnknown() { return false; }
}

function createUnknownCustomer() {
  return {
    isUnknown: true,
  }
}

function isUnknown(arg) {
- return (arg === "미확인 고객");
+ return arg.isUnknown;
}

// 클라이언트 1
const aCustomer = site.customer;
// ... 수많은 코드
let customerName;
if (isUnknown(aCustomer)) customerName = "거주자";
else customerName = aCustomer.name;

// 클라이언트 2
const plan = (isUnknown(aCustomer)) ? registry.billingPlan.basic : aCustomer.billingPlan;

// 클라이언트 3
const weeksDeliquent = (isUnknown(aCustomer)) ? 0 : aCustomer.paymentHistory.weeksDeliquentInLastYear;
```
##### STEP 2-4
[(7)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-5.md#7) 다음으로, 각각의 표준 응답을 적절한 리터럴 값으로 대체한다. 이름부터 해보자.
``` diff
class Site {
  get customer() {
    return (this._customer === "미확인 고객") ? createUnknownCustomer() : this._customer;
  }
}

class Customer {
  get name() {...}
  get billingPlan() {...}
  set billingPlan(arg) {...}
  get paymentHistory() {...}
  get isUnknown() { return false; }
}

function createUnknownCustomer() {
  return {
    isUnknown: true,
+   name: "거주자",
  }
}

function isUnknown(arg) {
  return arg.isUnknown;
}

// 클라이언트 1
const aCustomer = site.customer;
// ... 수많은 코드
-let customerName;
-if (isUnknown(aCustomer)) customerName = "거주자";
-else customerName = aCustomer.name;
+const customerName = aCustomer.name;

// 클라이언트 2
const plan = (isUnknown(aCustomer)) ? registry.billingPlan.basic : aCustomer.billingPlan;

// 클라이언트 3
const weeksDeliquent = (isUnknown(aCustomer)) ? 0 : aCustomer.paymentHistory.weeksDeliquentInLastYear;
```
##### STEP 2-5
다음은 요금제 차례다.
``` diff
class Site {
  get customer() {
    return (this._customer === "미확인 고객") ? createUnknownCustomer() : this._customer;
  }
}

class Customer {
  get name() {...}
  get billingPlan() {...}
  set billingPlan(arg) {...}
  get paymentHistory() {...}
  get isUnknown() { return false; }
}

function createUnknownCustomer() {
  return {
    isUnknown: true,
    name: "거주자",
+   billingPlan: registry.billingPlan.basic,
  }
}

function isUnknown(arg) {
  return arg.isUnknown;
}

// 클라이언트 1
const aCustomer = site.customer;
// ... 수많은 코드
const customerName = aCustomer.name;

// 클라이언트 2
-const plan = (isUnknown(aCustomer)) ? registry.billingPlan.basic : aCustomer.billingPlan;
+const plan = aCustomer.billingPlan;

// 클라이언트 3
const weeksDeliquent = (isUnknown(aCustomer)) ? 0 : aCustomer.paymentHistory.weeksDeliquentInLastYear;
```
##### STEP 2-6
비슷한 방법으로 납부 이력이 없다는 정보는 중첩 리터럴로 생성한다.
``` diff
class Site {
  get customer() {
    return (this._customer === "미확인 고객") ? createUnknownCustomer() : this._customer;
  }
}

class Customer {
  get name() {...}
  get billingPlan() {...}
  set billingPlan(arg) {...}
  get paymentHistory() {...}
  get isUnknown() { return false; }
}

function createUnknownCustomer() {
  return {
    isUnknown: true,
    name: "거주자",
    billingPlan: registry.billingPlan.basic,
+   paymentHistory: {
+     weeksDeliquentInLastYear: 0,
+   }
  }
}

function isUnknown(arg) {
  return arg.isUnknown;
}

// 클라이언트 1
const aCustomer = site.customer;
// ... 수많은 코드
const customerName = aCustomer.name;

// 클라이언트 2
const plan = aCustomer.billingPlan;

// 클라이언트 3
-const weeksDeliquent = (isUnknown(aCustomer)) ? 0 : aCustomer.paymentHistory.weeksDeliquentInLastYear;
+const weeksDeliquent = aCustomer.paymentHistory.weeksDeliquentInLastYear;
```
리터럴을 이런 식으로 사용하려면 불변으로 만들어야 한다(`freeze()` 메서드를 이용하면 된다). 참고로 나는 이 방식보다는 클래스를 사용하는 쪽을 선호한다.
#### 예시: 변환 함수 이용하기
앞의 두 예는 모두 클래스와 관련 있지만, 변환 단계를 추가하면 같은 아이디어를 레코드에도 적용할 수 있다.

입력이 다음처럼 단순한 레코드 구조라고 가정하자(JSON 문서다).
``` json
{
  "name": "애크미 보스턴",
  "location": "Malden MA",
  // 더 많은 현장(site) 정보
  "customer": {
    "name": "애크미 산업", 
    "billingPlan": "plan-451",
    "paymentHistory": {
      "weeksDeliquentInLastYear": 7,
      // 중략
    },
    // 중략
  }
}
```
고객이 알려지지 않은 경우도 있을 텐데, 앞서와 똑같이 **"미확인 고객"**으로 표시하자.
``` json
{
  "name": "물류창고 15",
  "location": "Malden MA",
  // 더 많은 현장(site) 정보
  "customer": "미확인 고객",
}
```
이번에도 앞서의 예시들과 비슷하게, 미확인 고객인지를 검사하는 클라이언트 코드들이 있다.
``` javascript
// 클라이언트 1
const site = acquireSiteData();
const aCustomer = site.customer;
// ... 수많은 코드
let customerName;
if (aCustomer === "미확인 고객") customerName = "거주자";
else customerName = aCustomer.name;

// 클라이언트 2
const plan = (aCustomer === "미확인 고객") ? registry.billingPlan.basic : aCustomer.billingPlan;

// 클라이언트 3
const weeksDeliquent = (aCustomer === "미확인 고객") ? 0 : aCustomer.paymentHistory.weeksDeliquentInLastYear;
```
##### STEP 3-1
처음 할 일은 현장 데이터 구조를 변환 함수인 `enrichSite()`에 통과시키는 것이다. 이 함수는 아직 특별한 작업없이 깊은 복사(`deep copy`)만 수행한다.
> 참고로 마틴 파울러는 본질은 같고 부가 정보만 덧붙이는 변환 함수의 이름을 "enrich"라 하고, 형태가 변할 때만 "transform"이라는 이름을 쓴다.
``` diff
+function enrichSite(inputSite) {
+ return _.cloneDeep(inputSite);
+}

// 클라이언트 1
+const rawSite = acquireSiteDate();
-const site = acquireSiteData();
+const site = enrichSite(rawSite);
const aCustomer = site.customer;
// ... 수많은 코드
let customerName;
if (aCustomer === "미확인 고객") customerName = "거주자";
else customerName = aCustomer.name;

// 클라이언트 2
const plan = (aCustomer === "미확인 고객") ? registry.billingPlan.basic : aCustomer.billingPlan;

// 클라이언트 3
const weeksDeliquent = (aCustomer === "미확인 고객") ? 0 : aCustomer.paymentHistory.weeksDeliquentInLastYear;
```
##### STEP 3-2
[(3)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-5.md#3) 알려지지 않은 고객인지 검사하는 로직을 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md) 한다.
``` diff
+function isUnknown(aCustomer) {
+ return aCustomer === "미확인 고객"
+}

function enrichSite(inputSite) {
  return _.cloneDeep(inputSite);
}

// 클라이언트 1
const rawSite = acquireSiteDate();
const site = enrichSite(rawSite);
const aCustomer = site.customer;
// ... 수많은 코드
let customerName;
-if (aCustomer === "미확인 고객") customerName = "거주자";
+if (isUnknown(aCustomer)) customerName = "거주자";
else customerName = aCustomer.name;

// 클라이언트 2
-const plan = (aCustomer === "미확인 고객") ? registry.billingPlan.basic : aCustomer.billingPlan;
+const plan = (isUnknown(aCustomer)) ? registry.billingPlan.basic : aCustomer.billingPlan;

// 클라이언트 3
-const weeksDeliquent = (aCustomer === "미확인 고객") ? 0 : aCustomer.paymentHistory.weeksDeliquentInLastYear;
+const weeksDeliquent = (isUnknown(aCustomer)) ? 0 : aCustomer.paymentHistory.weeksDeliquentInLastYear;
```
##### STEP 3-3
[(1)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-5.md#1)[(2)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-5.md#2) 고객 레코드에서 `isUnknown()` 속성을 추가하여 현장 정보를 보강(enrich)한다.
``` diff
function isUnknown(aCustomer) {
  return aCustomer === "미확인 고객"
}

-function enrichSite(inputSite) {
+function enrichSite(aSite) {
- return _.cloneDeep(inputSite);
+ const result = _.cloneDeep(aSite);
+ const unknownCustomer = {
+   isUnknown: true,
+ };

+ if (isUnknown(result.customer)) result.customer = unknownCustomer;
+ else result.customer.isUnknown = false;
+ return result;
}

// 클라이언트 1
const rawSite = acquireSiteDate();
const site = enrichSite(rawSite);
const aCustomer = site.customer;
// ... 수많은 코드
let customerName;
if (isUnknown(aCustomer)) customerName = "거주자";
else customerName = aCustomer.name;

// 클라이언트 2
const plan = (isUnknown(aCustomer)) ? registry.billingPlan.basic : aCustomer.billingPlan;

// 클라이언트 3
const weeksDeliquent = (isUnknown(aCustomer)) ? 0 : aCustomer.paymentHistory.weeksDeliquentInLastYear;
```
##### STEP 3-4
[(5)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-5.md#5) 그런 다음 특이 케이스 검사 시 새로운 속성을 이용하도록 수정한다. 원래의 검사도 유지하여 입력이 원래의 `rawSite`든 보강(변환)된 `site`든 상관없이 테스트가 동작하도록 해준다.
``` diff
function isUnknown(aCustomer) {
+ if (aCustomer === "미확인 고객") return true;
+ else return aCustomer.isUnknown;
- return aCustomer === "미확인 고객"
}

function enrichSite(aSite) {
  const result = _.cloneDeep(inputSite);
  const unknownCustomer = {
    isUnknown: true,
  };

  if (isUnknown(result.customer)) result.customer = unknownCustomer;
  else result.customer.isUnknown = false;
  return result;
}

// 클라이언트 1
const rawSite = acquireSiteDate();
const site = enrichSite(rawSite);
const aCustomer = site.customer;
// ... 수많은 코드
let customerName;
if (isUnknown(aCustomer)) customerName = "거주자";
else customerName = aCustomer.name;

// 클라이언트 2
const plan = (isUnknown(aCustomer)) ? registry.billingPlan.basic : aCustomer.billingPlan;

// 클라이언트 3
const weeksDeliquent = (isUnknown(aCustomer)) ? 0 : aCustomer.paymentHistory.weeksDeliquentInLastYear;
```
##### STEP 3-5
[(6)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-5.md#6) 모든 기능이 잘 동작하는지 테스트한 다음 [(7)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-5.md#7) 특이 케이스에 [6.10 여러 함수를 변환 함수로 묶기(Combine Functions into Transform)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-10.md)를 적용한다. 먼저 이름 선택 부분을 `enrichSite()` 함수로 옮긴다.
``` diff
function isUnknown(aCustomer) {
  if (aCustomer === "미확인 고객") return true;
  else return aCustomer.isUnknown;
}

function enrichSite(aSite) {
  const result = _.cloneDeep(inputSite);
  const unknownCustomer = {
    isUnknown: true,
+   name: "거주자",
  };

  if (isUnknown(result.customer)) result.customer = unknownCustomer;
  else result.customer.isUnknown = false;
  return result;
}

// 클라이언트 1
const rawSite = acquireSiteDate();
const site = enrichSite(rawSite);
const aCustomer = site.customer;
// ... 수많은 코드
-let customerName;
-if (isUnknown(aCustomer)) customerName = "거주자";
-else customerName = aCustomer.name;
+const customerName = aCustomer.name;

// 클라이언트 2
const plan = (isUnknown(aCustomer)) ? registry.billingPlan.basic : aCustomer.billingPlan;

// 클라이언트 3
const weeksDeliquent = (isUnknown(aCustomer)) ? 0 : aCustomer.paymentHistory.weeksDeliquentInLastYear;
```
##### STEP 3-6
테스트한 후 요금제에도 적용한다.
``` diff
function isUnknown(aCustomer) {
  if (aCustomer === "미확인 고객") return true;
  else return aCustomer.isUnknown;
}

function enrichSite(aSite) {
  const result = _.cloneDeep(inputSite);
  const unknownCustomer = {
    isUnknown: true,
    name: "거주자",
+   billingPlan: registry.billingPlan.basic,
  };

  if (isUnknown(result.customer)) result.customer = unknownCustomer;
  else result.customer.isUnknown = false;
  return result;
}

// 클라이언트 1
const rawSite = acquireSiteDate();
const site = enrichSite(rawSite);
const aCustomer = site.customer;
// ... 수많은 코드
const customerName = aCustomer.name;

// 클라이언트 2
-const plan = (isUnknown(aCustomer)) ? registry.billingPlan.basic : aCustomer.billingPlan;
+const plan = aCustomer.billingPlan;

// 클라이언트 3
const weeksDeliquent = (isUnknown(aCustomer)) ? 0 : aCustomer.paymentHistory.weeksDeliquentInLastYear;
```
##### STEP 3-7
또 테스트한 후 마지막 클라이언트까지 수정한다.
``` diff
function isUnknown(aCustomer) {
  if (aCustomer === "미확인 고객") return true;
  else return aCustomer.isUnknown;
}

function enrichSite(aSite) {
  const result = _.cloneDeep(inputSite);
  const unknownCustomer = {
    isUnknown: true,
    name: "거주자",
    billingPlan: registry.billingPlan.basic,
+   paymentHistory: {
+     weeksDeliquentInLastYear: 0,
+   }
  };

  if (isUnknown(result.customer)) result.customer = unknownCustomer;
  else result.customer.isUnknown = false;
  return result;
}

// 클라이언트 1
const rawSite = acquireSiteDate();
const site = enrichSite(rawSite);
const aCustomer = site.customer;
// ... 수많은 코드
const customerName = aCustomer.name;

// 클라이언트 2
const plan = aCustomer.billingPlan;

// 클라이언트 3
-const weeksDeliquent = (isUnknown(aCustomer)) ? 0 : aCustomer.paymentHistory.weeksDeliquentInLastYear;
+const weeksDeliquent = aCustomer.paymentHistory.weeksDeliquentInLastYear;
```