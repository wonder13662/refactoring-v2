### 10.5 특이 케이스 추가하기(Introduce Special Case)
``` diff
-if (aCustomer === "미확인 고객") customerName = "거주자";
+class UnknownCustomer {
+ get name() { return "거주자"; }
```
#### 배경
데이터 구조의 특정 값을 확인한 후 똑같은 동작을 수행하는 코드가 곳곳에 등장하는 경우가 더러 있는데, 흔히 볼 수 있는 중복 코드 중 하나다. 이처럼 코드베이스에서 특정 값에 대해 똑같이 반응하는 코드가 여러 곳이라면 그 반응들을 한 데로 모으는 게 효율적이다.

특수한 경우의 공통 동작을 요소 하나에 모아서 사용하는 특이 케이스 패턴(Special Case Pattern)이라는 것이 있는데, 바로 이럴 때 적용하면 좋은 매커니즘이다. 이 패턴을 활용하면 특이 케이스를 확인하는 코드 대부분을 단순한 함수 호출로 바꿀 수 있다.

특이 케이스는 여러 형태로 표현할 수 있다. 특이 케이스 객체에서 단순히 데이터를 읽기만 한다면 반환할 값들을 담은 리터럴 객체 형태로 준비하면 된다. 그 이상의 어떤 동작을 수행해야 한다면 필요한 메서드를 담은 객체를 생성하면 된다. 특이 케이스 객체는 이를 캡슐화한 클래스가 반환하도록 만들 수도 있고, 변환(transform)을 거쳐 데이터 구조에 추가시키는 형태도 될 수 있다.

널(null)은 특이 케이스로 처리할 때가 많다. 그래서 이 패턴을 "널 객체 패턴(Null Object Pattern)"이라고도 한다. 하지만 널 외의 다른 특이 케이스에도 같은 패턴을 적용할 수 있으니, 널 객체가 특이 케이스의 특수한 예라고 보는 게 맞을 것이다.
#### 절차
이번 리팩터링의 대상이 될 속성을 담은 데이터 구조(혹은 클래스)에서 시작하자. 이 데이터 구조를 컨테이너라고 하겠다. 컨테이너를 사용하는 코드에서는 해당 속성이 특이한 값인지를 검사한다. 우리는 이 대상이 가질 수 있는 값 중 특별하게 다뤄야 할 값을 특이 케이스 클래스(혹은 데이터 구조)로 대체하고자 한다.
##### (1)
컨테이너에 특이 케이스인지를 검사하는 속성을 추가하고, `false`를 반환하게 한다.
##### (2)
특이 케이스 객체를 만든다. 이 객체는 특이 케이시인지를 검사하는 속성만 포함되며, 이 속성은 `true`를 반환하게 한다.

##### (3)
클라이언트에서 특이 케이스인지를 검사하는 코드를 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md) 한다. 모든 클라이언트가 값을 직접 비교하는 대신 방금 추출한 함수를 사용하도록 고친다.
##### (4)
코드에 새로운 특이 케이스 대상을 추가한다. 함수의 반환 값으로 받거나 변환 함수를 적용하면 된다.
##### (5)
특이 케이스를 검사하는 함수 본문을 수정하여 특이 케이스 객체의 속성을 사용하도록 한다.
##### (6)
테스트한다.
##### (7)
[6.9 여러 함수를 클래스로 묶기(Combine Functions into Class)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-9.md)나 [6.10 여러 함수를 변환 함수로 묶기(Combine Functions into Transform)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-10.md)를 적용하여 특이 케이스를 처리하는 공통 동작을 새로운 요소로 옮긴다.
- 특이 케이스 클래스는 간단한 요청에는 항상 같은 값을 반환하는 게 보통이므로, 해당 특이 케이스의 리터럴 레코드를 만들어 활용할 수 있을 것이다.
##### (8)
아직도 특이 케이스 검사 함수를 이용하는 곳이 남아 있다면 검사 함수를 [6.2 함수 인라인하기(Inline Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-2.md) 한다.
#### 예시
##### STEP 1
전력 회사는 전력이 필요한 현장(site)에 인프라를 설치해 서비스를 제공한다.
``` diff
+class Site {
+ get customer() { return this._customer; }
+}
```
##### STEP 2
고객(customer) 클래스에는 수많은 속성이 있겠지만, 그 중 다음 세 가지만 고려해보자.
``` diff
class Site {
  get customer() { return this._customer; }
}

+class Customer {
+ get name() {...} // 고객 이름
+ get billingPlan() {...} // 요금제
+ get billingPlan(arg) {...}
+ get paymentHistory() {...} // 납부 이력
+}
```
##### STEP 3
일반적으로 현장에는 고객이 거주하는 게 보통이지만 꼭 그렇지만은 않다. 누군가 이사를 나가고 (아직 누구인지 모르는) 다른 누군가가 이사왔을 수도 있다. 이럴 때는 데이터 레코드의 고객 필드를 **미확인 고객**이란 문자열로 채운다. 이런 상황을 감안하여 `Site` 클래스를 사용하는 클라이언트 코드들은 알려지지 않은 미확인 고객도 처리할 수 있어야 한다. 이런 코드의 예를 몇 개 가져와봤다.
``` diff
+// 클라이언트 1
+const aCustomer = site.customer;
+// ... 수많은 코드
+let customerName;
+if (aCustomer === "미확인 고객") customerName = "거주자";
+else customerName = aCustomer.name;

+// 클라이언트 2
+const plan = (aCustomer === "미확인 고객") ? registry.billingPlan.basic : aCustomer.billingPlan;

+// 클라이언트 3
+if (aCustomer !== "미확인 고객") aCustomer.billingPlan = newPlan;

+// 클라이언트 4
+const weeksDeliquent = (aCustomer === "미확인 고객") ? 0 : aCustomer.paymentHistory.weeksDeliquentInLastYear;
```
코드 베이스를 훑어보니 미확인 고객을 처리해야 하는 클라이언트가 여러 개 발견됐고, 그 대부분에서 똑같은 방식으로 처리했다. 고객 이름으로는 **거주자**를 사용하고, 기본 요금제(billing plan)를 청구하고, 연체(delinquent) 기간은 0주(week)로 분류한 것이다. 많은 곳에서 이뤄지는 이 특이 케이스 검사와 공통된 반응이 우리에게 특이 케이스 객체를 도입할 때임을 말해준다.
##### STEP 4
[(1)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-5.md#1) 먼저 미확인 고객인지를 나타내는 메서드를 고객 클래스에 추가한다.
``` diff
class Site {
  get customer() { return this._customer; }
}

class Customer {
  get name() {...} // 고객 이름
  get billingPlan() {...} // 요금제
  get billingPlan(arg) {...}
  get paymentHistory() {...} // 납부 이력
+ get isUnknown() { return false; }
}

// 클라이언트 1
const aCustomer = site.customer;
// ... 수많은 코드
let customerName;
if (aCustomer === "미확인 고객") customerName = "거주자";
else customerName = aCustomer.name;

// 클라이언트 2
const plan = (aCustomer === "미확인 고객") ? registry.billingPlan.basic : aCustomer.billingPlan;

// 클라이언트 3
if (aCustomer !== "미확인 고객") aCustomer.billingPlan = newPlan;

// 클라이언트 4
const weeksDeliquent = (aCustomer === "미확인 고객") ? 0 : aCustomer.paymentHistory.weeksDeliquentInLastYear;
```
##### STEP 5
[(2)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-5.md#2) 그런 다음 미확인 고객 전용 클래스를 만든다.
``` diff
class Site {
  get customer() { return this._customer; }
}

class Customer {
  get name() {...} // 고객 이름
  get billingPlan() {...} // 요금제
  get billingPlan(arg) {...}
  get paymentHistory() {...} // 납부 이력
  get isUnknown() { return false; }
}

+class UnknownCustomer {
+ get isUnknown() { return true; }
+}

// 클라이언트 1
const aCustomer = site.customer;
// ... 수많은 코드
let customerName;
if (aCustomer === "미확인 고객") customerName = "거주자";
else customerName = aCustomer.name;

// 클라이언트 2
const plan = (aCustomer === "미확인 고객") ? registry.billingPlan.basic : aCustomer.billingPlan;

// 클라이언트 3
if (aCustomer !== "미확인 고객") aCustomer.billingPlan = newPlan;

// 클라이언트 4
const weeksDeliquent = (aCustomer === "미확인 고객") ? 0 : aCustomer.paymentHistory.weeksDeliquentInLastYear;
```
> `UnknownCustomer`를 `Customer`의 서브클래스로 만들지 않았음에 주목하자. 다른 언어, 특히 정적 타입 언어였다면 서브클래스로 만들었을 것이다. 하지만 자바스크립트의 서브클래스 규칙과 동적 타이핑 능력 덕분에 이 경우엔 지금 예처럼 만드는 편이 낫다.
##### STEP 6
[(3)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-5.md#3) 지금부터는 좀 까다롭다. **미확인 고객**을 기대하는 모두에 새로 만든 특이 케이스 객체(`UnknownCustomer`)를 반환하도록 하고, 역시 값이 **미확인 고객**인지를 검사하는 곳 모두에서 새로운 `isUnknown()` 메서드를 사용하도록 고쳐야 한다. 한 번에 조금씩만 변경하고 테스트할 수 있는 잘 정돈된 코드가 필요해 보인다. 그런데 `Customer` 클래스를 수정하여 **미확인 고객** 문자열 대신 `UnknownCustomer` 객체를 반환하게 한다면, 클라이언트들 각각에서 **미확인 고객**인지를 확인하는 코드 모두를 `isUnknown()` 호출로 바꾸는 작업을 한 번에 해야만 한다. 다시 말해, 전혀 매력적이지 않다.

이런 상황에 봉착할 때마다 내가 자주 사용하는 기법이 있다. 여러 곳에서 똑같이 수정해야만 하는 코드를 별도 함수로 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md)하여 한데로 모으는 것이다. 지금 예에서는 특이 케이스인지 확인하는 코드가 추출 대상이다.
``` diff
class Site {
  get customer() { return this._customer; }
}

class Customer {
  get name() {...} // 고객 이름
  get billingPlan() {...} // 요금제
  get billingPlan(arg) {...}
  get paymentHistory() {...} // 납부 이력
  get isUnknown() { return false; }
}

class UnknownCustomer {
  get isUnknown() { return true; }
}

+function isUnknown(arg) {
+ if (!((arg instanceof Customer) || (arg === '미확인 고객')))
+   throw new Error(`잘못된 값과 비교: <${arg}>`);
+ return (arg === '미확인 고객');
+}

// 클라이언트 1
const aCustomer = site.customer;
// ... 수많은 코드
let customerName;
if (aCustomer === "미확인 고객") customerName = "거주자";
else customerName = aCustomer.name;

// 클라이언트 2
const plan = (aCustomer === "미확인 고객") ? registry.billingPlan.basic : aCustomer.billingPlan;

// 클라이언트 3
if (aCustomer !== "미확인 고객") aCustomer.billingPlan = newPlan;

// 클라이언트 4
const weeksDeliquent = (aCustomer === "미확인 고객") ? 0 : aCustomer.paymentHistory.weeksDeliquentInLastYear;
```
> 의도치 않은 값이 입력되면 에러를 던지도록 한다. 이렇게 하면 리팩터링 도중 실수를 저지르거나, 혹은 이상하게 동작하는 위치를 찾는 데 도움이 된다.
##### STEP 7
이제 이 `isUnknown()` 함수를 이용해 미확인 고객인지를 확인할 수 있다. 이 변경을 한 번에 하나씩만 적용하고 테스트해보자.