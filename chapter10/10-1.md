# 10.1 조건문 분해하기(Decompose Conditional)
``` diff
-if (!aDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd))
+if (summer())
- charge = quantity * plan.summerRate;
+ charge = summerCharge();
else
- charge = quantity * plan.regularRate + plan.regularServiceCharge;
+ charge = regularCharge();

+ function summerCharge() { ... }
+ function regularCharge() { ... }
```

## 배경
복잡한 조건부 로직은 프로그램을 복잡하게 만드는 가장 흔한 원흉에 속한다. 다양한 조건, 그에 따라 동작도 다양한 코드를 작성하면 순식간에 꽤 긴 함수가 탄생한다. 긴 함수는 그 자체로 읽기가 어렵지만, 조건문은 그 어려움을 한층 가중시킨다. 조건을 검사하고 그 결과에 따른 동작을 표현한 코드는 무슨 일이 일어나는지 이야기해주지만 '왜' 일어나는지는 제대로 말해주지 않을 때가 많은 것이 문제다.

거대한 코드 블록이 주어지면 코드를 부위별로 분해한 다음 해체된 코드 덩어리들을 각 덩어리의 의도를 살린 이름의 함수 호출로 바꿔주자. 그러면 전체적인 의도가 더 확실히 드러난다. 조건문이 보이면 나는 조건식과 각 조건절에 이 작업을 해주길 좋아한다. 이렇게 하면 해당 조건이 무엇인지 강조하고, 그래서 무엇을 분기했는지가 명백해진다. 분기한 이유 역시 더 명확해진다.

이 리팩터링은 자신의 코드에 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md)를 적용하는 한 사례로 볼 수도 있다. 하지만 연습용으로 아주 훌륭하기 때문에 독립된 리팩터링으로 추가했다.

## 절차
### (1)
조건식과 그 조건식에 딸린 조건절 각각을 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md)한다.

## 예시
여름철이면 할인율이 달라지는 어떤 서비스의 요금을 계산한다고 해보자.
``` javascript
if (!aDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd))
  charge = quantity * plan.summerRate;
else
  charge = quantity * plan.regularRate + plan.regularServiceCharge;
```
### STEP 1
[(1)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-1.md#1) 우선 조건 부분(조건식)을 별도 함수로 추출하자.
``` diff
-if (!aDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd))
+if (summer())
  charge = quantity * plan.summerRate;
else
  charge = quantity * plan.regularRate + plan.regularServiceCharge;

+function summer() {
+ return !aDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd);
+}
```
### STEP 2
그런 다음 조건이 만족했을 때의 로직도 또 다른 함수로 추출한다.
``` diff
if (summer())
- charge = quantity * plan.summerRate;
+ charge = summerCharge();
else
  charge = quantity * plan.regularRate + plan.regularServiceCharge;

function summer() {
  return !aDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd);
}

+function summerCharge() {
+ return quantity * plan.summerRate;
+}
```
### STEP 3
마지막으로 `else`절도 별도 함수로 추출한다.
``` diff
if (summer())
  charge = summerCharge();
else
- charge = quantity * plan.regularRate + plan.regularServiceCharge;
+ charge = regularCharge();

function summer() {
  return !aDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd);
}

function summerCharge() {
  return quantity * plan.summerRate;
}

+function regularCharge() {
+ return quantity * plan.regularRate + plan.regularServiceCharge;
+}
```
### STEP 4
모두 끝났다면 취향에 따라 전체 조건문을 3항 연산자로 바꿔줄 수도 있다.
``` diff
-if (summer())
- charge = summerCharge();
-else
- charge = regularCharge();
+charge = summer() ? summerCharge() : regularCharge();

function summer() {
  return !aDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd);
}

function summerCharge() {
  return quantity * plan.summerRate;
}

function regularCharge() {
  return quantity * plan.regularRate + plan.regularServiceCharge;
}
```