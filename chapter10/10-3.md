# 10.3 중첩 조건문을 보호 구문으로 바꾸기(Replace Nested Conditional with Guard Clauses)
``` diff
function getPayAmount() {
- let result;
- if (isDead)
-   result = deadAmount();
+ if (isDead) return deadAmount();
- else {
-   if (isSeparated)
-     result = separaedAmount();
+ if (isSeparated) return separaedAmount();
-    else {
-     if (isRetired)
-       result = retiredAmount();
+ if (isRetired) retiredAmount();
-     else
-       result = normalPayAmount();
-   }
- }
- return result;
+ return normalPayAmount();
}
```
## 배경
조건문은 주로 두가지 형태로 쓰인다.
1. 참인 경로와 거짓인 경로 모두 정상 동작으로 이어지는 형태
2. 한쪽만 정상인 형태

두 형태는 의도하는 바가 서로 다르므로 그 의도가 코드에 드러나야 한다. 나는 두 경로 모두 정상 동작이라면 `if`와 `else`절을 사용한다. 한쪽만 정상이라면 비정상 조건을 `if`에서 검사한 다음, 조건이 참이면(비정상이면) 함수에서 빠져나온다. 두 번째 검사 형태를 흔히 `보호 구문(guard clause)`이라고 한다.

중첩 조건문을 보호 구문으로 바꾸기 리팩터링의 핵심은 의도를 부각하는 데 있다. 나는 `if-then-else` 구조를 사용할 때 `if` 절과 `else` 절에 똑같은 무게를 두어, 코드를 읽는 이에게 양 갈래가 똑같이 중요하다는 뜻을 전달한다. 이와 달리, 보호 구문은 "이건 함수의 핵심이 아니다. 이 일이 일어나면 무언가 조치를 취한 후 함수에서 빠져나온다"라고 이야기한다.

함수의 진입점과 반환점이 하나여야 한다고 배운 프로그래머와 함께 일하다 보면 이 리팩터링을 자주 사용하게 된다. 진입점이 하나라는 조건은 최신 프로그래밍 언어에서는 강제된다. 그런데 반환점이 하나여야 한다는 규칙은, 정말이지 유용하지 않다. 코드에서는 명확함이 핵심이다. 반환점이 하나일 때 함수의 로직이 더 맹백하다면 그렇게 하자. 그렇지 않다면 하지 말자.

## 절차
### (1)
교체해야 할 조건 중 가장 바깥 것을 선택하여 보호 구문으로 바꾼다.
### (2)
테스트한다.
### (3)
[(1)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-3.md#1) ~ [(2)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-3.md#2) 과정을 필요한 만큼 반복한다.
### (4)
모든 보호 구문이 같은 결과를 반환한다면 보호 구문들의 조건식을 - [10.2 중복 조건식 통합하기(Consolidate Conditional Expression)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-2.md) 한다.
## 예시
직원 급여를 계산하는 코드를 예로 가져왔다. 현직 직원만 급여를 받아야 하므로 이 함수는 두 가지 조건을 검사하고 있다.
``` javascript
function payAmount(employee) {
  let result;
  if (employee.isSeparated) { // 퇴사한 직원인가?
    result = { amount: 0, reasonCode: "SEP" };
  } else {
    if (employee.isRetired) { // 은퇴한 직원인가?
      result = { amount: 0, reasonCode: "RET" };
    } else {
      // 급여 계산 로직
      lorem.ipsum(dolor.sitAmet);
      consectetur(adipiscing).elit();
      sed.do.eiusmod = tempor.incididunt.ut(labore) && dolore(magna.aliqua);
      ut.enim.ad(minim.veniam);
      result = someFinalComputation();
    }
  }
  return result;
}
```
이 코드는 실제로 벌어지는 중요한 일들이 중첩된 조건들에 가려서 잘 보이지 않는다. 이 코드가 진짜 의도한 일은 모든 조건이 거짓일 때만 실행되기 때문이다. 이 상황에서는 보호 구문을 사용하면 코드의 의도가 더 잘 드러난다.
### STEP 1-1
다른 리팩터링과 마찬가지로 나는 단계를 작게 나눠 하나씩 밟아가길 좋아한다. [(1)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-3.md#1) 그러니 최상위 조건부터 보호 구문으로 바꿔보자.
``` diff
function payAmount(employee) {
  let result;
- if (employee.isSeparated) { // 퇴사한 직원인가?
-   result = { amount: 0, reasonCode: "SEP" };
- } else {
+ if (employee.isSeparated) return { amount: 0, reasonCode: "SEP" };
    if (employee.isRetired) { // 은퇴한 직원인가?
      result = { amount: 0, reasonCode: "RET" };
    } else {
      // 급여 계산 로직
      lorem.ipsum(dolor.sitAmet);
      consectetur(adipiscing).elit();
      sed.do.eiusmod = tempor.incididunt.ut(labore) && dolore(magna.aliqua);
      ut.enim.ad(minim.veniam);
      result = someFinalComputation();
    }
- }
  return result;
}
```
### STEP 1-2
[(2)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-3.md#2) 변경 후 테스트하고 [(3)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-3.md#3) 다음 조건으로 넘어간다.
``` diff
function payAmount(employee) {
  let result;
  if (employee.isSeparated) return { amount: 0, reasonCode: "SEP" };
- if (employee.isRetired) { // 은퇴한 직원인가?
-   result = { amount: 0, reasonCode: "RET" };
- } else {
+ if (employee.isRetired) return { amount: 0, reasonCode: "RET" };
    // 급여 계산 로직
    lorem.ipsum(dolor.sitAmet);
    consectetur(adipiscing).elit();
    sed.do.eiusmod = tempor.incididunt.ut(labore) && dolore(magna.aliqua);
    ut.enim.ad(minim.veniam);
    result = someFinalComputation();
- }
  return result;
}
```
### STEP 1-3
여기까지 왔다면 `result`변수는 아무 일도 하지 않으므로 제거하자.
``` diff
function payAmount(employee) {
- let result;
  if (employee.isSeparated) return { amount: 0, reasonCode: "SEP" };
  if (employee.isRetired) return { amount: 0, reasonCode: "RET" };
  // 급여 계산 로직
  lorem.ipsum(dolor.sitAmet);
  consectetur(adipiscing).elit();
  sed.do.eiusmod = tempor.incididunt.ut(labore) && dolore(magna.aliqua);
  ut.enim.ad(minim.veniam);
- result = someFinalComputation();
- return result;
+ return someFinalComputation();
}
```
가변 변수를 제거하면 자다가도 떡이 생긴다는 사실을 항상 기억하자!

## 예시: 조건 반대로 만들기
이 책 초판의 원고를 검토하던 조슈아 케리에프스키(Joshua Kerievsky)가 이 리팩터링을 수행할 때는 조건식을 반대로 만들어 적용하는 경우도 많다고 알려왔다. 그리고 고맙게도 예시까지 만들어 보내주었다.
``` javascript
function adjustedCapital(anInstrument) {
  let result = 0;
  if (anInstrument.capital > 0) {
    if (anInstrument.interestRate > 0 && anInstrument.duration > 0) {
      result = (anInstrument.income / anInstrument.duration) * anInstrument.adjustmentFactor;
    }
  }
  return result;
}
```
### STEP 2-1
역시 한 번에 하나씩 수정한다. 다만 이번에는 보호 구문을 추가하면서 조건을 역으로 바꿀 것이다.
``` diff
function adjustedCapital(anInstrument) {
  let result = 0;
+ if (anInstrument.capital <= 0) return result;
- if (anInstrument.capital > 0) {
    if (anInstrument.interestRate > 0 && anInstrument.duration > 0) {
      result = (anInstrument.income / anInstrument.duration) * anInstrument.adjustmentFactor;
    }
- }
  return result;
}
```
### STEP 2-2
다음 조건은 살짝 더 복잡하므로 두 단계로 나눠 진행하겠다. 먼저 간단히 `not`연산자(!)를 추가한다.
``` diff
function adjustedCapital(anInstrument) {
  let result = 0;
  if (anInstrument.capital <= 0) return result;
+ if (!(anInstrument.interestRate > 0 && anInstrument.duration > 0)) return result;
- if (anInstrument.interestRate > 0 && anInstrument.duration > 0) {
    result = (anInstrument.income / anInstrument.duration) * anInstrument.adjustmentFactor;
- }
  return result;
}
```
### STEP 2-3
이처럼 조건식 안에 `not`이 있으면 영 개운치 않으니 다음처럼 간소화한다.
``` diff
function adjustedCapital(anInstrument) {
  let result = 0;
  if (anInstrument.capital <= 0) return result;
+ if (anInstrument.interestRate <= 0 || anInstrument.duration <= 0) return result;
- if (!(anInstrument.interestRate > 0 && anInstrument.duration > 0)) return result;
  result = (anInstrument.income / anInstrument.duration) * anInstrument.adjustmentFactor;
  return result;
}
```
### STEP 2-4
두 `if`문 모두 같은 결과를 내는 조건을 포함하니 [10.2 중복 조건식 통합하기(Consolidate Conditional Expression)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-2.md) 한다.
``` diff
function adjustedCapital(anInstrument) {
  let result = 0;
- if (anInstrument.capital <= 0) return result;
- if (anInstrument.interestRate <= 0 || anInstrument.duration <= 0) return result;
+ if (anInstrument.capital <= 0 || anInstrument.interestRate <= 0 || anInstrument.duration <= 0) return result;
  result = (anInstrument.income / anInstrument.duration) * anInstrument.adjustmentFactor;
  return result;
}
```
### STEP 2-5
여기서의 `result` 변수는 두 가지 일을 한다. 처음 설정한 0은 보호 구문이 발동했을 때 반환할 값이다. 두 번째로 설정한 값은 계산의 최종 결과다. 이 변수를 제거하면 변수 하나가 두 가지 용도로 쓰이는 상황이 사라진다.([9.1 변수 쪼개기(Split Variable)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter09/9-1.md) 참고)
``` diff
function adjustedCapital(anInstrument) {
- let result = 0;
  if (anInstrument.capital <= 0 || anInstrument.interestRate <= 0 || anInstrument.duration <= 0) return result;
- result = (anInstrument.income / anInstrument.duration) * anInstrument.adjustmentFactor;
- return result;
+ return (anInstrument.income / anInstrument.duration) * anInstrument.adjustmentFactor;
}
```

- [목차](https://github.com/wonder13662/refactoring-v2/blob/writing/README.md)
- [10 조건부 로직 간소화](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10)
- [10.2 중복 조건식 통합하기(Consolidate Conditional Expression)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-2.md)
- [10.4 조건부 로직을 다형성으로 바꾸기(Replace Conditional with Polymorphism)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-4.md)
