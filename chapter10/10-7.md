### 10.7 제어 플래그를 탈출문으로 바꾸기(Replace Control Flag with Break)
``` diff
for (const p of people) {
- if (!found) {
+ if (p === "조커") {  
-   if (p === "조커") {
      sendAlert();
      found = true;
-   }
  }
}
```

#### 배경
제어 플래그란 코드의 동작을 변경하는 데 사용되는 변수를 말하며, 어딘가에서 값을 계산해 제어 플래그에 설정한 후 다른 어딘가의 조건문에서 검사하는 형태로 쓰인다. 나는 이런 코드를 항상 악취로 본다. 리팩터링으로 충분히 간소화할 수 있음에도 복잡하게 작성된 코드에서 흔히 나타나기 때문이다.

제어 플래그의 주 서식지는 반복문 안이다. `break`문이나 `countinue`문 활용에 익숙하지 않은 사람이 심어놓기도 하고, 함수의 `return`문을 하나로 유지하고자 노력하는 사람이 심기도 한다. 모든 함수의 `return`문은 하나여야 한다고 주장하는 사람도 있지만, 나는 동의하지 않는다. 함수에서 할 일을 다 마쳤다면 그 사실을 `return`문으로 알리는 편이 낫지 않을까?

#### 절차
##### (1)
제어 플래그를 사용하는 코드를 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md)할지 고려한다.
##### (2)
제어 플래그를 갱신하는 코드 각각을 적절한 제어문으로 바꾼다. 하나 바꿀때마다 테스트한다.
- 제어문으로는 주로 `return`, `break`, `continue`가 쓰인다.
##### (3)
모두 수정했다면 제어 플래그를 제거한다.

#### 예시
다음은 사람 목록을 훑으면서 악당(miscreant)을 찾는 코드다. 악당 이름은 하드코딩되어 있다.
``` javascript
let found = false;
for (const p of people) {
  if (!found) {
    if (p === "조커") {
      sendAlert();
      found = true;
    }
    if (p === "사루만") {
      sendAlert();
      found = true;
    }
  }
}
```
##### STEP 1
[(1)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-7.md#1) 여기서 제어 플래그는 `found` 변수이고, 제어 흐름을 변경하는데 쓰인다. 이처럼 정리해야 할 코드 양이 제법 된다면 가장 먼저 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md)를 활용해서 서로 밀접한 코드만 담은 함수를 뽑아내보자. 그러면 관련된 코드만 따로 떼어서 볼 수 있다.
``` diff
+checkForMiscreants(people);
+function checkForMiscreants(people) {
  let found = false;
  for (const p of people) {
    if (!found) {
      if (p === "조커") {
        sendAlert();
        found = true;
      }
      if (p === "사루만") {
        sendAlert();
        found = true;
      }
    }
  }
+}
```
##### STEP 2
[(2)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-7.md#2) 제어 플래그가 참이면 반복문에서는 더 이상 할 일이 없다. `break`문으로 반복문에서 벗어나거나 `return`을 써서 함수에서 아예 빠져나오면 된다. 이 함수에서는 더 할 일이 없으니 `return`을 사용하자. 언제나처럼 작은 단계로 나눠 진행할 것이다. 가장 먼저 `return`문을 넣은 후 테스트해보자. 
``` diff
checkForMiscreants(people);
function checkForMiscreants(people) {
  let found = false;
  for (const p of people) {
    if (!found) {
      if (p === "조커") {
        sendAlert();
-       found = true;
+       return;
      }
      if (p === "사루만") {
        sendAlert();
        found = true;
      }
    }
  }
}
```
##### STEP 3
제어 플래그가 갱신되는 장소를 모두 찾아서 같은 과정을 반복한다.
``` diff
checkForMiscreants(people);
function checkForMiscreants(people) {
  let found = false;
  for (const p of people) {
    if (!found) {
      if (p === "조커") {
        sendAlert();
        return;
      }
      if (p === "사루만") {
        sendAlert();
-       found = true;
+       return;
      }
    }
  }
}
```
##### STEP 4
[(3)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-7.md#3) 갱신 코드를 모두 제거했다면, 제어 플래그를 참조하는 다른 코드를 모두 제거한다.
``` diff
checkForMiscreants(people);
function checkForMiscreants(people) {
- let found = false;
  for (const p of people) {
-   if (!found) {
      if (p === "조커") {
        sendAlert();
        return;
      }
      if (p === "사루만") {
        sendAlert();
        return;
      }
-   }
  }
}
```
#### 더 가다듬기
##### STEP 5
이번 리팩터링은 여기서 끝이다. 하지만 이런 코드가 내 눈앞에 있다면 다음과 같은 모습으로 정리할 것이다.
``` diff
checkForMiscreants(people);
function checkForMiscreants(people) {
- for (const p of people) {
-   if (p === "조커") {
-     sendAlert();
-     return;
-   }
-   if (p === "사루만") {
-     sendAlert();
-     return;
-   }
- }
+ if (people.some(p => ["조커", "사루만"].includes(p))) sendAlert(); 
}
```
##### STEP 6
그리고 이 코드를 보고 있자니, 자바스크립트도 어서 다음과 같은 근사한 집합 연산을 지원해줬으면 하는 마음이 간절해진다.
``` diff
checkForMiscreants(people);
function checkForMiscreants(people) {
- if (people.some(p => ["조커", "사루만"].includes(p))) sendAlert(); 
+ if (["조커", "사루만"].isDisjointWith(people)) sendAlert(); 
}
```