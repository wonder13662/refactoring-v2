### 1.8 다형성을 활용해 계산 코드 재구성하기
이번에는 연극 장르를 추가하고 장르마다 공연료와 적립 포인트 계산법을 다르게 지정하도록 기능을 수정해보자. 현재 상태에서 코드를 변경하려면 이 계산을 수행하는 함수에서 조건문을 수정해야 한다. `amountFor()` 함수를 보면 연극 장르에 따라 계산 방식이 달라진다는 사실을 알 수 있는데, 이런 형태의 조건부 로직은 코드 수정 횟수가 늘어날수록 골칫거리로 전락하기 쉽다. 이를 방지하려면 프로그래밍 언어가 제공하는 구조적인 요소로 적절히 보완해야 한다.

조건부 로직을 명확한 구조로 보완하는 방법은 다양하지만, 여기서는 객체지향의 핵심 특징인 다형성(polymorphism)을 활용하는 것이 자연스럽다. 자바스크립트 커뮤니티에서 전통적인 객체지향 지원은 오랫동안 논란거리였다. 그러다가 ECMAScript 2015(ES6)부터 객체지향을 사용할 수 있는 문법과 구조가 제대로 지원되기 시작했다. 따라서 딱 맞는 상황이라면 이런 기능을 적극 활용하는 것이 좋다. 바로 지금처럼 말이다.

이번 작업의 목표는 상속 계층을 구성해서 희극 서브클래스와 비극 서브클래스가 각자의 구체적인 계산 로직을 정의하는 것이다. 호출하는 쪽에서는 다형성 버전의 공연료 계산 함수를 호출하기만 하면 되고, 희극이냐 비극이냐에 따라 정확한 계산 로직을 연결하는 작업은 언어 차원에서 처리해준다. 적립 포인트 계산도 비슷한 구조로 만들 것이다. 이 과정에서 몇 가지 리팩터링 기법을 적용하는데, 그 중 핵심은 [10.4 조건부 로직을 다형성으로 바꾸기(Replace Conditional with Polymorphism)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-4.md)다. 이 리팩터링은 조건부 코드 한 덩어리를 다형성을 활용하는 방식으로 바꿔준다. 그런데 이 리팩터링을 적용하려면 상속 계층부터 정의해야 한다. 즉, 공연료와 적립 포인트 계산 함수를 담을 클래스가 필요하다.

먼저 계산을 수행하는 코드를 살펴보자.

> 앞에서 수정한 리팩터링 덕분에 (출력 데이터 구조를 수정하지 않는 한) 출력 포맷 관련 코드에는 신경 쓸 일이 없다. 더 확실하게 하려면 중간 데이터 구조를 검사하는 테스트를 추가한다.

``` javascript
// createStatementData.js
export default function createStatementData(invoice, plays) {
  const result = {};
  result.customer = invoice.customer;
  result.performances = invoice.performances.map(enrichPerformace);
  result.totalAmount = totalAmount(result);
  result.totalVolumeCredits = totalVolumeCredits(result);
  return result;

  function enrichPerformace(aPerformance) {
    const result = Object.assign({}, aPerformance);
    result.play = playFor(result);
    result.amount = amountFor(result);
    result.volumeCredits = volumeCreditsFor(result);
    return result;
  }

  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }

  function amountFor(aPerformance) {
    let result = 0;
    switch(aPerformance.play.type) {
      case "tragedy": // 비극
        result = 40000;
        if (aPerformance.audience > 30) {  
          result += 1000 * (aPerformance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (aPerformance.audience > 20) {  
          result += 10000 + 500 * (aPerformance.audience - 30);
        }
        result += 300 * aPerformance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${aPerformance.play.type}`);
    }
    return result;
  }

  function volumeCreditsFor(aPerformance) {  
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
    if ("comedy" === aPerformance.play.type) result += Math.floor(aPerformance.audience / 5);
    return result;
  }

  function totalAmount(data) {
    return data.performances.reduce((total, p) => total + p.amount, 0);
  }

  function totalVolumeCredits(data) {
    return data.performances.reduce((total, p) => total + p.volumeCredits, 0);
  }
}
```
#### 공연료 계산기 만들기
#### STEP 1
여기서 핵심은 각 공연의 정보를 중간 데이터 구조에 채워주는 `enrichPerformance()` 함수다. 현재 이 함수는 조건부 로직을 포함한 함수인 `amountFor()`와 `volumeCreditsFor()`를 호출하여 공연료와 적립 포인트를 계산한다. 이번에 할 일은 이 두 함수를 전용 클래스로 욞기는 작업이다. 이 클래스는 공연 관련 데이터를 계산하는 함수들로 구성되므로 공연료 계산기(`PerformaceCalculator`)라 부르기로 하자.
``` diff
// createStatementData.js
export default function createStatementData(invoice, plays) {
  const result = {};
  result.customer = invoice.customer;
  result.performances = invoice.performances.map(enrichPerformace);
  result.totalAmount = totalAmount(result);
  result.totalVolumeCredits = totalVolumeCredits(result);
  return result;

  function enrichPerformace(aPerformance) {
+   const calculator = new PerformanceCalculator(aPerformance); // 공연료 계산기 생성
    const result = Object.assign({}, aPerformance);
    result.play = playFor(result);
    result.amount = amountFor(result);
    result.volumeCredits = volumeCreditsFor(result);
    return result;
  }

  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }

  function amountFor(aPerformance) {
    let result = 0;
    switch(aPerformance.play.type) {
      case "tragedy": // 비극
        result = 40000;
        if (aPerformance.audience > 30) {  
          result += 1000 * (aPerformance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (aPerformance.audience > 20) {  
          result += 10000 + 500 * (aPerformance.audience - 30);
        }
        result += 300 * aPerformance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${aPerformance.play.type}`);
    }
    return result;
  }

  function volumeCreditsFor(aPerformance) {  
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
    if ("comedy" === aPerformance.play.type) result += Math.floor(aPerformance.audience / 5);
    return result;
  }

  function totalAmount(data) {
    return data.performances.reduce((total, p) => total + p.amount, 0);
  }

  function totalVolumeCredits(data) {
    return data.performances.reduce((total, p) => total + p.volumeCredits, 0);
  }
}

// 최상위
+class PerformanceCalculator { // 공연료 계산기 클래스
+ constructor(aPerformance) {
+   this.performance = aPerformance;
+ }
+}
```
#### STEP 2
아직까지는 이 클래스의 객체로 할 수 있는 일은 없다. 기존 코드에서 몇 가지 동작을 이 클래스로 옮겨보자. 먼저 가장 간단한 연극 레코드부터 시작하자. 사실 이 작업은 다형성을 적용해야 할 만큼 차이가 크지 않으니 반드시 할 필요는 없지만, 모든 데이터 변환을 한 곳에서 수행할 수 있어서 더욱 명확해진다.

이를 위해서 계산기 클래스의 생성자에 [6.5 함수 선언 바꾸기(Change Function Declaration)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-5.md)를 적용하여 공연할 연극을 계산기로 전달한다.
``` diff
// createStatementData.js
export default function createStatementData(invoice, plays) {
  const result = {};
  result.customer = invoice.customer;
  result.performances = invoice.performances.map(enrichPerformace);
  result.totalAmount = totalAmount(result);
  result.totalVolumeCredits = totalVolumeCredits(result);
  return result;

  function enrichPerformace(aPerformance) {
-   const calculator = new PerformanceCalculator(aPerformance);
+   const calculator = new PerformanceCalculator(aPerformance, playFor(aPerformance)); // 공연 정보를 계산기로 전달
    const result = Object.assign({}, aPerformance);
-   result.play = playFor(result);
+   result.play = calculator.play;
    result.amount = amountFor(result);
    result.volumeCredits = volumeCreditsFor(result);
    return result;
  }

  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }

  function amountFor(aPerformance) {
    let result = 0;
    switch(aPerformance.play.type) {
      case "tragedy": // 비극
        result = 40000;
        if (aPerformance.audience > 30) {  
          result += 1000 * (aPerformance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (aPerformance.audience > 20) {  
          result += 10000 + 500 * (aPerformance.audience - 30);
        }
        result += 300 * aPerformance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${aPerformance.play.type}`);
    }
    return result;
  }

  function volumeCreditsFor(aPerformance) {  
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
    if ("comedy" === aPerformance.play.type) result += Math.floor(aPerformance.audience / 5);
    return result;
  }

  function totalAmount(data) {
    return data.performances.reduce((total, p) => total + p.amount, 0);
  }

  function totalVolumeCredits(data) {
    return data.performances.reduce((total, p) => total + p.volumeCredits, 0);
  }
}

// 최상위
class PerformanceCalculator { // 공연료 계산기 클래스
- constructor(aPerformance) {
+ constructor(aPerformance, aPlay) {  
    this.performance = aPerformance;
    this.play = aPlay;
  }
}
```
> '컴파일-테스트-커밋'이란 말을 자꾸 하면 지긋지긋해할 것 같아서 이제부터는 되도록 생략하겠다. 말만 생략할 뿐, 여전히 기회가 될 때마다 실행해야 함을 잊지 말자. 사실 나(마틴 파울러)도 '컴파일-테스트-커밋' 하기가 귀찮아서 소홀해질 때가 있다. 그러다 실수하면 정신이 번쩍 들면서 다시 꼬박꼬박 수행하게 된다.
#### 함수들을 계산기로 옮기기
#### STEP 3
그 다음 옮길 로직은 공연료 계산에 더 중요하다. 지금까지는 중첩 함수를 재배치하는 것이어서 함수를 옮기는 데 부담이 없었다. 하지만 이번에는 함수를 (모듈, 클래스 등) 다른 컨텍스트로 옮기는 큰 작업이다. 그러니 이번에는 [8.1 함수 옮기기(Move Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-1.md) 리팩터링으로 작업을 단계별로 차근차근 진행해보자. 가장 먼저 할 일은 공연료 계산 코드를 계산기 클래스 안으로 복사하는 것이다. 그런 다음 이 코드가 새 보금자리에서 잘 동작하도록 `aPerformance`를 `this.performance`로 바꾸고 `playFor(aPerformance)`를 `this.play`로 바꿔준다.
``` diff
// createStatementData.js
export default function createStatementData(invoice, plays) {
  const result = {};
  result.customer = invoice.customer;
  result.performances = invoice.performances.map(enrichPerformace);
  result.totalAmount = totalAmount(result);
  result.totalVolumeCredits = totalVolumeCredits(result);
  return result;

  function enrichPerformace(aPerformance) {
    const calculator = new PerformanceCalculator(aPerformance, playFor(aPerformance));
    const result = Object.assign({}, aPerformance);
    result.play = calculator.play;
    result.amount = amountFor(result);
    result.volumeCredits = volumeCreditsFor(result);
    return result;
  }

  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }

  function amountFor(aPerformance) {
    let result = 0;
    switch(aPerformance.play.type) {
      case "tragedy": // 비극
        result = 40000;
        if (aPerformance.audience > 30) {  
          result += 1000 * (aPerformance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (aPerformance.audience > 20) {  
          result += 10000 + 500 * (aPerformance.audience - 30);
        }
        result += 300 * aPerformance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${aPerformance.play.type}`);
    }
    return result;
  }

  function volumeCreditsFor(aPerformance) {  
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
    if ("comedy" === aPerformance.play.type) result += Math.floor(aPerformance.audience / 5);
    return result;
  }

  function totalAmount(data) {
    return data.performances.reduce((total, p) => total + p.amount, 0);
  }

  function totalVolumeCredits(data) {
    return data.performances.reduce((total, p) => total + p.volumeCredits, 0);
  }
}

// 최상위
class PerformanceCalculator { // 공연료 계산기 클래스
  constructor(aPerformance, aPlay) {  
    this.performance = aPerformance;
    this.play = aPlay;
  }

+ get amount() { // amountFor() 함수의 코드를 계산기 클래스로 복사
+   let result = 0;
+   switch(this.play.type) { // amountFor() 함수가 매개변수로 받던 정보를 PerformanceCalculator의 인스턴스의 필드에서 바로 얻음
+     case "tragedy": // 비극
+       result = 40000;
+       if (this.performance.audience > 30) {  
+         result += 1000 * (this.performance.audience - 30);
+       }
+       break;
+     case "comedy": // 희극
+       result = 30000;
+       if (this.performance.audience > 20) {  
+         result += 10000 + 500 * (this.performance.audience - 30);
+       }
+       result += 300 * aPerformance.audience;
+       break;
+     default:
+       throw new Error(`알 수 없는 장르: ${this.play.type}`);
+   }
+   return result;
+ }
}
```
이렇게 수정한 다음 컴파일하여 에러가 없는지 확인한다. 내 개발 환경에서는 코드를 실행할 때 '컴파일'되는데, 실제로 [babel](https://babeljs.io/)을 실행한다는 뜻으로 썼다. 이렇게 하면 필요 이상으로 많은 일을 하는 셈이지만 어쨌든 새로 만든 함수 코드의 구문 에러를 잘 걸러내준다.
#### STEP 4
복사한 함수가 동작하게끔 수정했다면 원본 함수가 방금 만든 함수로 작업을 위임하도록 바꾼다.
``` diff
// createStatementData.js
export default function createStatementData(invoice, plays) {
  const result = {};
  result.customer = invoice.customer;
  result.performances = invoice.performances.map(enrichPerformace);
  result.totalAmount = totalAmount(result);
  result.totalVolumeCredits = totalVolumeCredits(result);
  return result;

  function enrichPerformace(aPerformance) {
    const calculator = new PerformanceCalculator(aPerformance, playFor(aPerformance));
    const result = Object.assign({}, aPerformance);
    result.play = calculator.play;
    result.amount = amountFor(result);
    result.volumeCredits = volumeCreditsFor(result);
    return result;
  }

  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }

  function amountFor(aPerformance) {
-   let result = 0;
-   switch(aPerformance.play.type) {
-     case "tragedy": // 비극
-       result = 40000;
-       if (aPerformance.audience > 30) {  
-         result += 1000 * (aPerformance.audience - 30);
-       }
-       break;
-     case "comedy": // 희극
-       result = 30000;
-       if (aPerformance.audience > 20) {  
-         result += 10000 + 500 * (aPerformance.audience - 30);
-       }
-       result += 300 * aPerformance.audience;
-       break;
-     default:
-       throw new Error(`알 수 없는 장르: ${aPerformance.play.type}`);
-   }
-   return result;
+   return new PerformanceCalculator(aPerformance, playFor(aPerformance)).amount; // 원본 함수인 amountFor()도 PerformanceCalculator를 이용하도록 수정
  }

  function volumeCreditsFor(aPerformance) {  
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
    if ("comedy" === aPerformance.play.type) result += Math.floor(aPerformance.audience / 5);
    return result;
  }

  function totalAmount(data) {
    return data.performances.reduce((total, p) => total + p.amount, 0);
  }

  function totalVolumeCredits(data) {
    return data.performances.reduce((total, p) => total + p.volumeCredits, 0);
  }
}

// 최상위
class PerformanceCalculator { // 공연료 계산기 클래스
  constructor(aPerformance, aPlay) {  
    this.performance = aPerformance;
    this.play = aPlay;
  }

  get amount() { // amountFor() 함수의 코드를 계산기 클래스로 복사
    let result = 0;
    switch(this.play.type) { // amountFor() 함수가 매개변수로 받던 정보를 PerformanceCalculator의 인스턴스의 필드에서 바로 얻음
      case "tragedy": // 비극
        result = 40000;
        if (this.performance.audience > 30) {  
          result += 1000 * (this.performance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (this.performance.audience > 20) {  
          result += 10000 + 500 * (this.performance.audience - 30);
        }
        result += 300 * aPerformance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${this.play.type}`);
    }
    return result;
  }
}
```
#### STEP 5
그런 다음 컴파일-테스트-커밋해서 새 집으로 이사 간 코드가 제대로 작동하는지 확인한다. 문제없다면 원래 함수를 [6.2 함수 인라인하기(Inline Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-2.md)하여 새 함수를 직접 호출하도록 수정한다(컴파일-테스트-커밋).
``` diff
// createStatementData.js
export default function createStatementData(invoice, plays) {
  const result = {};
  result.customer = invoice.customer;
  result.performances = invoice.performances.map(enrichPerformace);
  result.totalAmount = totalAmount(result);
  result.totalVolumeCredits = totalVolumeCredits(result);
  return result;

  function enrichPerformace(aPerformance) {
    const calculator = new PerformanceCalculator(aPerformance, playFor(aPerformance));
    const result = Object.assign({}, aPerformance);
    result.play = calculator.play;
-   result.amount = amountFor(result);
+   result.amount = calculator.amount; // amountFor() 대신 PerformanceCalculator의 함수 이용
    result.volumeCredits = volumeCreditsFor(result);
    return result;
  }

  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }

  function amountFor(aPerformance) {
    return new PerformanceCalculator(aPerformance, playFor(aPerformance)).amount; // 원본 함수인 amountFor()도 PerformanceCalculator를 이용하도록 수정
  }

  function volumeCreditsFor(aPerformance) {  
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
    if ("comedy" === aPerformance.play.type) result += Math.floor(aPerformance.audience / 5);
    return result;
  }

  function totalAmount(data) {
    return data.performances.reduce((total, p) => total + p.amount, 0);
  }

  function totalVolumeCredits(data) {
    return data.performances.reduce((total, p) => total + p.volumeCredits, 0);
  }
}

// 최상위
class PerformanceCalculator { // 공연료 계산기 클래스
  constructor(aPerformance, aPlay) {  
    this.performance = aPerformance;
    this.play = aPlay;
  }

  get amount() { // amountFor() 함수의 코드를 계산기 클래스로 복사
    let result = 0;
    switch(this.play.type) { // amountFor() 함수가 매개변수로 받던 정보를 PerformanceCalculator의 인스턴스의 필드에서 바로 얻음
      case "tragedy": // 비극
        result = 40000;
        if (this.performance.audience > 30) {  
          result += 1000 * (this.performance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (this.performance.audience > 20) {  
          result += 10000 + 500 * (this.performance.audience - 30);
        }
        result += 300 * aPerformance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${this.play.type}`);
    }
    return result;
  }
}
```
#### STEP 6
적립 포인트를 계산하는 함수도 같은 방법으로 옮긴다.
``` diff
// createStatementData.js
export default function createStatementData(invoice, plays) {
  const result = {};
  result.customer = invoice.customer;
  result.performances = invoice.performances.map(enrichPerformace);
  result.totalAmount = totalAmount(result);
  result.totalVolumeCredits = totalVolumeCredits(result);
  return result;

  function enrichPerformace(aPerformance) {
    const calculator = new PerformanceCalculator(aPerformance, playFor(aPerformance));
    const result = Object.assign({}, aPerformance);
    result.play = calculator.play;
    result.amount = calculator.amount;
-   result.volumeCredits = volumeCreditsFor(result);
+   result.volumeCredits = calculator.volumeCredits;
    return result;
  }

  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }

  function amountFor(aPerformance) {
    return new PerformanceCalculator(aPerformance, playFor(aPerformance)).amount;
  }

  function volumeCreditsFor(aPerformance) {  
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
    if ("comedy" === aPerformance.play.type) result += Math.floor(aPerformance.audience / 5);
    return result;
  }

  function totalAmount(data) {
    return data.performances.reduce((total, p) => total + p.amount, 0);
  }

  function totalVolumeCredits(data) {
    return data.performances.reduce((total, p) => total + p.volumeCredits, 0);
  }
}

// 최상위
class PerformanceCalculator {
  constructor(aPerformance, aPlay) {  
    this.performance = aPerformance;
    this.play = aPlay;
  }

  get amount() {
    let result = 0;
    switch(this.play.type) {
      case "tragedy": // 비극
        result = 40000;
        if (this.performance.audience > 30) {  
          result += 1000 * (this.performance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (this.performance.audience > 20) {  
          result += 10000 + 500 * (this.performance.audience - 30);
        }
        result += 300 * aPerformance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${this.play.type}`);
    }
    return result;
  }

+ get volumeCredits() {
+   let result = 0;
+   result += Math.max(this.performance.audience - 30, 0);
+   if ("comedy" === this.play.type) result += Math.floor(this.performance.audience / 5);
+   return result;
+ }
}
```
#### 공연료 계산기를 다형성 버전으로 만들기
#### STEP 7
클래스에 로직을 담았으니 이제 다형성을 지원하게 만들어보자. 가장 먼저 할 일은 타입 코드(type code) 대신 서브클래스를 사용하도록 변경하는 것이다([12.6 타입 코드를 서브클래스로 바꾸기(Replace Type Code with Subclasses)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-6.md)). 이렇게 하려면 `PerformanceCalculator`의 서브클래스들을 준비하고 `createStatementData()`에서 그중 적합한 서브클래스를 사용하게 만들어야 한다. 그리고 딱 맞는 서브클래스를 사용하려면 생성자 대신 함수를 호출하도록 바꿔야 한다. 자바스크립트에서는 생성자가 서브클래스의 인스턴스를 반환할 수 없기 때문이다. 그래서 [11.8 생성자를 팩터리 함수로 바꾸기(Replace Constructor with Factory Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-8.md)를 적용한다.
``` diff
// createStatementData.js
export default function createStatementData(invoice, plays) {
  const result = {};
  result.customer = invoice.customer;
  result.performances = invoice.performances.map(enrichPerformace);
  result.totalAmount = totalAmount(result);
  result.totalVolumeCredits = totalVolumeCredits(result);
  return result;

  function enrichPerformace(aPerformance) {
-   const calculator = new PerformanceCalculator(aPerformance, playFor(aPerformance));
+   const calculator = createPerformaceCalculator(aPerformance, playFor(aPerformance)); // 생성자 대신 팩터리 함수 이용
    const result = Object.assign({}, aPerformance);
    result.play = calculator.play;
    result.amount = calculator.amount;
    result.volumeCredits = calculator.volumeCredits;
    return result;
  }

  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }

  function amountFor(aPerformance) {
    return new PerformanceCalculator(aPerformance, playFor(aPerformance)).amount;
  }

  function volumeCreditsFor(aPerformance) {  
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
    if ("comedy" === aPerformance.play.type) result += Math.floor(aPerformance.audience / 5);
    return result;
  }

  function totalAmount(data) {
    return data.performances.reduce((total, p) => total + p.amount, 0);
  }

  function totalVolumeCredits(data) {
    return data.performances.reduce((total, p) => total + p.volumeCredits, 0);
  }
}

// 최상위
+function createPerformaceCalculator(aPerformance, aPlay) {
+ return new PerformanceCalculator(aPerformance, aPlay);
+}

class PerformanceCalculator {
  constructor(aPerformance, aPlay) {  
    this.performance = aPerformance;
    this.play = aPlay;
  }

  get amount() {
    let result = 0;
    switch(this.play.type) {
      case "tragedy": // 비극
        result = 40000;
        if (this.performance.audience > 30) {  
          result += 1000 * (this.performance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (this.performance.audience > 20) {  
          result += 10000 + 500 * (this.performance.audience - 30);
        }
        result += 300 * aPerformance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${this.play.type}`);
    }
    return result;
  }

  get volumeCredits() {
    let result = 0;
    result += Math.max(this.performance.audience - 30, 0);
    if ("comedy" === this.play.type) result += Math.floor(this.performance.audience / 5);
    return result;
  }
}
```
#### STEP 8
함수를 이용하면 다음과 같이 `PerformanceCalculator`의 서브클래스 중에서 어느 것을 생성해서 반환할지 선택할 수 있다. 
``` diff
// createStatementData.js
export default function createStatementData(invoice, plays) {
  const result = {};
  result.customer = invoice.customer;
  result.performances = invoice.performances.map(enrichPerformace);
  result.totalAmount = totalAmount(result);
  result.totalVolumeCredits = totalVolumeCredits(result);
  return result;

  function enrichPerformace(aPerformance) {
    const calculator = createPerformaceCalculator(aPerformance, playFor(aPerformance));
    const result = Object.assign({}, aPerformance);
    result.play = calculator.play;
    result.amount = calculator.amount;
    result.volumeCredits = calculator.volumeCredits;
    return result;
  }

  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }

  function amountFor(aPerformance) {
    return new PerformanceCalculator(aPerformance, playFor(aPerformance)).amount;
  }

  function volumeCreditsFor(aPerformance) {  
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
    if ("comedy" === aPerformance.play.type) result += Math.floor(aPerformance.audience / 5);
    return result;
  }

  function totalAmount(data) {
    return data.performances.reduce((total, p) => total + p.amount, 0);
  }

  function totalVolumeCredits(data) {
    return data.performances.reduce((total, p) => total + p.volumeCredits, 0);
  }
}

// 최상위
function createPerformaceCalculator(aPerformance, aPlay) {
- return new PerformanceCalculator(aPerformance, aPlay);
+ switch(aPlay.type) {
+   case "tragedy": return new TragedyCalculator(aPerformance, aPlay);
+   case "comedy": return new ComedyCalculator(aPerformance, aPlay);
+   default:
+     throw new Error(`알 수 없는 장르: ${aPlay.type}`);
+ }
}

class PerformanceCalculator {
  constructor(aPerformance, aPlay) {  
    this.performance = aPerformance;
    this.play = aPlay;
  }

  get amount() {
    let result = 0;
    switch(this.play.type) {
      case "tragedy": // 비극
        result = 40000;
        if (this.performance.audience > 30) {  
          result += 1000 * (this.performance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (this.performance.audience > 20) {  
          result += 10000 + 500 * (this.performance.audience - 30);
        }
        result += 300 * aPerformance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${this.play.type}`);
    }
    return result;
  }

  get volumeCredits() {
    let result = 0;
    result += Math.max(this.performance.audience - 30, 0);
    if ("comedy" === this.play.type) result += Math.floor(this.performance.audience / 5);
    return result;
  }
}

+class TragedyCalculator extends PerformanceCalculator {
+}

+class ComedyCalculator extends PerformanceCalculator {
+}
```
#### STEP 9
이제 다형성을 지원하기 위한 구조는 갖춰졌다. 다음은 [10.4 조건부 로직을 다형성으로 바꾸기(Replace Conditional with Polymorphism)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-4.md)를 적용할 차례다.

비극 공연의 공연료 계산부터 시작해보자.
``` diff
// createStatementData.js
export default function createStatementData(invoice, plays) {
  const result = {};
  result.customer = invoice.customer;
  result.performances = invoice.performances.map(enrichPerformace);
  result.totalAmount = totalAmount(result);
  result.totalVolumeCredits = totalVolumeCredits(result);
  return result;

  function enrichPerformace(aPerformance) {
    const calculator = createPerformaceCalculator(aPerformance, playFor(aPerformance));
    const result = Object.assign({}, aPerformance);
    result.play = calculator.play;
    result.amount = calculator.amount;
    result.volumeCredits = calculator.volumeCredits;
    return result;
  }

  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }

  function amountFor(aPerformance) {
    return new PerformanceCalculator(aPerformance, playFor(aPerformance)).amount;
  }

  function volumeCreditsFor(aPerformance) {  
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
    if ("comedy" === aPerformance.play.type) result += Math.floor(aPerformance.audience / 5);
    return result;
  }

  function totalAmount(data) {
    return data.performances.reduce((total, p) => total + p.amount, 0);
  }

  function totalVolumeCredits(data) {
    return data.performances.reduce((total, p) => total + p.volumeCredits, 0);
  }
}

// 최상위
function createPerformaceCalculator(aPerformance, aPlay) {
  switch(aPlay.type) {
    case "tragedy": return new TragedyCalculator(aPerformance, aPlay);
    case "comedy": return new ComedyCalculator(aPerformance, aPlay);
    default:
      throw new Error(`알 수 없는 장르: ${aPlay.type}`);
  }
}

class PerformanceCalculator {
  constructor(aPerformance, aPlay) {  
    this.performance = aPerformance;
    this.play = aPlay;
  }

  get amount() {
    let result = 0;
    switch(this.play.type) {
      case "tragedy": // 비극
        result = 40000;
        if (this.performance.audience > 30) {  
          result += 1000 * (this.performance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (this.performance.audience > 20) {  
          result += 10000 + 500 * (this.performance.audience - 30);
        }
        result += 300 * aPerformance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${this.play.type}`);
    }
    return result;
  }

  get volumeCredits() {
    let result = 0;
    result += Math.max(this.performance.audience - 30, 0);
    if ("comedy" === this.play.type) result += Math.floor(this.performance.audience / 5);
    return result;
  }
}

class TragedyCalculator extends PerformanceCalculator {
+ get amount() {
+   let result = 40000;
+   if (this.performance.audience > 30) {  
+     result += 1000 * (this.performance.audience - 30);
+   }
+   return result;
+ }
}

class ComedyCalculator extends PerformanceCalculator {
}
```
#### STEP 10
이 메서드를 서브클래스에 정의하기만 해도 슈퍼클래스(`PerformanceCalculator`)의 조건부 로직이 오버라이드된다. 하지만 나처럼 편집증이 있는 프로그래머라면 다음과 같이 작성할 것이다.
``` diff
// createStatementData.js
export default function createStatementData(invoice, plays) {
  const result = {};
  result.customer = invoice.customer;
  result.performances = invoice.performances.map(enrichPerformace);
  result.totalAmount = totalAmount(result);
  result.totalVolumeCredits = totalVolumeCredits(result);
  return result;

  function enrichPerformace(aPerformance) {
    const calculator = createPerformaceCalculator(aPerformance, playFor(aPerformance));
    const result = Object.assign({}, aPerformance);
    result.play = calculator.play;
    result.amount = calculator.amount;
    result.volumeCredits = calculator.volumeCredits;
    return result;
  }

  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }

  function amountFor(aPerformance) {
    return new PerformanceCalculator(aPerformance, playFor(aPerformance)).amount;
  }

  function volumeCreditsFor(aPerformance) {  
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
    if ("comedy" === aPerformance.play.type) result += Math.floor(aPerformance.audience / 5);
    return result;
  }

  function totalAmount(data) {
    return data.performances.reduce((total, p) => total + p.amount, 0);
  }

  function totalVolumeCredits(data) {
    return data.performances.reduce((total, p) => total + p.volumeCredits, 0);
  }
}

// 최상위
function createPerformaceCalculator(aPerformance, aPlay) {
  switch(aPlay.type) {
    case "tragedy": return new TragedyCalculator(aPerformance, aPlay);
    case "comedy": return new ComedyCalculator(aPerformance, aPlay);
    default:
      throw new Error(`알 수 없는 장르: ${aPlay.type}`);
  }
}

class PerformanceCalculator {
  constructor(aPerformance, aPlay) {  
    this.performance = aPerformance;
    this.play = aPlay;
  }

  get amount() {
    let result = 0;
    switch(this.play.type) {
      case "tragedy": // 비극
-       result = 40000;
-       if (this.performance.audience > 30) {  
-         result += 1000 * (this.performance.audience - 30);
-       }
-       break;
+       throw "오류 발생";  // 비극 공연료는 `TragedyCalculator`를 이용하도록 유도
      case "comedy": // 희극
        result = 30000;
        if (this.performance.audience > 20) {  
          result += 10000 + 500 * (this.performance.audience - 30);
        }
        result += 300 * aPerformance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${this.play.type}`);
    }
    return result;
  }

  get volumeCredits() {
    let result = 0;
    result += Math.max(this.performance.audience - 30, 0);
    if ("comedy" === this.play.type) result += Math.floor(this.performance.audience / 5);
    return result;
  }
}

class TragedyCalculator extends PerformanceCalculator {
  get amount() {
    let result = 40000;
    if (this.performance.audience > 30) {  
      result += 1000 * (this.performance.audience - 30);
    }
    return result;
  }
}

class ComedyCalculator extends PerformanceCalculator {
}
```
> 비극 담당 `case`절을 삭제하고 `default` 절에서 에러를 던지게 할 수도 있다. 하지만 나는 명시적으로 던지는 방식을 좋아한다. 게다가 이 문장은 잠시 후 수정할 예정이다(그래서 정식 `Error` 객체가 아닌 문자열을 던졌다).
#### STEP 11
컴파일-테스트-커밋한 후 희극 공연료 계산 코드도 옮긴다.
``` diff
// createStatementData.js
export default function createStatementData(invoice, plays) {
  const result = {};
  result.customer = invoice.customer;
  result.performances = invoice.performances.map(enrichPerformace);
  result.totalAmount = totalAmount(result);
  result.totalVolumeCredits = totalVolumeCredits(result);
  return result;

  function enrichPerformace(aPerformance) {
    const calculator = createPerformaceCalculator(aPerformance, playFor(aPerformance));
    const result = Object.assign({}, aPerformance);
    result.play = calculator.play;
    result.amount = calculator.amount;
    result.volumeCredits = calculator.volumeCredits;
    return result;
  }

  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }

  function amountFor(aPerformance) {
    return new PerformanceCalculator(aPerformance, playFor(aPerformance)).amount;
  }

  function volumeCreditsFor(aPerformance) {  
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
    if ("comedy" === aPerformance.play.type) result += Math.floor(aPerformance.audience / 5);
    return result;
  }

  function totalAmount(data) {
    return data.performances.reduce((total, p) => total + p.amount, 0);
  }

  function totalVolumeCredits(data) {
    return data.performances.reduce((total, p) => total + p.volumeCredits, 0);
  }
}

// 최상위
function createPerformaceCalculator(aPerformance, aPlay) {
  switch(aPlay.type) {
    case "tragedy": return new TragedyCalculator(aPerformance, aPlay);
    case "comedy": return new ComedyCalculator(aPerformance, aPlay);
    default:
      throw new Error(`알 수 없는 장르: ${aPlay.type}`);
  }
}

class PerformanceCalculator {
  constructor(aPerformance, aPlay) {  
    this.performance = aPerformance;
    this.play = aPlay;
  }

  get amount() {
    let result = 0;
    switch(this.play.type) {
      case "tragedy": // 비극
        throw "오류 발생";
      case "comedy": // 희극
-       result = 30000;
-       if (this.performance.audience > 20) {  
-         result += 10000 + 500 * (this.performance.audience - 30);
-       }
-       result += 300 * aPerformance.audience;
-       break;
+       throw "오류 발생";
      default:
        throw new Error(`알 수 없는 장르: ${this.play.type}`);
    }
    return result;
  }

  get volumeCredits() {
    let result = 0;
    result += Math.max(this.performance.audience - 30, 0);
    if ("comedy" === this.play.type) result += Math.floor(this.performance.audience / 5);
    return result;
  }
}

class TragedyCalculator extends PerformanceCalculator {
  get amount() {
    let result = 40000;
    if (this.performance.audience > 30) {  
      result += 1000 * (this.performance.audience - 30);
    }
    return result;
  }
}

class ComedyCalculator extends PerformanceCalculator {
+ get amount() {
+   let result = 30000;
+   if (this.performance.audience > 20) {  
+     result += 10000 + 500 * (this.performance.audience - 30);
+   }
+   result += 300 * aPerformance.audience;
+   return result;
+ }
}
```
#### STEP 12
이제 슈퍼클래스의 `amount()` 메서드는 호출할 일이 없으니 삭제해도 된다. 그래도 여기에 미래의 나에게 한마디 남겨놓는 게 좋을 것 같다.
``` diff
// createStatementData.js
export default function createStatementData(invoice, plays) {
  const result = {};
  result.customer = invoice.customer;
  result.performances = invoice.performances.map(enrichPerformace);
  result.totalAmount = totalAmount(result);
  result.totalVolumeCredits = totalVolumeCredits(result);
  return result;

  function enrichPerformace(aPerformance) {
    const calculator = createPerformaceCalculator(aPerformance, playFor(aPerformance));
    const result = Object.assign({}, aPerformance);
    result.play = calculator.play;
    result.amount = calculator.amount;
    result.volumeCredits = calculator.volumeCredits;
    return result;
  }

  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }

  function amountFor(aPerformance) {
    return new PerformanceCalculator(aPerformance, playFor(aPerformance)).amount;
  }

  function volumeCreditsFor(aPerformance) {  
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
    if ("comedy" === aPerformance.play.type) result += Math.floor(aPerformance.audience / 5);
    return result;
  }

  function totalAmount(data) {
    return data.performances.reduce((total, p) => total + p.amount, 0);
  }

  function totalVolumeCredits(data) {
    return data.performances.reduce((total, p) => total + p.volumeCredits, 0);
  }
}

// 최상위
function createPerformaceCalculator(aPerformance, aPlay) {
  switch(aPlay.type) {
    case "tragedy": return new TragedyCalculator(aPerformance, aPlay);
    case "comedy": return new ComedyCalculator(aPerformance, aPlay);
    default:
      throw new Error(`알 수 없는 장르: ${aPlay.type}`);
  }
}

class PerformanceCalculator {
  constructor(aPerformance, aPlay) {  
    this.performance = aPerformance;
    this.play = aPlay;
  }

  get amount() {
-   let result = 0;
-   switch(this.play.type) {
-     case "tragedy": // 비극
-       throw "오류 발생";
-     case "comedy": // 희극
-       throw "오류 발생";
-     default:
-       throw new Error(`알 수 없는 장르: ${this.play.type}`);
-   }
-   return result;
+   throw new Error('서브클래스에서 처리하도록 설계되었습니다.');
  }

  get volumeCredits() {
    let result = 0;
    result += Math.max(this.performance.audience - 30, 0);
    if ("comedy" === this.play.type) result += Math.floor(this.performance.audience / 5);
    return result;
  }
}

class TragedyCalculator extends PerformanceCalculator {
  get amount() {
    let result = 40000;
    if (this.performance.audience > 30) {  
      result += 1000 * (this.performance.audience - 30);
    }
    return result;
  }
}

class ComedyCalculator extends PerformanceCalculator {
  get amount() {
    let result = 30000;
    if (this.performance.audience > 20) {  
      result += 10000 + 500 * (this.performance.audience - 30);
    }
    result += 300 * aPerformance.audience;
    return result;
  }
}
```
#### STEP 13
다음으로 교체할 조건부 로직은 적립 포인트를 계산하는 부분이다. 향후 제공할 가능성이 있는 연극 장르들을 검토한 결과, 일부 장르에서만 약간씩 다를 뿐 대다수의 연극은 관객수가 30을 넘는지를 검사해야 한다. 이럴 때는 일반적인 경우를 기본으로 삼아 슈퍼클래스에 남겨두고, 장르마다 달라지는 부분은 필요할 때 오버라이드하게 만드는 것이 좋다. 그래서 포인트 계산 방식이 조금 다른 희극 처리 로직을 해당 서브클래스로 내린다.
``` diff
// createStatementData.js
export default function createStatementData(invoice, plays) {
  const result = {};
  result.customer = invoice.customer;
  result.performances = invoice.performances.map(enrichPerformace);
  result.totalAmount = totalAmount(result);
  result.totalVolumeCredits = totalVolumeCredits(result);
  return result;

  function enrichPerformace(aPerformance) {
    const calculator = createPerformaceCalculator(aPerformance, playFor(aPerformance));
    const result = Object.assign({}, aPerformance);
    result.play = calculator.play;
    result.amount = calculator.amount;
    result.volumeCredits = calculator.volumeCredits;
    return result;
  }

  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }

  function amountFor(aPerformance) {
    return new PerformanceCalculator(aPerformance, playFor(aPerformance)).amount;
  }

  function volumeCreditsFor(aPerformance) {  
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
    if ("comedy" === aPerformance.play.type) result += Math.floor(aPerformance.audience / 5);
    return result;
  }

  function totalAmount(data) {
    return data.performances.reduce((total, p) => total + p.amount, 0);
  }

  function totalVolumeCredits(data) {
    return data.performances.reduce((total, p) => total + p.volumeCredits, 0);
  }
}

// 최상위
function createPerformaceCalculator(aPerformance, aPlay) {
  switch(aPlay.type) {
    case "tragedy": return new TragedyCalculator(aPerformance, aPlay);
    case "comedy": return new ComedyCalculator(aPerformance, aPlay);
    default:
      throw new Error(`알 수 없는 장르: ${aPlay.type}`);
  }
}

class PerformanceCalculator {
  constructor(aPerformance, aPlay) {  
    this.performance = aPerformance;
    this.play = aPlay;
  }

  get amount() {
    throw new Error('서브클래스에서 처리하도록 설계되었습니다.');
  }

  get volumeCredits() {
-   let result = 0;
-   result += Math.max(this.performance.audience - 30, 0);
-   if ("comedy" === this.play.type) result += Math.floor(this.performance.audience / 5);
-   return result;
+   return Math.max(this.performance.audience - 30, 0);
  }
}

class TragedyCalculator extends PerformanceCalculator {
  get amount() {
    let result = 40000;
    if (this.performance.audience > 30) {  
      result += 1000 * (this.performance.audience - 30);
    }
    return result;
  }
}

class ComedyCalculator extends PerformanceCalculator {
  get amount() {
    let result = 30000;
    if (this.performance.audience > 20) {  
      result += 10000 + 500 * (this.performance.audience - 30);
    }
    result += 300 * aPerformance.audience;
    return result;
  }

+ get volumeCredits() {
+   return super.volumeCredits + Math.floor(this.performance.audience / 5);
+ }  
}
```