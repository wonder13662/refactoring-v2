### 1.1 자, 시작해보자!
초판에서는 첫 예시로 비디오 대여점에서 영수증을 출력하는 프로그램을 소개했다. 그런데 요즘 독자는 비디오 대여점이 뭔지 모를 수도 있겠다는 생각이 들어서, 기본 틀은 유지하되 지금 시대에 맞게 각색하기로 했다.

다양한 연극을 외주로 받아서 공연하는 극단이 있다고 생각해보자. 공연 요청이 들어오면 연극의 장르와 관객 규모를 기초로 비용을 책정한다. 현재 이 극단은 두 가지 장르, 비극(tragedy)과 희극(comedy)만 공연한다. 그리고 공연료와 별개로 포인트(volume credit)를 지급해서 다음번 의뢰 시 공연료를 할인받을 수도 있다. 일종의 충성도 프로그램인 셈이다.

극단은 공연할 연극 정보를 다음과 같이 간단한 JSON 파일에 저장한다.

``` json
// plays.json
{
  "hamlet": {"name": "Hamlet", "type": "tragedy"},
  "as-like": {"name": "As You Like it", "type": "comedy"},
  "othello": {"name": "Othello", "type": "tragedy"},
}
```
공연료 청구서에 들어갈 데이터도 다음과 같이 JSON 파일로 표현한다.
``` json
// invoices.json
[
  {
    "customer": "BigCo",
    "performances": [
      {
        "playID": "hamlet",
        "audience": 55,
      },
      {
        "playID": "as-like",
        "audience": 35,
      },
      {
        "playID": "othello",
        "audience": 40,
      },
    ]
  }
]
```
공연료 청구서를 출력하는 코드는 다음과 같이 간단히 함수로 구현했다.
``` javascript
function statement(invoice, plays) {
  let totalAmount = 0;
  let volumeCredits = 0;
  let result = `청구 내역 (고객명: ${invoice.customer})\n`;
  const format = new Intl.NumberFormat("en-US", {
    style: "currency", 
    currency: "USD",
    minimumFractionDigits: 2,
  }).format;

  for (let perf of invoice.performances) {
    const play = plays[perf.playID];
    let thisAmount = 0;

    switch(play.type) {
      case "tragedy": // 비극
        thisAmount = 40000;
        if (perf.audience > 30) {
          thisAmount += 1000 * (perf.audience - 30);
        }
        break;
      case "comedy": // 희극
        thisAmount = 30000;
        if (perf.audience > 20) {
          thisAmount += 10000 + 500 * (perf.audience - 30);
        }
        thisAmount += 300 * perf.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${play.type}`);
    }

    // 포인트를 적립한다.
    volumeCredits += Math.max(perf.audience - 30, 0);
    // 희극 관객 5명마다 추가 포인트를 제공한다.
    if ("comedy" === play.type) volumeCredits += Math.floor(perf.audience / 5);

    // 청구 내역을 출력한다.
    result += ` ${play.name}: ${format(thisAmount/100)} (${perf.audience}석)`;
    totalAmount += thisAmount;
  }

  result += `총액: ${format(totalAmount/100)}\n`
  result += `적립 포인트: ${volumeCredits}점\n`
  return result;
}
```
이 코드에 앞의 두 테스트 데이터 파일(plays.json과 invoices.json)을 입력해 실행한 결과는 다음과 같다.
```
청구내역 (고객명: BigCo)
 hamlet: $650.00 (55석)
 As You Like It: $580.00 (35석)
 othello: $500.00 (40석)
총액: $1,730.00
적립 포인트: 47점
```

(참고)이 프로그램을 직접 src 디렉토리에서 구동해 볼 수 있습니다.
``` bash
// 실행해보기
$ node index.js
// 테스트해보기
$ npm run test
```

### 1.2 예시 프로그램을 본 소감
이 프로그램의 설계를 보고 난 소감은 어떤가? 나는 이 상태로도 그럭저럭 쓸만하다는 생각이 든다. 프로그램이 너무 짧아서 특별히 애써 이해해야 할 구조도 없다. 앞에서 설명했듯이 이 책에서는 이처럼 짧은 예만 소개한다. 하지만 이런 코드가 수백 줄짜리 프로그램의 일부라면 간단한 인라인 함수 하나라도 이해하기 쉽지 않다.

프로그램이 잘 작동하는 상황에서 그저 코드가 '지저분하다'는 이유로 불평하는 것은 프로그램의 구조를 너무 미적인 기준으로만 판단하는 건 아닐까? 컴파일러는 코드가 깔끔하든 지저분하든 개의치 않으니 말이다. 하지만 그 코드를 수정하려면 사람이 개입되고, 사람은 코드의 미적 상태에 민감하다. 설계가 나쁜 시스템은 수정하기 어렵다. 원하는 동작을 수행하도록 하기 위해 수정해야 할 부분을 찾고, 기존 코드와 잘 맞물려 작동하게 할 방법을 강구하기가 어렵기 때문이다. 무엇을 수정할지 찾기 어렵다면 실수를 저질러서 버그가 생길 가능성도 높아진다.

그래서 나는 수백 줄짜리 코드를 수정할 때면 먼저 프로그램의 작동 방식을 더 쉽게 파악할 수 있도록 코드를 여러 함수와 프로그램 요소로 재구성한다. 프로그램의 구조가 빈약하다면 대체로 구조부터 바로잡은 뒤에 기능을 수정하는 편이 작업하기가 훨씬 수월할다.

> 프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서 원하는 기능을 추가한다.

자, 이 코드에서 사용자의 입맛에 맞게 수정할 부분을 몇 개 발견했다. 가장 먼저 청구 내역을 HTML로 출력하는 기능이 필요하다. 이 변경이 어느 부분에 영향을 줄지 생각해보자. 우선(HTML 태그를 삽입해야 하니) 청구 결과에 문자열을 추가하는 문장 각각을 조건문으로 감싸야한다. 그러면 `statement()` 함수의 복잡도가 크게 증가한다. 이런 상황이라면 대부분 이 함수의 복사본을 만들고 복사본에서 HTML을 출력하는 식으로 처리할 것이다.이때 복사하는 일 자체는 그리 부담되지 않지만, 나중에 수많은 문제를 일으킬 여지가 있다. 청구서 작성 로직을 변경할 때마다 기존 함수와 HTML 버전 함수 모두를 수정하고, 항시 일관되게 수정했는지도 확인해야 한다. 로직을 변경할 일이 절대 없다면 이렇게 복사해서 붙이는 방식도 상관없지만, 오래 사용할 프로그램이라면 중복 코드는 골칫거리가 된다.

이는 두 번째 변경 사항과도 관련이 있다. 배우들은 사극, 전원극, 전원 희극, 역사 전원극, 역사 비극, 희비 역사 전원극, 장면 변화가 없는 고전극, 길이와 시간과 장소에 제약 없는 자유극 등 더 많은 장르를 연기하고 싶어 한다. 언제 어떤 연극을 할지는 아직 결정하지 못했지만, 이 변경은 공연료와 적립 포인트 계산법에 영향을 줄 것이다. 경험 많은 개발자로서 내가 장담하건데, 어떤 방식으로 정하든 반드시 6개월 안에 다시 변경하게 될 것이다. 새로운 요구사항은 수색 대원처럼 한두 명씩이 아니라, 한 부대씩 몰려오기 마련이다.

이처럼 연극 장르와 공연료 정책이 달라질 때마다 `statement()` 함수를 수정해야 한다. 만약 `statement()`를 복사해서 별도의 `htmlStatement()`를 만든다면 모든 수정이 두 함수에 일관되게 반영되도록 보장해야 한다. 게다가 정책이 복잡해질수록 수정할 부분을 찾기 어려워지고 수정 과정에서 실수할 가능성도 커진다.

리팩터링이 필요한 이유는 바로 이러한 변경 때문이다. 잘 작동하고 나중에 변경할 일이 절대 없다면 코드를 현재 상태로 놔둬도 아무런 문제가 없다. 더 다음어두면 물론 좋겠지만, 누군가 코드를 읽지 않는 한 아무런 피해가 없다. 하지만 그러다 다른 사람이 읽고 이해해야 할 일이 생겼는데 로직을 파악하기 어렵다면 뭔가 대책을 마련해야 한다.

### 1.3 리팩터링의 첫 단계
리팩터링의 첫 단계는 항상 똑같다. 리팩터링할 코드 영역을 꼼꼼하게 검사해줄 테스트 코드들부터 마련해야 한다. 리팩터링에서 테스트의 역할은 굉장히 중요하다. 리팩터링 기법들이 버그 발생 여지를 최소화하도록 구성됐다고는 하나 실제 작업은 사람이 수행하기 때문에 언제든지 실수할 수 있다. 프로그램이 클수록 수정 과정에서 예상치 못한 문제가 발생할 가능성이 크다. '디지털 시대의 연약한 자여, 그대 이름은 소프트웨어.'

`statement()` 함수의 테스트는 어떻게 구성하면 될까? 이 함수가 문자열을 반환하므로, 다양한 장르의 공연들로 구성된 공연료 청구서 몇 개를 미리 작성하여 문자열 형태로 준비해둔다. 그런 다음 `statement()`가 반환한 문자열과 준비해둔 정답 문자열을 비교한다. 그리고 테스트 프레임워크를 이용하여 모든 테스트를 단축키 하나로 실행할 수 있도록 설정해둔다. 이 테스트는 몇 초면 끝날 것이며, 나중에 보겠지만 나는 테스트를 수시로 한다.

여기서 중요한 부분은 테스트 결과를 보고하는 빙삭이다. 출력된 문자열이 정답 문자열과 똑같다면 테스트를 통과했다는 의미의 초록불을 켜고, 조금이라도 다르면 실패를 뜻하는 빨간불을 켠다. 즉, 성공/실패를 스스로 판단하는 자가진단 테스트로 만든다. 자가진단 여부는 매우 중요하다. 그렇지 않으면 테스트 결과를 노트에 적어둔 값으로 일일이 눈으로 비교해야 하는데, 속도가 상당히 떨어지게 된다. 최신 테스트 프레임워크는 자가진단 테스트를 작성하고 실행하는데 필요한 모든 기능을 제공한다.

> 리팩터링하기 전에 제대로 된 테스트부터 마련한다. 테스트는 반드시 자가진단하도록 만든다.

나는 리팩터링 시 테스트에 상당히 의지한다. 내가 저지른 실수로부터 보호해주는 버그 검출기 역할을 해주기 때문이다. 원하는 내용을 소스 코드와 테스트 코드 양쪽에 적어두면, 두 번 똑같이 실수하지 않는 한 버그 검출기에 반드시 걸린다. 이와 같은 중복 검사로 실수 가능성을 크게 줄일 수 있다. 테스트를 작성하는데 시간이 좀 걸리지만, 신경 써서 만들어두면 디버깅 시간이 줄어서 전체 작업 시간은 오히려 단축된다. 리팩터링에서 테스트의 역할이 굉장히 중요하기 때문에 4장 전체를 테스트에 할애했다.

### 1.4 statement() 함수 쪼개기
`statement()`처럼 긴 함수를 리팩터링할 때는 먼저 전체 동작을 각각의 부분으로 나눌 수 있는 지점을 찾는다. 그러면 중간 즈음의 switch문이 가장 먼저 눈에 띌 것이다.
``` javascript
function statement(invoice, plays) {
  let totalAmount = 0;
  let volumeCredits = 0;
  let result = `청구 내역 (고객명: ${invoice.customer})\n`;
  const format = new Intl.NumberFormat("en-US", {
    style: "currency", 
    currency: "USD",
    minimumFractionDigits: 2,
  }).format;

  for (let perf of invoice.performances) {
    const play = plays[perf.playID];
    let thisAmount = 0;

    switch(play.type) { // <- 이 switch 문에 주목!
      case "tragedy": // 비극
        thisAmount = 40000;
        if (perf.audience > 30) {
          thisAmount += 1000 * (perf.audience - 30);
        }
        break;
      case "comedy": // 희극
        thisAmount = 30000;
        if (perf.audience > 20) {
          thisAmount += 10000 + 500 * (perf.audience - 30);
        }
        thisAmount += 300 * perf.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${play.type}`);
    }

    // 포인트를 적립한다.
    volumeCredits += Math.max(perf.audience - 30, 0);
    // 희극 관객 5명마다 추가 포인트를 제공한다.
    if ("comedy" === play.type) volumeCredits += Math.floor(perf.audience / 5);

    // 청구 내역을 출력한다.
    result += ` ${play.name}: ${format(thisAmount/100)} (${perf.audience}석)`;
    totalAmount += thisAmount;
  }

  result += `총액: ${format(totalAmount/100)}\n`
  result += `적립 포인트: ${volumeCredits}점\n`
  return result;
}
```
이 `switch`문을 살펴보면 한 번의 공연에 대한 요금을 계산하고 있다. 이러한 사실은 코드를 분석해서 얻은 정보다. 워드 커닝햄(Ward Cunningham)이 말하길, 이런 식으로 파악한 정보는 휘발성이 높기로 악명 높은 저장 장치인 내 머릿속에 기록되므로, 잊지 않으려면 재빨리 코드에 반영해야 한다. 그러면 다음번에 코드를 볼 때, 다시 분석하지 않아도 코드 스스로가 자신이 하는 일이 무엇인지 이야기해줄 것이다.
#### STEP 1
여기서는 코드 조각을 별도 함수로 추출하는 방식으로 앞서 파악한 정보를 코드에 반영할 것이다. 추출한 함수에는 그 코드가 하는 일을 설명하는 이름을 지어준다. `amountFor(aPerformance)` 정도면 적당해 보인다. 나는 이렇게 코드 조각을 함수로 추출할 때 실수를 최소화해주는 절차를 마련해뒀다. 이 절차를 따로 기록해두고, 나중에 참조하기 쉽도록 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md)란 이름을 붙였다.

먼저 별도 함수로 빼냈을 때 유효범위를 벗어나는 변수, 즉 새 함수에서는 곧바로 사용할 수 없는 변수가 있는지 확인한다. 이번 예에서는 `perf`, `play`, `thisAmount`가 여기 속한다. `perf`와 `play`는 추출한 새 함수에서도 필요하지만 값을 변경하지 않기 때문에 매개변수로 전달하면 된다. 한편 `thisAmount`는 함수 안에서 값이 바뀌는데, 이런 변수는 조심해서 다뤄야 한다. 이번 예에서는 이런 변수가 하나뿐이므로 이 값을 반환하도록 작성했다. 또한 이 변수를 초기화하는 코드도 추출한 함수에 넣었다. 결과는 다음과 같다.
``` diff
function statement(invoice, plays) {
+ function amountFor(perf, play) { // 값이 바뀌지 않는 변수는 매개변수로 전달
+   let thisAmount = 0; // 변수를 초기화하는 코드
+   switch(play.type) { // <- 이 switch 문에 주목!
+     case "tragedy": // 비극
+       thisAmount = 40000;
+       if (perf.audience > 30) {
+         thisAmount += 1000 * (perf.audience - 30);
+       }
+       break;
+     case "comedy": // 희극
+       thisAmount = 30000;
+       if (perf.audience > 20) {
+         thisAmount += 10000 + 500 * (perf.audience - 30);
+       }
+       thisAmount += 300 * perf.audience;
+       break;
+     default:
+       throw new Error(`알 수 없는 장르: ${play.type}`);
+   }
+   return thisAmount;  // <- 함수 안에서 값이 바뀌는 변수 반환
+ }

  let totalAmount = 0;
  let volumeCredits = 0;
  let result = `청구 내역 (고객명: ${invoice.customer})\n`;
  const format = new Intl.NumberFormat("en-US", {
    style: "currency", 
    currency: "USD",
    minimumFractionDigits: 2,
  }).format;

  for (let perf of invoice.performances) {
    const play = plays[perf.playID];
    let thisAmount = 0;

    switch(play.type) { // <- 이 switch 문에 주목!
      case "tragedy": // 비극
        thisAmount = 40000;
        if (perf.audience > 30) {
          thisAmount += 1000 * (perf.audience - 30);
        }
        break;
      case "comedy": // 희극
        thisAmount = 30000;
        if (perf.audience > 20) {
          thisAmount += 10000 + 500 * (perf.audience - 30);
        }
        thisAmount += 300 * perf.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${play.type}`);
    }

    // 포인트를 적립한다.
    volumeCredits += Math.max(perf.audience - 30, 0);
    // 희극 관객 5명마다 추가 포인트를 제공한다.
    if ("comedy" === play.type) volumeCredits += Math.floor(perf.audience / 5);

    // 청구 내역을 출력한다.
    result += ` ${play.name}: ${format(thisAmount/100)} (${perf.audience}석)`;
    totalAmount += thisAmount;
  }

  result += `총액: ${format(totalAmount/100)}\n`
  result += `적립 포인트: ${volumeCredits}점\n`
  return result;
}
```
> 코드 위에 붙은 'XXX 함수/파일/클래스...' 형태의 머리말은 이어지는 코드가 머리말에서 명시한 이름의 함수/파일/클래스에서 발췌한 것이라는 뜻이다. 따라서 그 함수/파일/클래스의 코드 중에서 당장 설명할 일이 없는 부분은 생략됐을 수 있다.
#### STEP 2
이제 `statement()`에서는 `thisAmount` 값을 채울 때 방금 추출한 `amountFor()` 함수를 호출한다.
``` diff
function statement(invoice, plays) {
  function amountFor(perf, play) { // 값이 바뀌지 않는 변수는 매개변수로 전달
    let thisAmount = 0; // 변수를 초기화하는 코드
    switch(play.type) { // <- 이 switch 문에 주목!
      case "tragedy": // 비극
        thisAmount = 40000;
        if (perf.audience > 30) {
          thisAmount += 1000 * (perf.audience - 30);
        }
        break;
      case "comedy": // 희극
        thisAmount = 30000;
        if (perf.audience > 20) {
          thisAmount += 10000   500 * (perf.audience - 30);
        }
        thisAmount += 300 * perf.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${play.type}`);
    }
    return thisAmount;  // <- 함수 안에서 값이 바뀌는 변수 반환
  }

  let totalAmount = 0;
  let volumeCredits = 0;
  let result = `청구 내역 (고객명: ${invoice.customer})\n`;
  const format = new Intl.NumberFormat("en-US", {
    style: "currency", 
    currency: "USD",
    minimumFractionDigits: 2,
  }).format;

  for (let perf of invoice.performances) {
    const play = plays[perf.playID];
-   let thisAmount = 0;
+   let thisAmount = amountFor(perf, play); // <- 추출한 함수를 이용

-   switch(play.type) { // <- 이 switch 문에 주목!
-     case "tragedy": // 비극
-       thisAmount = 40000;
-       if (perf.audience > 30) {
-         thisAmount += 1000 * (perf.audience - 30);
-       }
-       break;
-     case "comedy": // 희극
-       thisAmount = 30000;
-       if (perf.audience > 20) {
-         thisAmount += 10000 + 500 * (perf.audience - 30);
-       }
-       thisAmount += 300 * perf.audience;
-       break;
-     default:
-       throw new Error(`알 수 없는 장르: ${play.type}`);
-    }

    // 포인트를 적립한다.
    volumeCredits += Math.max(perf.audience - 30, 0);
    // 희극 관객 5명마다 추가 포인트를 제공한다.
    if ("comedy" === play.type) volumeCredits += Math.floor(perf.audience / 5);

    // 청구 내역을 출력한다.
    result += ` ${play.name}: ${format(thisAmount/100)} (${perf.audience}석)`;
    totalAmount += thisAmount;
  }

  result += `총액: ${format(totalAmount/100)}\n`
  result += `적립 포인트: ${volumeCredits}점\n`
  return result;
}
```
이렇게 수정하고 나면 곧바로 컴파일하고 테스트해서 실수한 게 없는지 확인한다. 아무리 간단한 수정이라도 리팩터링 후에는 항상 테스트하는 습관을 들이는 것이 바람직하다. 사람은 실수하기 마련이다. 적어도 내가 겪은 바로는 그렇다. 한 가지를 수정할 때마다 테스트하면, 오류가 생기더라도 변경 폭이 작기 때문에 살펴볼 범위도 좁아서 문제를 찾고 해결하기가 훨씬 쉽다. 이처럼 조금씩 변경하고 매번 테스트하는 것은 리팩터링 절차의 핵심이다. 한 번에 너무 많이 수정하려다 실수를 저지르면 디버깅하기 어려워서 결과적으로 작업 시간이 늘어난다. 조금씩 수정하여 피드백 주기를 짧게 가져가는 습관이 이러한 재앙을 피하는 길이다.

> 여기서 '컴파일'이란 자바스크립트를 실행하는 데 필요한 모든 작업을 의미한다. 사실 자바스크립트는 별도의 컴파일 과정 없이 곧바로 실행시킬 수 있기 때문에 컴파일이란 표현이 맞지 않을 수 있지만, 코드를 `output` 디렉터리로 옮기거나 [바벨](https://babeljs.io/)과 같은 도구를 사용하는 것도 포괄하는 표현으로 사용했다.

> 리팩터링은 프로그램 수정을 작은 단계로 나눠 진행한다. 그래서 중간에 실수하더라도 버그를 쉽게 찾을 수 있다.

지금 예는 자바스크립트 코드이므로 `amountFor()`를 `statement()`의 중첩 함수(nested function)으로 만들 수 있었다.
> 자바스크립트를 포함하여 일부 언어에서는 함수 안에 함수를 정의할 수 있다. 다른 클래스 안에 정의하는 중첩 클래스(내부 클래스)의 함수 버전이라 생각하면 된다. 내부 클래스에서 자원(변수, 메서드 등)에 접근할 수 있듯이, 내부 함수에서도 바깥 함수의 자원(변수, 함수 등)에 접근할 수 있다.

이렇게 하면 바깥 함수에서 쓰던 변수를 새로 추출한 함수에 매개변수로 전달할 필요가 없어서 편하다. 지금 경우에는 달라질 게 없지만 일반적으로 중첩 함수로 만들면 할 일 하나가 줄어드는 셈이다.

방금 수정한 사항을 테스트해보니 문제가 없다. 그래서 다음 단계로 변경 사항을 로컬 버전 관리 시스템에 커밋한다. 나는 깃(git)이나 머큐리얼(mercurial)처럼 개인 커밋(private commit)을 지원하는 버전 관리 시스템을 사용하며, 하나의 리팩터링을 문제없이 끝낼 때마다 커밋한다. 그래야 중간에 문제가 생기더라도 이전의 정상 상태로 쉽게 돌아갈 수 있다. 이렇게 자잘한 변경들이 어느 정도 의미 있는 단위로 뭉쳐지면 공유 저장소로 푸시(push)한다.

[6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md)는 흔히 IDE에서 자동으로 수행해준다. 난 자바로 프로그래밍할 때는 거의 본능적으로 함수 추출 리팩터링에 해당하는 단축키를 누른다. 이 책을 집필할 시점에서는 그 정도로 뛰어난 자바스크립트용 자동 리팩터링 도구가 없었기 때문에 수작업으로 진행했다. 지역 변수의 유효범위 문제만 조심하면 수동으로 해도 어려울 건 없다.

함수를 추출하고 나면 추출된 함수 코드를 자세히 들여다보면서 지금보다 명확하게 표현할 수 있는 간단한 방법은 없는지 검토한다. 가장 먼저 변수의 이름을 더 명확하게 바꿔보자. 가령 `thisAmount`를 `result`로 변경할 수 있다.
``` diff
function statement(invoice, plays) {
  function amountFor(perf, play) { // 값이 바뀌지 않는 변수는 매개변수로 전달
-   let thisAmount = 0; // 변수를 초기화하는 코드
+   let result = 0; // <- 명확한 이름으로 변경
    switch(play.type) { //
      case "tragedy": // 비극
-       thisAmount = 40000;
+       result = 40000;
        if (perf.audience > 30) {
-         thisAmount += 1000 * (perf.audience - 30);
+         result += 1000 * (perf.audience - 30);
        }
        break;
      case "comedy": // 희극
-       thisAmount = 30000;
+       result = 30000;
        if (perf.audience > 20) {
-         thisAmount += 10000   500 * (perf.audience - 30);
+         result += 10000   500 * (perf.audience - 30);
        }
-       thisAmount += 300 * perf.audience;
+       result += 300 * perf.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${play.type}`);
    }
-   return thisAmount;
+   return result;
  }

  let totalAmount = 0;
  let volumeCredits = 0;
  let result = `청구 내역 (고객명: ${invoice.customer})\n`;
  const format = new Intl.NumberFormat("en-US", {
    style: "currency", 
    currency: "USD",
    minimumFractionDigits: 2,
  }).format;

  for (let perf of invoice.performances) {
    const play = plays[perf.playID];
    let thisAmount = amountFor(perf, play);

    // 포인트를 적립한다.
    volumeCredits += Math.max(perf.audience - 30, 0);
    // 희극 관객 5명마다 추가 포인트를 제공한다.
    if ("comedy" === play.type) volumeCredits += Math.floor(perf.audience / 5);

    // 청구 내역을 출력한다.
    result += ` ${play.name}: ${format(thisAmount/100)} (${perf.audience}석)`;
    totalAmount += thisAmount;
  }

  result += `총액: ${format(totalAmount/100)}\n`
  result += `적립 포인트: ${volumeCredits}점\n`
  return result;
}
```
나는 함수의 반환 값에는 항상 `result`라는 이름을 쓴다. 그러면 그 변수의 역할을 쉽게 알 수 있다. 이번에도 마찬가지로 컴파일하고, 테스트하고, 커밋한다.
#### STEP 3
다음은 첫 번째 인수인 `perf`를 `aPerformance`로 리팩터링해보자.
``` diff
function statement(invoice, plays) {
- function amountFor(perf, play) {
+ function amountFor(aPerformance, play) {  
    let result = 0;
    switch(play.type) {
      case "tragedy": // 비극
        result = 40000;
-       if (perf.audience > 30) {
+       if (aPerformance.audience > 30) {  
-         result += 1000 * (perf.audience - 30);
+         result += 1000 * (aPerformance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
-       if (perf.audience > 20) {
+       if (aPerformance.audience > 20) {  
-         result += 10000   500 * (perf.audience - 30);
+         result += 10000   500 * (aPerformance.audience - 30);
        }
-       result += 300 * perf.audience;
+       result += 300 * aPerformance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${play.type}`);
    }
    return result;
  }

  let totalAmount = 0;
  let volumeCredits = 0;
  let result = `청구 내역 (고객명: ${invoice.customer})\n`;
  const format = new Intl.NumberFormat("en-US", {
    style: "currency", 
    currency: "USD",
    minimumFractionDigits: 2,
  }).format;

  for (let perf of invoice.performances) {
    const play = plays[perf.playID];
    let thisAmount = amountFor(perf, play);

    // 포인트를 적립한다.
    volumeCredits += Math.max(perf.audience - 30, 0);
    // 희극 관객 5명마다 추가 포인트를 제공한다.
    if ("comedy" === play.type) volumeCredits += Math.floor(perf.audience / 5);

    // 청구 내역을 출력한다.
    result += ` ${play.name}: ${format(thisAmount/100)} (${perf.audience}석)`;
    totalAmount += thisAmount;
  }

  result += `총액: ${format(totalAmount/100)}\n`
  result += `적립 포인트: ${volumeCredits}점\n`
  return result;
}
```
이번에도 내 코딩 스타일에 따라 처리했다. 자바스크립트와 같은 동적 타입 언어를 사용할 때는 타입이 드러나게 작성하면 도움이 된다. 그래서 나는 매개변수 이름에 접두어로 타입 이름을 적는데, 지금처럼 매개변수의 역할이 뚜렷하지 않을 때는 부정 관사(a/an)를 붙인다. 이 방식은 켄트 벡에게 배웠는데 쓰면 쓸수록 정말 유용한 것 같다([Smalltalk Best Practice Patterns(Addison-Wesley, 1997)](https://www.amazon.com/Smalltalk-Best-Practice-Patterns-Kent/dp/013476904X))

> 컴퓨터가 이해하는 코드는 바보도 작성할 수 있다. 사람이 이해하도록 작성하는 프로그래머가 진정한 실력자다.

이렇게 이름을 바꿀만한 가치가 있을까? 물론이다. 좋은 코드라면 하는 일이 명확히 드러나야 하며, 이때 변수 이름은 커다란 역할을 한다. 그러니 명확성을 높이기 위한 이름 바꾸기에는 조금도 망설이지 말기 바란다. '찾아 바꾸기' 기능을 제공하는 도구를 사용하면 어렵지도 않다. 준비해둔 테스트가 있다면, 그리고 정적 타입 언어를 사용한다면, 여러분이 미처 발견하지 못한 부분까지 찾아줄 것이다. 자동 리팩터링 도구를 사용한다면 호출하는 곳이 아주 많은 함수의 이름도 아주 쉽게 바꿀 수 있다.

#### STEP 4 - play 변수 제거하기
다음으로 `play` 매개변수의 이름을 바꿀 차례다. 그런데 이 변수는 좀 다르게 처리해야 한다. `amountFor()`의 매개변수를 살펴보면서 이 값들이 어디서 오는지 알아봤다. `aPerformance`는 루프 변수에서 오기 때문에 반복문을 한 번 돌때마다 자연스레 값이 변경된다. 하지만 `play`는 개별 공연(`performance`)에서 얻기 때문에 애초에 매개변수로 전달할 필요가 없다. 그냥 `amountFor()`안에서 다시 계산하면 된다. 나는 긴 함수를 잘게 쪼갤 때마다 `play`같은 변수를 최대한 제거한다. 이런 임시 변수들 때문에 로컬 범위에 존재하는 이름이 늘어나서 추출 작업이 복잡해지기 때문이다. 이를 해결해주는 리팩터링으로는 [7.4 임시 변수를 질의 함수로 바꾸기(Replace Temp with Query)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-4.md)가 있다.

먼저 대입문(=)의 우변을 함수로 추출한다.
``` diff
function statement(invoice, plays) {
+ function playFor(aPerformance) {
+   return plays[aPerformance.playID];
+ }
  function amountFor(aPerformance, play) {  
    let result = 0;
    switch(play.type) {
      case "tragedy": // 비극
        result = 40000;
        if (aPerformance.audience > 30) {  
          result += 1000 * (aPerformance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (aPerformance.audience > 20) {  
          result += 10000   500 * (aPerformance.audience - 30);
        }
        result += 300 * aPerformance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${play.type}`);
    }
    return result;
  }

  let totalAmount = 0;
  let volumeCredits = 0;
  let result = `청구 내역 (고객명: ${invoice.customer})\n`;
  const format = new Intl.NumberFormat("en-US", {
    style: "currency", 
    currency: "USD",
    minimumFractionDigits: 2,
  }).format;

  for (let perf of invoice.performances) {
-   const play = plays[perf.playID];
+   const play = playFor(perf);
    let thisAmount = amountFor(perf, play);

    // 포인트를 적립한다.
    volumeCredits += Math.max(perf.audience - 30, 0);
    // 희극 관객 5명마다 추가 포인트를 제공한다.
    if ("comedy" === play.type) volumeCredits += Math.floor(perf.audience / 5);

    // 청구 내역을 출력한다.
    result += ` ${play.name}: ${format(thisAmount/100)} (${perf.audience}석)`;
    totalAmount += thisAmount;
  }

  result += `총액: ${format(totalAmount/100)}\n`
  result += `적립 포인트: ${volumeCredits}점\n`
  return result;
}
```
#### STEP 5
컴파일-테스트-커밋한 다음 [6.4 변수 인라인하기(Inline Variable)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-4.md)를 적용한다.
``` diff
function statement(invoice, plays) {
  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }
  function amountFor(aPerformance, play) {  
    let result = 0;
    switch(play.type) {
      case "tragedy": // 비극
        result = 40000;
        if (aPerformance.audience > 30) {  
          result += 1000 * (aPerformance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (aPerformance.audience > 20) {  
          result += 10000   500 * (aPerformance.audience - 30);
        }
        result += 300 * aPerformance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${play.type}`);
    }
    return result;
  }

  let totalAmount = 0;
  let volumeCredits = 0;
  let result = `청구 내역 (고객명: ${invoice.customer})\n`;
  const format = new Intl.NumberFormat("en-US", {
    style: "currency", 
    currency: "USD",
    minimumFractionDigits: 2,
  }).format;

  for (let perf of invoice.performances) {
-   const play = playFor(perf);
-   let thisAmount = amountFor(perf, play);
+   let thisAmount = amountFor(perf, playFor(perf));

    // 포인트를 적립한다.
    volumeCredits += Math.max(perf.audience - 30, 0);
    // 희극 관객 5명마다 추가 포인트를 제공한다.
-   if ("comedy" === play.type) volumeCredits += Math.floor(perf.audience / 5);
+   if ("comedy" === playFor(perf).type) volumeCredits += Math.floor(perf.audience / 5);

    // 청구 내역을 출력한다.
-   result += ` ${play.name}: ${format(thisAmount/100)} (${perf.audience}석)`;
+   result += ` ${playFor(perf).name}: ${format(thisAmount/100)} (${perf.audience}석)`;
    totalAmount += thisAmount;
  }

  result += `총액: ${format(totalAmount/100)}\n`
  result += `적립 포인트: ${volumeCredits}점\n`
  return result;
}
```
다시 컴파일-테스트-커밋한다.
#### STEP 6
변수를 인라인한 덕분에 `amountFor()`에 [6.5 함수 선언 바꾸기(Change Function Declaration)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-5.md)를 적용해서 `play` 매개변수를 제거할 수 있게 되었다. 이 작업은 두 단계로 진행한다. 먼저 새로 만든 `playFor()`를 사용하도록 `amountFor()`를 수정한다.
``` diff
function statement(invoice, plays) {
  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }
  function amountFor(aPerformance, play) {  
    let result = 0;
-   switch(play.type) {
+   switch(playFor(aPerformance).type) {
      case "tragedy": // 비극
        result = 40000;
        if (aPerformance.audience > 30) {  
          result += 1000 * (aPerformance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (aPerformance.audience > 20) {  
          result += 10000   500 * (aPerformance.audience - 30);
        }
        result += 300 * aPerformance.audience;
        break;
      default:
-       throw new Error(`알 수 없는 장르: ${play.type}`);
+       throw new Error(`알 수 없는 장르: ${playFor(aPerformance).type}`);
    }
    return result;
  }

  let totalAmount = 0;
  let volumeCredits = 0;
  let result = `청구 내역 (고객명: ${invoice.customer})\n`;
  const format = new Intl.NumberFormat("en-US", {
    style: "currency", 
    currency: "USD",
    minimumFractionDigits: 2,
  }).format;

  for (let perf of invoice.performances) {
    let thisAmount = amountFor(perf, playFor(perf));

    // 포인트를 적립한다.
    volumeCredits += Math.max(perf.audience - 30, 0);
    // 희극 관객 5명마다 추가 포인트를 제공한다.
    if ("comedy" === playFor(perf).type) volumeCredits += Math.floor(perf.audience / 5);

    // 청구 내역을 출력한다.
    result += ` ${playFor(perf).name}: ${format(thisAmount/100)} (${perf.audience}석)`;
    totalAmount += thisAmount;
  }

  result += `총액: ${format(totalAmount/100)}\n`
  result += `적립 포인트: ${volumeCredits}점\n`
  return result;
}
```
#### STEP 7
컴파일-테스트-커밋하고 `play` 매개변수를 삭제한다.
``` diff
function statement(invoice, plays) {
  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }
- function amountFor(aPerformance, play) {  
+ function amountFor(aPerformance) {  
    let result = 0;
    switch(playFor(aPerformance).type) {
      case "tragedy": // 비극
        result = 40000;
        if (aPerformance.audience > 30) {  
          result += 1000 * (aPerformance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (aPerformance.audience > 20) {  
          result += 10000   500 * (aPerformance.audience - 30);
        }
        result += 300 * aPerformance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${playFor(aPerformance).type}`);
    }
    return result;
  }

  let totalAmount = 0;
  let volumeCredits = 0;
  let result = `청구 내역 (고객명: ${invoice.customer})\n`;
  const format = new Intl.NumberFormat("en-US", {
    style: "currency", 
    currency: "USD",
    minimumFractionDigits: 2,
  }).format;

  for (let perf of invoice.performances) {
-   let thisAmount = amountFor(perf, playFor(perf));
+   let thisAmount = amountFor(perf);

    // 포인트를 적립한다.
    volumeCredits += Math.max(perf.audience - 30, 0);
    // 희극 관객 5명마다 추가 포인트를 제공한다.
    if ("comedy" === playFor(perf).type) volumeCredits += Math.floor(perf.audience / 5);

    // 청구 내역을 출력한다.
    result += ` ${playFor(perf).name}: ${format(thisAmount/100)} (${perf.audience}석)`;
    totalAmount += thisAmount;
  }

  result += `총액: ${format(totalAmount/100)}\n`
  result += `적립 포인트: ${volumeCredits}점\n`
  return result;
}
```
다시 한번 컴파일-테스트-커밋한다.
#### STEP 8
방금 수행한 리팩터링에서 주목할 점이 몇 가지 있다. 이전 코드는 루프를 한 번 돌 때마다 공연을 조회했는데 반해 리팩터링한 코드에서는 세 번이나 조회한다. 뒤에서 리팩터링과 성능의 관계를 자세히 설명하겠지만, 일단 지금 확인한 바로는 이렇게 변경해도 성능에 큰 영향은 없다. 설사 심각하게 느려지더라도 제대로 리팩터링된 코드베이스는 그렇지 않은 코드보다 성능을 개선하기가 훨씬 수월하다.

지역 변수를 제거해서 얻는 가장 큰 장점은 추출 작업이 훨씬 쉬워진다는 것이다. 유효범위를 신경 써야 할 대상이 줄어들기 때문이다. 실제로 나는 추출 작업 전에는 거의 항상 지역 변수부터 제거한다.

`amountFor()`에 전달할 인수를 모두 처리했으니, 이 함수를 호출하는 코드로 돌아가보자. 여기서 `amountFor()`는 임시 변수인 `thisAmount`에 값을 설정하는 데 사용되는데, 그 값이 다시 바뀌지 않는다. 따라서 [6.4 변수 인라인하기(Inline Variable)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-4.md)를 적용한다.
``` diff
function statement(invoice, plays) {
  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }
  function amountFor(aPerformance) {  
    let result = 0;
    switch(playFor(aPerformance).type) {
      case "tragedy": // 비극
        result = 40000;
        if (aPerformance.audience > 30) {  
          result += 1000 * (aPerformance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (aPerformance.audience > 20) {  
          result += 10000   500 * (aPerformance.audience - 30);
        }
        result += 300 * aPerformance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${playFor(aPerformance).type}`);
    }
    return result;
  }

  let totalAmount = 0;
  let volumeCredits = 0;
  let result = `청구 내역 (고객명: ${invoice.customer})\n`;
  const format = new Intl.NumberFormat("en-US", {
    style: "currency", 
    currency: "USD",
    minimumFractionDigits: 2,
  }).format;

  for (let perf of invoice.performances) {
-   let thisAmount = amountFor(perf);

    // 포인트를 적립한다.
    volumeCredits += Math.max(perf.audience - 30, 0);
    // 희극 관객 5명마다 추가 포인트를 제공한다.
    if ("comedy" === playFor(perf).type) volumeCredits += Math.floor(perf.audience / 5);

    // 청구 내역을 출력한다.
-   result += ` ${playFor(perf).name}: ${format(thisAmount/100)} (${perf.audience}석)`;
+   result += ` ${playFor(perf).name}: ${format(amountFor(perf)/100)} (${perf.audience}석)`;
-   totalAmount += thisAmount;
+   totalAmount += amountFor(perf);
  }

  result += `총액: ${format(totalAmount/100)}\n`
  result += `적립 포인트: ${volumeCredits}점\n`
  return result;
}
```
#### STEP 9 - 적립포인트 계산코드 추출하기
지금까지 `statement()` 함수를 리팩터링한 결과는 다음과 같다.
``` javascript
function statement(invoice, plays) {
  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }
  function amountFor(aPerformance) {  
    let result = 0;
    switch(playFor(aPerformance).type) {
      case "tragedy": // 비극
        result = 40000;
        if (aPerformance.audience > 30) {  
          result += 1000 * (aPerformance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (aPerformance.audience > 20) {  
          result += 10000   500 * (aPerformance.audience - 30);
        }
        result += 300 * aPerformance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${playFor(aPerformance).type}`);
    }
    return result;
  }

  let totalAmount = 0;
  let volumeCredits = 0;
  let result = `청구 내역 (고객명: ${invoice.customer})\n`;
  const format = new Intl.NumberFormat("en-US", {
    style: "currency", 
    currency: "USD",
    minimumFractionDigits: 2,
  }).format;

  for (let perf of invoice.performances) {
    // 포인트를 적립한다.
    volumeCredits += Math.max(perf.audience - 30, 0);
    // 희극 관객 5명마다 추가 포인트를 제공한다.
    if ("comedy" === playFor(perf).type) volumeCredits += Math.floor(perf.audience / 5);

    // 청구 내역을 출력한다.
    result += ` ${playFor(perf).name}: ${format(amountFor(perf)/100)} (${perf.audience}석)`;
    totalAmount += amountFor(perf);
  }

  result += `총액: ${format(totalAmount/100)}\n`
  result += `적립 포인트: ${volumeCredits}점\n`
  return result;
}
```
앞에서 `play` 변수를 제거한 결과 로컬 유효범위의 변수가 하나 줄어서 적립 포인트 계산 부분을 추출하기가 훨씬 쉬워졌다.

처리해야 할 변수가 아직 두 개 더 남아 있다. 여기서도 `perf`는 간단히 전달만 하면 된다. 하지만 `volumeCredits`는 반복문을 돌 때마다 값을 누적해야 하기 때문에 살짝 더 까다롭다. 이 상황에서 최선의 방법은 추출한 함수에서 `volumeCredits`의 복제본을 초기화한 뒤 계산 결과를 반환토록 하는 것이다.
``` diff
function statement(invoice, plays) {
+ function volumeCreditsFor(perf) {
+   let volumeCredits = 0;
+   volumeCredits += Math.max(perf.audience - 30, 0);
+   if ("comedy" === playFor(perf).type) volumeCredits += Math.floor(perf.audience / 5);
+   return volumeCredits;
+ }
  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }
  function amountFor(aPerformance) {  
    let result = 0;
    switch(playFor(aPerformance).type) {
      case "tragedy": // 비극
        result = 40000;
        if (aPerformance.audience > 30) {  
          result += 1000 * (aPerformance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (aPerformance.audience > 20) {  
          result += 10000   500 * (aPerformance.audience - 30);
        }
        result += 300 * aPerformance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${playFor(aPerformance).type}`);
    }
    return result;
  }

  let totalAmount = 0;
  let volumeCredits = 0;
  let result = `청구 내역 (고객명: ${invoice.customer})\n`;
  const format = new Intl.NumberFormat("en-US", {
    style: "currency", 
    currency: "USD",
    minimumFractionDigits: 2,
  }).format;

  for (let perf of invoice.performances) {
-   // 포인트를 적립한다.
-   volumeCredits += Math.max(perf.audience - 30, 0);
+   volumeCredits += volumeCreditsFor(perf);
-   // 희극 관객 5명마다 추가 포인트를 제공한다.
-   if ("comedy" === playFor(perf).type) volumeCredits += Math.floor(perf.audience / 5);

    // 청구 내역을 출력한다.
    result += ` ${playFor(perf).name}: ${format(amountFor(perf)/100)} (${perf.audience}석)`;
    totalAmount += amountFor(perf);
  }

  result += `총액: ${format(totalAmount/100)}\n`
  result += `적립 포인트: ${volumeCredits}점\n`
  return result;
}
```
필요없어진 주석 두 문장은 지웠다(남겨두면 오히려 오해의 소지가 있다).
#### STEP 10
컴파일-테스트-커밋한 다음, 새로 추출한 함수에서 쓰이는 변수들 이름을 적절히 바꾼다.
``` diff
function statement(invoice, plays) {
- function volumeCreditsFor(perf) {
+ function volumeCreditsFor(aPerformance) {  
-   let volumeCredits = 0;
+   let result = 0;
-   volumeCredits += Math.max(perf.audience - 30, 0);
+   result += Math.max(aPerformance.audience - 30, 0);
-   if ("comedy" === playFor(perf).type) volumeCredits += Math.floor(perf.audience / 5);
+   if ("comedy" === playFor(aPerformance).type) volumeCredits += Math.floor(aPerformance.audience / 5);
-   return volumeCredits;
+   return result;
  }
  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }
  function amountFor(aPerformance) {  
    let result = 0;
    switch(playFor(aPerformance).type) {
      case "tragedy": // 비극
        result = 40000;
        if (aPerformance.audience > 30) {  
          result += 1000 * (aPerformance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (aPerformance.audience > 20) {  
          result += 10000   500 * (aPerformance.audience - 30);
        }
        result += 300 * aPerformance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${playFor(aPerformance).type}`);
    }
    return result;
  }

  let totalAmount = 0;
  let volumeCredits = 0;
  let result = `청구 내역 (고객명: ${invoice.customer})\n`;
  const format = new Intl.NumberFormat("en-US", {
    style: "currency", 
    currency: "USD",
    minimumFractionDigits: 2,
  }).format;

  for (let perf of invoice.performances) {
    volumeCredits += volumeCreditsFor(perf);

    // 청구 내역을 출력한다.
    result += ` ${playFor(perf).name}: ${format(amountFor(perf)/100)} (${perf.audience}석)`;
    totalAmount += amountFor(perf);
  }

  result += `총액: ${format(totalAmount/100)}\n`
  result += `적립 포인트: ${volumeCredits}점\n`
  return result;
}
```
이상의 작업을 하나의 단계처럼 표현했지만, 실제로는 앞에서와 마찬가지로 변수 이름을 하나씩 바꿀 때마다 컴파일-테스트-커밋했다.
#### STEP 11 - format 변수 제거하기
다시 최상위 코드인 `statement()`를 살펴보자.
``` javascript
function statement(invoice, plays) {
  let totalAmount = 0;
  let volumeCredits = 0;
  let result = `청구 내역 (고객명: ${invoice.customer})\n`;
  const format = new Intl.NumberFormat("en-US", {
    style: "currency", 
    currency: "USD",
    minimumFractionDigits: 2,
  }).format;

  for (let perf of invoice.performances) {
    volumeCredits += volumeCreditsFor(perf);

    // 청구 내역을 출력한다.
    result += ` ${playFor(perf).name}: ${format(amountFor(perf)/100)} (${perf.audience}석)`;
    totalAmount += amountFor(perf);
  }

  result += `총액: ${format(totalAmount/100)}\n`
  result += `적립 포인트: ${volumeCredits}점\n`
  return result;
}  
```
앞에서 설명했듯이 임시 변수는 나중에 문제를 일으킬 수 있다. 임시 변수는 자신이 속한 루틴에서만 의미가 있어서 루틴이 길고 복잡해지기 쉽다. 따라서 다음으로 할 리팩터링은 이런 변수들을 제거하는 것이다. 그 중에서 `format`이 가장 만만해 보인다. `format`은 임시 변수에 (함수 포인터처럼) 함수를 대입한 형태인데, 나는 함수를 직접 선언해 사용하도록 바꾸는 편이다.
``` diff
function statement(invoice, plays) {
+ function format(aNumber) {
+   return new Intl.NumberFormat("en-US", {
+     style: "currency", 
+     currency: "USD",
+     minimumFractionDigits: 2,
+   }).format(aNumber);
+ }
  function volumeCreditsFor(aPerformance) {  
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
    if ("comedy" === playFor(aPerformance).type) volumeCredits += Math.floor(aPerformance.audience / 5);
    return result;
  }
  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }
  function amountFor(aPerformance) {  
    let result = 0;
    switch(playFor(aPerformance).type) {
      case "tragedy": // 비극
        result = 40000;
        if (aPerformance.audience > 30) {  
          result += 1000 * (aPerformance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (aPerformance.audience > 20) {  
          result += 10000   500 * (aPerformance.audience - 30);
        }
        result += 300 * aPerformance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${playFor(aPerformance).type}`);
    }
    return result;
  }

  let totalAmount = 0;
  let volumeCredits = 0;
  let result = `청구 내역 (고객명: ${invoice.customer})\n`;
- const format = new Intl.NumberFormat("en-US", {
-   style: "currency", 
-   currency: "USD",
-   minimumFractionDigits: 2,
- }).format;

  for (let perf of invoice.performances) {
    volumeCredits += volumeCreditsFor(perf);

    // 청구 내역을 출력한다.
    result += ` ${playFor(perf).name}: ${format(amountFor(perf)/100)} (${perf.audience}석)`;
    totalAmount += amountFor(perf);
  }

  result += `총액: ${format(totalAmount/100)}\n`
  result += `적립 포인트: ${volumeCredits}점\n`
  return result;
}
```

> 이처럼 함수 변수를 일반 함수로 변경하는 것도 리팩터링이지만, 따로 이름을 붙여 리팩터링 목록에 넣지는 않았다. 굉장히 간단한 데다 드물게 쓰여서 그리 중요하지 않다고 판단했기 때문이다. 이처럼 따로 구분할 만큼 중요하지 않는 리팩터링 기법은 이 외에도 많이 있다.

#### STEP 12
그런데 이름이 마음에 걸린다. "format"은 이 함수가 하는 일을 충분히 설명해주지 못한다. 템플릿 문자열 안에서 사용될 이름이라서 "formatAsUSD"라고 하기에는 또 너무 장황하다(특히 지금처럼 가시 범위가 좁다면 더더욱 맞지 않다). 이 함수의 핵심은 화폐 단위 맞추기다. 그래서 그런 느낌을 살리는 이름을 골라서 다음과 같이 [6.5 함수 선언 바꾸기(Change Function Declaration)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-5.md)를 적용했다.
``` diff
function statement(invoice, plays) {
- function format(aNumber) {
+ function usd(aNumber) {  
    return new Intl.NumberFormat("en-US", {
      style: "currency", 
      currency: "USD",
      minimumFractionDigits: 2,
-   }).format(aNumber);
+   }).format(aNumber/100);
  }
  function volumeCreditsFor(aPerformance) {  
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
    if ("comedy" === playFor(aPerformance).type) volumeCredits += Math.floor(aPerformance.audience / 5);
    return result;
  }
  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }
  function amountFor(aPerformance) {  
    let result = 0;
    switch(playFor(aPerformance).type) {
      case "tragedy": // 비극
        result = 40000;
        if (aPerformance.audience > 30) {  
          result += 1000 * (aPerformance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (aPerformance.audience > 20) {  
          result += 10000   500 * (aPerformance.audience - 30);
        }
        result += 300 * aPerformance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${playFor(aPerformance).type}`);
    }
    return result;
  }

  let totalAmount = 0;
  let volumeCredits = 0;
  let result = `청구 내역 (고객명: ${invoice.customer})\n`;

  for (let perf of invoice.performances) {
    volumeCredits += volumeCreditsFor(perf);

    // 청구 내역을 출력한다.
-   result += ` ${playFor(perf).name}: ${format(amountFor(perf)/100)} (${perf.audience}석)`;
+   result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)`;
    totalAmount += amountFor(perf);
  }

- result += `총액: ${format(totalAmount/100)}\n`
+ result += `총액: ${usd(totalAmount)}\n`
  result += `적립 포인트: ${volumeCredits}점\n`
  return result;
}
```
이름짓기는 중요하면서도 쉽지 않은 작업이다. 긴 함수를 작게 쪼개는 리팩터링은 일므을 잘 지어야만 효과가 있다. 이름이 좋으면 함수 본문을 읽지 않고도 무슨 일을 하는지 알 수 있다. 물론 단번에 좋은 이름을 짓기는 쉽지 않다. 따라서 처음에는 당장 떠오르는 최선의 이름을 사용하다가, 나중에 더 좋은 이름이 떠오를 때 바꾸는 식이 좋다. 흔히 코드를 두 번 이상 읽고 나서야 가장 적합한 이름이 떠오르곤 한다.

앞서 이름을 바꿀 때, 여러 차례 등장하는 100으로 나누는 코드도 추출한 함수로 옮겼다. 미국에서는 금액을 흔히 센트 단위의 정수로 저장한다. 그래야 달러 미만을 표현할 때 부동소수점을 사용하지 않아도 되고 산술 연산도 쉽게 처리할 수 있다. 하지만 화면에 출력할 때는 다시 달러 단위로 변환해야 하므로 포맷 변환 함수인 `usd()`에서 나눗셈까지 처리해주면 좋다.

#### STEP 13 - volumeCredits 변수 제거하기
다음으로 살펴볼 변수는 `volumeCredits`다. 이 변수는 반복문을 한 바퀴 돌 때마다 값을 누적하기 때문에 리팩터링을 하기가 더 까다롭다. 따라서 먼저 [8.7 반복문 쪼개기(Split loop)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-7.md)로 `volumeCredits` 값이 누적되는 부분을 따로 빼낸다.
``` diff
function statement(invoice, plays) {
  function usd(aNumber) {  
    return new Intl.NumberFormat("en-US", {
      style: "currency", 
      currency: "USD",
      minimumFractionDigits: 2,
    }).format(aNumber/100);
  }
  function volumeCreditsFor(aPerformance) {  
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
    if ("comedy" === playFor(aPerformance).type) volumeCredits += Math.floor(aPerformance.audience / 5);
    return result;
  }
  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }
  function amountFor(aPerformance) {  
    let result = 0;
    switch(playFor(aPerformance).type) {
      case "tragedy": // 비극
        result = 40000;
        if (aPerformance.audience > 30) {  
          result += 1000 * (aPerformance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (aPerformance.audience > 20) {  
          result += 10000   500 * (aPerformance.audience - 30);
        }
        result += 300 * aPerformance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${playFor(aPerformance).type}`);
    }
    return result;
  }

  let totalAmount = 0;
  let volumeCredits = 0;
  let result = `청구 내역 (고객명: ${invoice.customer})\n`;

  for (let perf of invoice.performances) {
-   volumeCredits += volumeCreditsFor(perf);

    // 청구 내역을 출력한다.
    result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)`;
    totalAmount += amountFor(perf);
  }
+ for (let perf of invoice.performances) {
+   volumeCredits += volumeCreditsFor(perf);  
+ }

  result += `총액: ${usd(totalAmount)}\n`
  result += `적립 포인트: ${volumeCredits}점\n`
  return result;
}
```
#### STEP 14
이어서 [8.6 문장 슬라이드하기(Slide Statements)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-6.md)를 적용해서 `volumeCredits` 변수를 선언하는 문장을 반복문 바로 앞으로 옮긴다.
``` diff
function statement(invoice, plays) {
  function usd(aNumber) {  
    return new Intl.NumberFormat("en-US", {
      style: "currency", 
      currency: "USD",
      minimumFractionDigits: 2,
    }).format(aNumber/100);
  }
  function volumeCreditsFor(aPerformance) {  
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
    if ("comedy" === playFor(aPerformance).type) volumeCredits += Math.floor(aPerformance.audience / 5);
    return result;
  }
  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }
  function amountFor(aPerformance) {  
    let result = 0;
    switch(playFor(aPerformance).type) {
      case "tragedy": // 비극
        result = 40000;
        if (aPerformance.audience > 30) {  
          result += 1000 * (aPerformance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (aPerformance.audience > 20) {  
          result += 10000   500 * (aPerformance.audience - 30);
        }
        result += 300 * aPerformance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${playFor(aPerformance).type}`);
    }
    return result;
  }

  let totalAmount = 0;
- let volumeCredits = 0;
  let result = `청구 내역 (고객명: ${invoice.customer})\n`;

  for (let perf of invoice.performances) {
    // 청구 내역을 출력한다.
    result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)`;
    totalAmount += amountFor(perf);
  }
+ let volumeCredits = 0;  
  for (let perf of invoice.performances) {
    volumeCredits += volumeCreditsFor(perf);  
  }

  result += `총액: ${usd(totalAmount)}\n`
  result += `적립 포인트: ${volumeCredits}점\n`
  return result;
}
```
#### STEP 15
`volumeCredits` 값 갱신과 관련한 문장들을 한데 모아두면 [7.4 임시 변수를 질의 함수로 바꾸기(Replace Temp with Query)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-4.md)가 수월해진다. 이번에도 역시 `volumeCredits` 값 계산 코드를 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md)하는 작업부터 한다.
``` diff
function statement(invoice, plays) {
+ function totalVolumeCredits() {
+   let volumeCredits = 0;
+   for (let perf of invoice.performances) {
+     volumeCredits += volumeCreditsFor(perf);
+   }
+   return volumeCredits;
+ }
  function usd(aNumber) {  
    return new Intl.NumberFormat("en-US", {
      style: "currency", 
      currency: "USD",
      minimumFractionDigits: 2,
    }).format(aNumber/100);
  }
  function volumeCreditsFor(aPerformance) {  
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
    if ("comedy" === playFor(aPerformance).type) volumeCredits += Math.floor(aPerformance.audience / 5);
    return result;
  }
  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }
  function amountFor(aPerformance) {  
    let result = 0;
    switch(playFor(aPerformance).type) {
      case "tragedy": // 비극
        result = 40000;
        if (aPerformance.audience > 30) {  
          result += 1000 * (aPerformance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (aPerformance.audience > 20) {  
          result += 10000   500 * (aPerformance.audience - 30);
        }
        result += 300 * aPerformance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${playFor(aPerformance).type}`);
    }
    return result;
  }

  let totalAmount = 0;
  let result = `청구 내역 (고객명: ${invoice.customer})\n`;

  for (let perf of invoice.performances) {
    // 청구 내역을 출력한다.
    result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)`;
    totalAmount += amountFor(perf);
  }
- let volumeCredits = 0;
+ let volumeCredits = totalVolumeCredits();
- for (let perf of invoice.performances) {
-   volumeCredits += volumeCreditsFor(perf);  
- }

  result += `총액: ${usd(totalAmount)}\n`
  result += `적립 포인트: ${volumeCredits}점\n`
  return result;
}
```
#### STEP 16
함수 추출이 끝났다면, 다음은 `volumeCredits`을 [6.4 변수 인라인하기(Inline Variable)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-4.md)할 차례다.
``` diff
function statement(invoice, plays) {
  function totalVolumeCredits() {
    let volumeCredits = 0;
    for (let perf of invoice.performances) {
      volumeCredits += volumeCreditsFor(perf);
    }
    return volumeCredits;
  }
  function usd(aNumber) {  
    return new Intl.NumberFormat("en-US", {
      style: "currency", 
      currency: "USD",
      minimumFractionDigits: 2,
    }).format(aNumber/100);
  }
  function volumeCreditsFor(aPerformance) {  
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
    if ("comedy" === playFor(aPerformance).type) volumeCredits += Math.floor(aPerformance.audience / 5);
    return result;
  }
  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }
  function amountFor(aPerformance) {  
    let result = 0;
    switch(playFor(aPerformance).type) {
      case "tragedy": // 비극
        result = 40000;
        if (aPerformance.audience > 30) {  
          result += 1000 * (aPerformance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (aPerformance.audience > 20) {  
          result += 10000   500 * (aPerformance.audience - 30);
        }
        result += 300 * aPerformance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${playFor(aPerformance).type}`);
    }
    return result;
  }

  let totalAmount = 0;
  let result = `청구 내역 (고객명: ${invoice.customer})\n`;

  for (let perf of invoice.performances) {
    // 청구 내역을 출력한다.
    result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)`;
    totalAmount += amountFor(perf);
  }
- let volumeCredits = totalVolumeCredits();

  result += `총액: ${usd(totalAmount)}\n`
- result += `적립 포인트: ${volumeCredits}점\n`
+ result += `적립 포인트: ${totalVolumeCredits()}점\n`
  return result;
}
```
여기서 잠시 멈추고 방금 한 일에 대해 생각해보자. 무엇보다도 반복문을 쪼개서 성능이 느려지지 않을까 걱정할 수 있다. 이처럼 반복문이 중복되는 것을 꺼리는 이들이 많지만, 이 정도 중복은 성능에 미치는 영향이 미미할 때가 많다. 실제로 이번 리팩터링 전과 후의 실행시간을 측정해보면 차이를 거의 느끼지 못할 것이다. 경험 많은 프로그래머조차 코드의 실제 성능을 정확히 예측하지 못한다. 똑똑한 컴파일러들은 최신 캐싱 기법 등으로 무장하고 있어서 우리의 직관을 초월하는 결과를 내어주기 때문이다. 또한 소프트웨어 성능은 대체로 코드의 몇몇 작은 부분에 의해 결정되므로 그 외의 부분은 수정한다고 해도 성능 차이를 체감할 수 없다.

하지만 '대체로 그렇다'와 '항상 그렇다'는 엄연히 다르다. 때로는 리팩터링이 성능에 상당한 영향으 주기도 한다. 그런 경우라도 나는 개의치 않고 리팩터링한다. 잘 다듬어진 코드라야 성능 개선 작업도 훨씬 수월하기 때문이다. 리팩터링 과정에서 성능이 크게 떨어졌다면 리팩터링 후 시간을 내어 개선한다. 이 과정에서 리팩터링된 코드를 예전으로 되돌리는 경우도 있지만, 대체로 리팩터링 덕분에 성능 개선을 더 효과적으로 수행할 수 있다. 결과적으로 더 깔끔하면서 더 빠른 코드를 얻게 된다.

따라서 리팩터링으로 인한 성능 문제에 대한 내 조언은 '특별한 경우가 아니라면 일단 무시하라'는 것이다. 리팩터링 때문에 성능이 떨어졌다면, 하던 리팩터링을 마무리하고 나서 성능을 개선하자.

또 하나, `volumeCredits` 변수를 제거하는 작업의 단계를 아주 잘게 나눴다는 점에도 주목하자. 다음과 같이 총 네 단계로 수행했으며, 각 단계마다 컴파일-테스트하고 로컬 저장소에 커밋했다.

1. [8.7 반복문 쪼개기(Split loop)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-7.md)로 변수 값을 누적시키는 부분을 분리한다.