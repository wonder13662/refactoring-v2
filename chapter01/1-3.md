# 1.3 리팩터링의 첫 단계
리팩터링의 첫 단계는 항상 똑같다. 리팩터링할 코드 영역을 꼼꼼하게 검사해줄 테스트 코드들부터 마련해야 한다. 리팩터링에서 테스트의 역할은 굉장히 중요하다. 리팩터링 기법들이 버그 발생 여지를 최소화하도록 구성됐다고는 하나 실제 작업은 사람이 수행하기 때문에 언제든지 실수할 수 있다. 프로그램이 클수록 수정 과정에서 예상치 못한 문제가 발생할 가능성이 크다. '디지털 시대의 연약한 자여, 그대 이름은 소프트웨어.'

`statement()` 함수의 테스트는 어떻게 구성하면 될까? 이 함수가 문자열을 반환하므로, 다양한 장르의 공연들로 구성된 공연료 청구서 몇 개를 미리 작성하여 문자열 형태로 준비해둔다. 그런 다음 `statement()`가 반환한 문자열과 준비해둔 정답 문자열을 비교한다. 그리고 테스트 프레임워크를 이용하여 모든 테스트를 단축키 하나로 실행할 수 있도록 설정해둔다. 이 테스트는 몇 초면 끝날 것이며, 나중에 보겠지만 나는 테스트를 수시로 한다.

여기서 중요한 부분은 테스트 결과를 보고하는 빙삭이다. 출력된 문자열이 정답 문자열과 똑같다면 테스트를 통과했다는 의미의 초록불을 켜고, 조금이라도 다르면 실패를 뜻하는 빨간불을 켠다. 즉, 성공/실패를 스스로 판단하는 자가진단 테스트로 만든다. 자가진단 여부는 매우 중요하다. 그렇지 않으면 테스트 결과를 노트에 적어둔 값으로 일일이 눈으로 비교해야 하는데, 속도가 상당히 떨어지게 된다. 최신 테스트 프레임워크는 자가진단 테스트를 작성하고 실행하는데 필요한 모든 기능을 제공한다.

> 리팩터링하기 전에 제대로 된 테스트부터 마련한다. 테스트는 반드시 자가진단하도록 만든다.

나는 리팩터링 시 테스트에 상당히 의지한다. 내가 저지른 실수로부터 보호해주는 버그 검출기 역할을 해주기 때문이다. 원하는 내용을 소스 코드와 테스트 코드 양쪽에 적어두면, 두 번 똑같이 실수하지 않는 한 버그 검출기에 반드시 걸린다. 이와 같은 중복 검사로 실수 가능성을 크게 줄일 수 있다. 테스트를 작성하는데 시간이 좀 걸리지만, 신경 써서 만들어두면 디버깅 시간이 줄어서 전체 작업 시간은 오히려 단축된다. 리팩터링에서 테스트의 역할이 굉장히 중요하기 때문에 4장 전체를 테스트에 할애했다.

- [목차](https://github.com/wonder13662/refactoring-v2/blob/writing)
- [1 리팩터링: 첫 번째 예시](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter01)
- [1.2 예시 프로그램을 본 소감](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter01/1-2.md)
- [1.4 statement() 함수 쪼개기](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter01/1-4.md)
