### 어플리케이션 실행
```
$ node index.js
```

### 테스트 실행
```
$ npm run test
```

## Chapter 02 리팩터링 원칙
### 2.1 리팩터링 정의
- 리팩터링: `명사` 소프트웨어의 겉보기 동작(Observable behavior)은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법.
- 리팩터링(하다): `동사` 소프트웨어의 겉보기 동작(Observable behavior)은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.
- 누군가 "리팩터링하다가 코드가 깨져서 며칠이나 고생했다"라고 한다면, 십중팔구 리팩터링한 것이 아니다.

### 2.2 두 개의 모자
- 기능 추가
  - 기존 코드는 절대 건드리지 않음
  - 새 기능을 추가함
  - 진척도는 테스트를 추가해서 통과하는지 확인하는 방식으로 측정
- 리팩터링
  - 기능 추가는 절대 하지 않음
  - 코드 재구성에만 전념
  - 테스트도 새로 만들지 않음(앞 과정에서 놓친 테스트 케이스를 발견하면 새로 만듬)
  - 인터페이스를 변경해야 할 때만 기존 테스트 수정
### 2.3 리팩터링하는 이유
- 리팩터링하면 소프트웨어 설계가 좋아진다
- 리팩터링하면 소프트웨어를 이해하기 쉬워진다
- 리팩터링하면 버그를 쉽게 찾을 수 있다
- 리팩터링하면 프로그래밍 속도를 높일 수 있다
### 2.4 언제 리팩터링해야 할까?
#### 3의 법칙
- 처음에는 그냥 한다.
- 비슷한 일을 두 번째로 하게 되면(중복이 생겼다는 사실에 당황스럽겠지만), 일단 계속 진행한다.
- 비슷한 일을 세 번째 하게 되면 리팩터링 한다.
- 스트라이크 세 번이면 리팩터링하라(삼진 리팩터링)
#### 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기
- 리팩터링하기 가장 좋은 시점은 기능을 새로 추가하기 직전
- 구조를 살짝 바꾸면 다른 작업을 하기가 훨씬 쉬워질 만한 부분을 찾는다
#### 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기
- 코드를 수정하려면 그 코드가 하는 일을 파악해야 함 
- 코드를 파악할 때마다 코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지는 없는지 찾아본다
- 리팩터링하면 머리로 이해한 것을 코드로 옮겨 담을 수 있다
- 수정한 코드를 테스트해보면 내 생각이 맞았는지 확인할 수 있다
- 이해한 것을 코드에 반영해두면 더 오래 보존할 수 있을 뿐만 아니라 동료들도 알 수 있다
- 리팩터링하면 코드가 깔끔하게 정리되어 전에는 보이지 않던 설계가 눈에 들어오기 시작한다
#### 쓰레기 줍기 리팩터링(Litter-Pickup Refactoring)
- 작업 중에 비효율적인 코드 발견
- 원래하려던 일과 관련이 없다. 어떻게 하지?
- 간단히 수정할 수 있는 것은 즉시 고침
- 시간이 좀 걸리는 일은 짧은 메모만 남긴 다음, 하던 일을 끝내고 처리한다
#### 계획된 리팩터링과 수시로 하는 리팩터링
- 개발에 들어가기 전에 리팩터링 일정을 따로 잡지 않음
- 기능을 추가하거나 버그를 잡는 동안 리팩터링도 함께 함
- 대부분의 리팩터링을 다른 일을 하는 중에 처리한다
- `의견` 어떤 개발자들은 리팩터링을 하는 업무를 따로 진행하는 경우도 있다. 꼭 필요한 것일까?
- `조언` 무언가 수정하려 할 때는 먼저 수정하기 쉽게 정돈하고(단, 만만치 않을 수 있다) 그럼 다음 쉽게 수정하자 - 켄트 백
- 그동안 리팩터링에 소홀했다면, 따로 시간을 내서 새 기능을 추가히기 쉽도록 코드베이스를 개선할 필요가 있다. 이때 리팩터링에 투자한 일주일의 효과를 다음 몇 달 동안 누릴 수도 있다
- 하지만 이런 이유로 계획된 리팩터링을 하게 되는 일은 최소한으로 줄여야 한다. 리팩터링 작업 대부분은 드러나지 않게, 기회가 될 때마다 해야 한다
#### 오래 걸리는 리팩터링
- 팀 전체가 리팩터링에 매달리는 것은 회의적이다
- 그보다는 주어진 문제를 몇 주에 걸쳐 조금씩 해결해가는 편이 효과적일 때가 많다
- 리팩터링해야 할 코드와 관련한 작업을 하게 될 때마다 원하는 방향으로 조금씩 개선하는 식이다
- 예컨데 라이브러리를 교체할 때는 기존 것과 새 것 모두를 포용하는 추상 인터페이스를 마련한다. 기존 코드가 이 추상 인터페이스를 호출하도록 만들고 나면 라이브러리를 훨씬 쉽게 교체할 수 있다.(이 전략을 추상화로 갈아타기 - Branch By Abstraction)이라고 한다.
#### 코드 리뷰에 리팩터링 활용하기
- 코드 리뷰는 개발팀 전체에 지식을 전파하는데 좋다
  - 경험이 더 많은 개발자의 노하우를 더 적은 개발자에게 전수할 수 있다
  - 시스템의 다양한 측면을 더 많은 사람이 이해하는 데도 도움이 된다
  - 다른 사람의 아이디어를 얻을 수 있다
  - 서로의 기여가 일을 더욱 편하게 만들어 준다
- 리팩터링은 다른 이의 코드를 리뷰하는 데도 도움이 된다
  - 새로운 아이디어가 떠오르면 리팩터링하여 쉽게 구현해 넣을 수 있는 지 살펴본다
  - 쉽다면 실제로 리팩터링한다
  - 이 과정을 반복하면 아이디어를 실제 적용한 모습을 더 명확하게 볼 수 있다. 리팩터링하지 않고는 떠올릴 수 없는 한 차원 높은 아이디어가 떠오르기도 한다
- 코드 리뷰에 리팩토링을 접목하는 방식
  - 풀 요청 모델(Pull Request Model)은 코드 작성자가 바로 참여하지 않아서 효과적이지 않음
  - 짝 프로그래밍(Pair Programming) 방식이 효과적이다
#### 관리자에게는 뭐라고 말해야 할까?
- 관리자와 고객이 "리팩터링은 누적된 오류를 잡는 일이거나, 혹은 가치있는 기능을 만들어내지 못하는 작업"이라고 오해하여 리팩터링이 금지된 조직도 있었음
- 리팩터링만을 위한 일정을 몇 주씩 잡는 개발팀을 보면 오해는 더욱 커짐. 리팩토링이 아난 어설픈 재구성 작업을 하면서 코드베이스를 망가뜨리는 경우도 있음
- 기술을 모르는 상당수의 관리자와 고객이 있다면, "리팩터링한다고 말하지 말라"는 편이 낫다
- 그리고 기능 추가, 버그 수정의 작업에서 관련된 리팩터링 작업을 먼저 수행한 뒤에 작업을 진행한다
#### 리팩터링하지 말아야 할 때
- 지저분한 코드를 발견해도 굳이 수정할 필요가 없다면 그냥 둔다. 외부 API 다루듯 호출해서 쓰는 코드라면 지저분해도 그냥 둔다. 내부 동작을 이해해야 할 시점에 리팩토링해야 효과를 볼 수 있다.
- 리팩터링하는 것보다 새로 작성하는 게 쉬울 때도 리팩터링하지 않는다.(하지만 직접 리팩터링해보기 전에는 어느 쪽이 쉬운지 확실히 알 수 없을 때도 많다)
### 2.5 리팩터링 시 고려할 문제
#### 새 기능 개발 속도 저하
- 예를 들자면, (대대적인) 리팩터링이 필요해 보이지만, 추가하려는 새 기능이 아주 작아서 기능 추가부터 하고 싶은 상황
- 준비를 위한 리팩터링을 하면 변경을 훨씬 쉽게 할 수 있다
- 대부분은 리팩터링을 더 자주 하도록 노력해야 한다
- 개발팀을 이끌고 있다면 코드베이스가 더 건강해지는 것을 추구한다는 사실을 팀원들에게 명확히 밝혀야 함
  - 리팩터링을 할지 말지를 판단하는 능력은 수년에 걸친 경험을 통해 서서히 형성된다
  - 리더는 리팩터링 경험이 부족한 이들이 이런 능력을 빠르게 갖추도록 개발 과정에서 많이 이끌어 줘야 한다
- 리팩터링은 '클린 코드'나 '바람직한 엔지니어링 습관'이 아니다. 개발 기간 단축 - 경제적인 이유로 하는 것이다
#### 코드 소유권
- 코드 소유권이 나뉘어 있으면 리팩터링에 방해가 된다
- 코드 소유권을 팀에 두는 것이 낫다
- 어떤 팀은 다른 팀 사람이 자기 팀 코드를 브랜치를 따서 수정하고 커밋을 요청하는 오픈소스 모델을 권장하기도 함. 대규모 시스템 개발 시 적합
#### 브랜치
- 통합 주기만큼은 최대한 짧게 잡아야 한다
- 머지가 복잡해지는 문제는 기능별 브랜치들이 독립적으로 개발되는 기간이 길어질 수록 기하급수적으로 늘어난다. 4주간 작업한 브랜치들을 통합하는 노력은 2주간 작업한 브랜치들을 통합할 때보다 두 배 이상 든다
- CI(Continuous Integration)에 따르면 모든 팀원이 하루에 최소 한 번은 마스터와 통합한다
- 머지의 복잡도를 줄일 수 있어서 CI를 선호하기도 하지만, 가장 큰 이유는 리팩터링과 궁합이 아주 좋기 때문이다
- 켄트 백이 CI와 리팩터링을 합쳐서 익스트림 프로그래밍(eXetreme Programming - XP)를 만든 이유도 바로 두 기법의 궁합이 잘 맞기 때문이다
#### 테스팅
- 자가 테스트 코드(self-testing code)가 필요하다
- 리팩터링 도중의 오류를 빨리 수정하려면, 코드의 다양한 측면을 검사하는 테스트 스위트(test suite)가 필요하다. 그리고 이를 빠르게 실행할 수 있어야 한다
- 테스트가 실패한다면 가장 최근에 통과한 버전에서 무엇이 달라졌는지 살펴볼 수 있다는데 있다
- 테스트 주기가 짧다면 단 몇 줄만 비교하면 되며, 문제를 일으킨 부분이 그 몇 줄 안에 있기 때문에 버그를 훨씬 쉽게 찾을 수 있다
- 자가 테스트 코드는 통합 과정에서 발생하는 의미 충돌을 잡는 매커니즘으로 활용할 수 있어서 자연스럽게도 CI와 밀접하게 연관된다
- CI에 통합된 테스트는 XP의 권장사항이자 지속적 배포(CD - Continuous Delviery)의 핵심
#### 레거시 코드
- 레거시 시스템을 파악할 때 리팩터링이 굉장히 도움이 된다
- 레거시 시스템에 테스트가 없는 경우, 테스트 보강이 필요하다
- 참고도서 `레거시 코드 활용 전략(에이콘, 2018)`에 나온 지침을 충실히 따르자. 핵심은 "프로그램에서 테스트를 추가할 틈새를 찾아서 시스템을 테스트해야 한다"는 것이다
- 복잡하게 얽힌 레거시 코드를 단번에 리팩터링하는 것은 어렵다
- 서로 관련된 부분끼리 나눠서 하나씩 공략하는 것이다
#### 데이터베이스
- 리팩터링 초판에서 데이터베이스는 리팩터링하기 어려운 영역이라고 했음. 하지만 틀림
- 데이터베이스 리팩터링 기법
  - 커다란 변경들을 쉽게 조합하고 다룰 수 있는 데이터 마이그레이션 스크립트를 작성
  - 접근 코드와 데이터베이스 스키마에 대한 구조적 변경을 스크립트로 처리하게끔 통합
  - 프로덕션 환경에 여러 단계로 나눠서 릴리스하는 것이 좋다
    - 필드 이름을 바꿀 때 첫 번째 커밋에서는 새로운 데이터베이스 필드를 추가하고 사용하지는 않는다 
    - 그 다음 기존 필드와 새 필드를 동시에 업데이트하도록 설정
    - 그 다음 데이터베이스를 읽는 클라이언트들을 새 필드를 사용하는 버전으로 조금씩 교체
    - 이 과정에서 발생하는 버그 해결
    - 클라이언트 교체 작업이 모두 끝냈다면, 더는 필요가 ㅇ벗어진 예전 필드를 삭제
### 2.6 리팩터링, 아키텍쳐, 애그니(YAGNI)
- 리팩터링 이전에는 코딩을 시작하기 전에 소프트웨어 설계와 아키텍쳐를 어느 정도, 심지어 거의 완료해야 했음. 일단 코드로 작성된 뒤로는 아키텍쳐를 바꿀 수 없고 부주의로 인해 부패할 일만 남았다고 여기곤 했다
- 리팩터링 이후에는 수년 동안 운영되던 소프트웨어라도 아키텍쳐를 대폭 변경할 수 있었다
- 하지만 레기서 코드는 변경하기 어려울 때가 많다. 특히 탄탄한 테스트가 뒷받침해주지 못하면 더더욱 어렵다
- 미래의 변경을 대비한 설계 방식들
  - 간결한 설계(Simple design)
  - 점진적 설계(Incremental design)
  - YAGNI(You aren't going to need it - "필요 없을 거다"의 줄임말)
  - 진화형 아키텍쳐(Evolutionary architecture)
    - 아키텍쳐 관련 결정 시간을 두고 반복해 내릴 수 있다는 장점을 활용하는 패턴과 실천법을 추구한다