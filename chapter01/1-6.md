### 1.6 계산 단계와 포맷팅 단계 분리하기
지금까지는 프로그램의 논리적인 요소를 파악하기 쉽도록 코드의 구조를 보강하는 데 주안점을 두고 리팩터링했다. 리팩터링 초기 단계에서 흔히 수행하는 일이다. 복잡하게 얽힌 덩어리를 잘게 쪼개는 작업은 이름을 잘 짓는 일만큼 중요하다.

골격은 충분히 개선됐으니 이제 원하던 기능 기능 변경, 즉 `statement()`의 HTML 버전을 만드는 작업을 살펴보자. 여러 각도에서 볼 때 확실히 처음 코드보다 작업하기 편해졌다. 계산 코드가 모두 분리됐기 때문에 일곱 줄짜리 최상단 코드에 대응하는 HTML 버전만 작성하면 된다. 그런데 문제가 하나 있다. 분리된 계산 함수들이 텍스트 버전인 `statement()` 안에 중첩 함수로 들어가 있는 게 아닌가. 이 모두를 그대로 복사해 붙이는 방식으로 HTML 버전을 만들고 싶진 않다. 텍스트 버전과 HTML 버전 함수 모두가 똑같은 계산 함수들을 사용하게 만들고 싶다.

다양한 해결책 중 내가 가장 선호하는 방식은 [6.11 단계 쪼개기(Split Phase)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-11.md)다. 내 목표는 `statement()`의 로직을 두 단계로 나누는 것이다. 첫 단계에서는 `statement()`에 필요한 데이터를 처리하고, 다음 단계에서는 앞서 처리한 결과를 텍스트나 HTML로 표현하도록 하자. 다시 말해 첫 번째 단계에서는 두 번째 단계로 전달할 중간 데이터 구조를 생성하는 것이다.

#### STEP 1
단계를 쪼개려면 먼저 두 번째 단계가 될 코드들을 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md)로 뽑아내야 한다. 이 예에서 두 번째 단계는 청구 내역을 출력하는 코드인데, 현재는 `statement()`의 본문 전체가 여기 해당한다.
``` diff
function statement(invoice, plays) {
+ return renderPlainText(invoice, plays); // 본문 전체를 별도의 함수로 추출
+}

+function renderPlainText(invoice, plays) { // 본문 전체를 별도의 함수로 추출
  let result = `청구 내역 (고객명: ${invoice.customer})\n`;
  for (let perf of invoice.performances) {
    // 청구 내역을 출력한다.
    result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)`;
  }
  result += `총액: ${usd(totalAmount())}\n` // 변수 인라인 후 함수 이름 바꾸기
  result += `적립 포인트: ${totalVolumeCredits()}점\n`
  return result;

  function totalAmount() {  
    let result = 0;
    for (let perf of invoice.performances) {
      result += amountFor(perf);
    }
    return result;
  }

  function totalVolumeCredits() {
    let result = 0;
    for (let perf of invoice.performances) {
      result += volumeCreditsFor(perf);
    }
    return result;
  }

  function usd(aNumber) {  
    return new Intl.NumberFormat("en-US", {
      style: "currency", 
      currency: "USD",
      minimumFractionDigits: 2,
    }).format(aNumber/100);
  }

  function volumeCreditsFor(aPerformance) {  
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
    if ("comedy" === playFor(aPerformance).type) volumeCredits += Math.floor(aPerformance.audience / 5);
    return result;
  }

  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }

  function amountFor(aPerformance) {  
    let result = 0;
    switch(playFor(aPerformance).type) {
      case "tragedy": // 비극
        result = 40000;
        if (aPerformance.audience > 30) {  
          result += 1000 * (aPerformance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (aPerformance.audience > 20) {  
          result += 10000   500 * (aPerformance.audience - 30);
        }
        result += 300 * aPerformance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${playFor(aPerformance).type}`);
    }
    return result;
  }  
}
```
항상 하듯이 수정한 코드를 컴파일-테스트-커밋한다.
#### STEP 2
다음으로 두 단계 사이의 중간 데이터 구조 역할을 할 객체를 만들어서 `renderPlainText()`에 인수로 전달한다(컴파일-테스트-커밋).