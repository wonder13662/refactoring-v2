### 1.6 계산 단계와 포맷팅 단계 분리하기
지금까지는 프로그램의 논리적인 요소를 파악하기 쉽도록 코드의 구조를 보강하는 데 주안점을 두고 리팩터링했다. 리팩터링 초기 단계에서 흔히 수행하는 일이다. 복잡하게 얽힌 덩어리를 잘게 쪼개는 작업은 이름을 잘 짓는 일만큼 중요하다.

골격은 충분히 개선됐으니 이제 원하던 기능 기능 변경, 즉 `statement()`의 HTML 버전을 만드는 작업을 살펴보자. 여러 각도에서 볼 때 확실히 처음 코드보다 작업하기 편해졌다. 계산 코드가 모두 분리됐기 때문에 일곱 줄짜리 최상단 코드에 대응하는 HTML 버전만 작성하면 된다. 그런데 문제가 하나 있다. 분리된 계산 함수들이 텍스트 버전인 `statement()` 안에 중첩 함수로 들어가 있는 게 아닌가. 이 모두를 그대로 복사해 붙이는 방식으로 HTML 버전을 만들고 싶진 않다. 텍스트 버전과 HTML 버전 함수 모두가 똑같은 계산 함수들을 사용하게 만들고 싶다.

다양한 해결책 중 내가 가장 선호하는 방식은 [6.11 단계 쪼개기(Split Phase)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-11.md)다. 내 목표는 `statement()`의 로직을 두 단계로 나누는 것이다. 첫 단계에서는 `statement()`에 필요한 데이터를 처리하고, 다음 단계에서는 앞서 처리한 결과를 텍스트나 HTML로 표현하도록 하자. 다시 말해 첫 번째 단계에서는 두 번째 단계로 전달할 중간 데이터 구조를 생성하는 것이다.

#### STEP 1
단계를 쪼개려면 먼저 두 번째 단계가 될 코드들을 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md)로 뽑아내야 한다. 이 예에서 두 번째 단계는 청구 내역을 출력하는 코드인데, 현재는 `statement()`의 본문 전체가 여기 해당한다.
``` diff
function statement(invoice, plays) {
+ return renderPlainText(invoice, plays); // 본문 전체를 별도의 함수로 추출
+}

+function renderPlainText(invoice, plays) { // 본문 전체를 별도의 함수로 추출
  let result = `청구 내역 (고객명: ${invoice.customer})\n`;
  for (let perf of invoice.performances) {
    // 청구 내역을 출력한다.
    result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)`;
  }
  result += `총액: ${usd(totalAmount())}\n`
  result += `적립 포인트: ${totalVolumeCredits()}점\n`
  return result;

  function totalAmount() {  
    let result = 0;
    for (let perf of invoice.performances) {
      result += amountFor(perf);
    }
    return result;
  }

  function totalVolumeCredits() {
    let result = 0;
    for (let perf of invoice.performances) {
      result += volumeCreditsFor(perf);
    }
    return result;
  }

  function usd(aNumber) {  
    return new Intl.NumberFormat("en-US", {
      style: "currency", 
      currency: "USD",
      minimumFractionDigits: 2,
    }).format(aNumber/100);
  }

  function volumeCreditsFor(aPerformance) {  
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
    if ("comedy" === playFor(aPerformance).type) result += Math.floor(aPerformance.audience / 5);
    return result;
  }

  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }

  function amountFor(aPerformance) {  
    let result = 0;
    switch(playFor(aPerformance).type) {
      case "tragedy": // 비극
        result = 40000;
        if (aPerformance.audience > 30) {  
          result += 1000 * (aPerformance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (aPerformance.audience > 20) {  
          result += 10000 + 500 * (aPerformance.audience - 30);
        }
        result += 300 * aPerformance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${playFor(aPerformance).type}`);
    }
    return result;
  }  
}
```
항상 하듯이 수정한 코드를 컴파일-테스트-커밋한다.
#### STEP 2
다음으로 두 단계 사이의 중간 데이터 구조 역할을 할 객체를 만들어서 `renderPlainText()`에 인수로 전달한다(컴파일-테스트-커밋).
``` diff
function statement(invoice, plays) {
+ const statementData = {};
- return renderPlainText(invoice, plays);
+ return renderPlainText(statementData, invoice, plays); // 중간 데이터 구조를 인수로 전달
}

-function renderPlainText(invoice, plays) {
+function renderPlainText(data, invoice, plays) { // 중간 데이터 구조를 인수로 전달
  let result = `청구 내역 (고객명: ${invoice.customer})\n`;
  for (let perf of invoice.performances) {
    // 청구 내역을 출력한다.
    result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)`;
  }
  result += `총액: ${usd(totalAmount())}\n`
  result += `적립 포인트: ${totalVolumeCredits()}점\n`
  return result;

  function totalAmount() {  
    let result = 0;
    for (let perf of invoice.performances) {
      result += amountFor(perf);
    }
    return result;
  }

  function totalVolumeCredits() {
    let result = 0;
    for (let perf of invoice.performances) {
      result += volumeCreditsFor(perf);
    }
    return result;
  }

  function usd(aNumber) {  
    return new Intl.NumberFormat("en-US", {
      style: "currency", 
      currency: "USD",
      minimumFractionDigits: 2,
    }).format(aNumber/100);
  }

  function volumeCreditsFor(aPerformance) {  
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
    if ("comedy" === playFor(aPerformance).type) result += Math.floor(aPerformance.audience / 5);
    return result;
  }

  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }

  function amountFor(aPerformance) {  
    let result = 0;
    switch(playFor(aPerformance).type) {
      case "tragedy": // 비극
        result = 40000;
        if (aPerformance.audience > 30) {  
          result += 1000 * (aPerformance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (aPerformance.audience > 20) {  
          result += 10000 + 500 * (aPerformance.audience - 30);
        }
        result += 300 * aPerformance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${playFor(aPerformance).type}`);
    }
    return result;
  }  
}
```
#### STEP 2
이번에는 `renderPlainText()`의 다른 두 인수(`invoice`와 `plays`)를 살펴보자. 이 인수들을 통해 전달되는 데이터를 모두 방금 만든 중간 데이터 구조로 옮기면, 계산 관련 코드는 전부 `statement()` 함수로 모으고 `renderPlainText()`는 `data` 매개변수로 전달된 데이터만 처리하게 만들 수 있다.

가장 먼저 고객 정보부터 중간 데이터 구조로 옮긴다(컴파일-테스트-커밋).
``` diff
function statement(invoice, plays) {
  const statementData = {};
+ statementData.customer = invoice.customer;  // 고객 데이터를 중간 데이터로 옮김
  return renderPlainText(statementData, invoice, plays);
}

function renderPlainText(data, invoice, plays) {
- let result = `청구 내역 (고객명: ${invoice.customer})\n`;
+ let result = `청구 내역 (고객명: ${data.customer})\n`; // 고객 데이터를 중간 데이터로부터 얻음
  for (let perf of invoice.performances) {
    // 청구 내역을 출력한다.
    result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)`;
  }
  result += `총액: ${usd(totalAmount())}\n`
  result += `적립 포인트: ${totalVolumeCredits()}점\n`
  return result;

  function totalAmount() {  
    let result = 0;
    for (let perf of invoice.performances) {
      result += amountFor(perf);
    }
    return result;
  }

  function totalVolumeCredits() {
    let result = 0;
    for (let perf of invoice.performances) {
      result += volumeCreditsFor(perf);
    }
    return result;
  }

  function usd(aNumber) {  
    return new Intl.NumberFormat("en-US", {
      style: "currency", 
      currency: "USD",
      minimumFractionDigits: 2,
    }).format(aNumber/100);
  }

  function volumeCreditsFor(aPerformance) {  
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
    if ("comedy" === playFor(aPerformance).type) result += Math.floor(aPerformance.audience / 5);
    return result;
  }

  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }

  function amountFor(aPerformance) {  
    let result = 0;
    switch(playFor(aPerformance).type) {
      case "tragedy": // 비극
        result = 40000;
        if (aPerformance.audience > 30) {  
          result += 1000 * (aPerformance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (aPerformance.audience > 20) {  
          result += 10000 + 500 * (aPerformance.audience - 30);
        }
        result += 300 * aPerformance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${playFor(aPerformance).type}`);
    }
    return result;
  }  
}
```
#### STEP 3
같은 방식으로 공연 정보까지 중간 데이터 구조로 옮기고 나면 `renderPlainText()`의 `invoice` 매개변수를 삭제해도 된다(컴파일-테스트-커밋).
``` diff
function statement(invoice, plays) {
  const statementData = {};
  statementData.customer = invoice.customer;
+ statementData.performances = invoice.performances; // 공연 정보를 중간 데이터로 옮김
- return renderPlainText(statementData, invoice, plays);
+ return renderPlainText(statementData, plays); // 필요 없어진 인수 삭제
}

function renderPlainText(data, invoice, plays) {
  let result = `청구 내역 (고객명: ${data.customer})\n`;
- for (let perf of invoice.performances) {
+ for (let perf of data.performances) {  
    // 청구 내역을 출력한다.
    result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)`;
  }
  result += `총액: ${usd(totalAmount())}\n`
  result += `적립 포인트: ${totalVolumeCredits()}점\n`
  return result;

  function totalAmount() {  
    let result = 0;
-   for (let perf of invoice.performances) {
+   for (let perf of data.performances) {  
      result += amountFor(perf);
    }
    return result;
  }

  function totalVolumeCredits() {
    let result = 0;
-   for (let perf of invoice.performances) {
+   for (let perf of data.performances) {  
      result += volumeCreditsFor(perf);
    }
    return result;
  }

  function usd(aNumber) {  
    return new Intl.NumberFormat("en-US", {
      style: "currency", 
      currency: "USD",
      minimumFractionDigits: 2,
    }).format(aNumber/100);
  }

  function volumeCreditsFor(aPerformance) {  
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
    if ("comedy" === playFor(aPerformance).type) result += Math.floor(aPerformance.audience / 5);
    return result;
  }

  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }

  function amountFor(aPerformance) {  
    let result = 0;
    switch(playFor(aPerformance).type) {
      case "tragedy": // 비극
        result = 40000;
        if (aPerformance.audience > 30) {  
          result += 1000 * (aPerformance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (aPerformance.audience > 20) {  
          result += 10000 + 500 * (aPerformance.audience - 30);
        }
        result += 300 * aPerformance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${playFor(aPerformance).type}`);
    }
    return result;
  }  
}
```
#### STEP 4
이제 연극 제목도 중간 데이터 구조에서 가져오도록 한다. 이를 위해 공연 정보 레코드에 연극 데이터를 추가해야 한다(컴파일-테스트-커밋).
``` diff
function statement(invoice, plays) {
  const statementData = {};
  statementData.customer = invoice.customer;
- statementData.performances = invoice.performances;
+ statementData.performances = invoice.performances.map(enrichPerformace);
  return renderPlainText(statementData, plays);

+ function enrichPerformace(aPerformance) {
+   const result = Object.assign({}, aPerformance); // 얕은 복사 수행
+   return result;
+ }
}

function renderPlainText(data, invoice, plays) {
  let result = `청구 내역 (고객명: ${data.customer})\n`;
  for (let perf of data.performances) {  
    // 청구 내역을 출력한다.
    result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)`;
  }
  result += `총액: ${usd(totalAmount())}\n`
  result += `적립 포인트: ${totalVolumeCredits()}점\n`
  return result;

  function totalAmount() {  
    let result = 0;
    for (let perf of data.performances) {  
      result += amountFor(perf);
    }
    return result;
  }

  function totalVolumeCredits() {
    let result = 0;
    for (let perf of data.performances) {  
      result += volumeCreditsFor(perf);
    }
    return result;
  }

  function usd(aNumber) {  
    return new Intl.NumberFormat("en-US", {
      style: "currency", 
      currency: "USD",
      minimumFractionDigits: 2,
    }).format(aNumber/100);
  }

  function volumeCreditsFor(aPerformance) {  
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
    if ("comedy" === playFor(aPerformance).type) result += Math.floor(aPerformance.audience / 5);
    return result;
  }

  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }

  function amountFor(aPerformance) {  
    let result = 0;
    switch(playFor(aPerformance).type) {
      case "tragedy": // 비극
        result = 40000;
        if (aPerformance.audience > 30) {  
          result += 1000 * (aPerformance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (aPerformance.audience > 20) {  
          result += 10000 + 500 * (aPerformance.audience - 30);\
          
        }
        result += 300 * aPerformance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${playFor(aPerformance).type}`);
    }
    return result;
  }  
}
```
여기서는 공연 객체를 복사하기만 했지만, 잠시 후 이렇게 새로 만든 레코드에 데이터를 채울 것이다. 이때 복사를 한 이유는 함수로 건넨 데이터를 수정하기 싫어서다. 가변(mutable) 데이터는 금방 상하기 때문에 나는 데이터를 최대한 불변(mutable)처럼 취급한다.
> 자바스크립트를 처음 접한 독자는 여기 나온 `result = Object.assign({}, aPerformance)` 구문이 굉장히 어색할 수 있다. 이 문장은 얕은 복사(shallow copy)를 수행한다. 나는 이럴 때 함수로 만드는 방식을 선호하지만, 워낙 굳어진 표현이라서 별도 함수로 만들면 자바스크립트 프로그래머가 볼 때 오히려 어색할까봐 이렇게 썼다.
#### STEP 5
이제 연극 정보를 담을 자리가 마련됐으니 실제로 데이터를 담아보자. 이를 위해 [8.1 함수 옮기기(Move Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-1.md)를 적용하여 `playFor()` 함수를 `statement()`로 옮긴다(컴파일-테스트-커밋).
``` diff
function statement(invoice, plays) {
  const statementData = {};
  statementData.customer = invoice.customer;
  statementData.performances = invoice.performances.map(enrichPerformace);
  return renderPlainText(statementData, plays);

  function enrichPerformace(aPerformance) {
    const result = Object.assign({}, aPerformance);
+   result.play = playFor(result);  // 중간 데이터에 연극 정보를 저장
    return result;
  }

+ function playFor(aPerformance) { // renderPlainText()의 중첩 함수였던 playFor()를 statement()로 옮김
+   return plays[aPerformance.playID];
+ }
}

function renderPlainText(data, invoice, plays) {
  let result = `청구 내역 (고객명: ${data.customer})\n`;
  for (let perf of data.performances) {  
    // 청구 내역을 출력한다.
    result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)`;
  }
  result += `총액: ${usd(totalAmount())}\n`
  result += `적립 포인트: ${totalVolumeCredits()}점\n`
  return result;

  function totalAmount() {  
    let result = 0;
    for (let perf of data.performances) {  
      result += amountFor(perf);
    }
    return result;
  }

  function totalVolumeCredits() {
    let result = 0;
    for (let perf of data.performances) {  
      result += volumeCreditsFor(perf);
    }
    return result;
  }

  function usd(aNumber) {  
    return new Intl.NumberFormat("en-US", {
      style: "currency", 
      currency: "USD",
      minimumFractionDigits: 2,
    }).format(aNumber/100);
  }

  function volumeCreditsFor(aPerformance) {  
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
    if ("comedy" === playFor(aPerformance).type) result += Math.floor(aPerformance.audience / 5);
    return result;
  }

- function playFor(aPerformance) {
-   return plays[aPerformance.playID];
- }

  function amountFor(aPerformance) {  
    let result = 0;
    switch(playFor(aPerformance).type) {
      case "tragedy": // 비극
        result = 40000;
        if (aPerformance.audience > 30) {  
          result += 1000 * (aPerformance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (aPerformance.audience > 20) {  
          result += 10000 + 500 * (aPerformance.audience - 30);
        }
        result += 300 * aPerformance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${playFor(aPerformance).type}`);
    }
    return result;
  }  
}
```
#### STEP 6
그런 다음 `renderPlainText()` 안에서 `playFor()`를 호출하던 부분을 중간 데이터를 사용하도록 바꾼다(컴파일-테스트-커밋).
``` diff
function statement(invoice, plays) {
  const statementData = {};
  statementData.customer = invoice.customer;
  statementData.performances = invoice.performances.map(enrichPerformace);
  return renderPlainText(statementData, plays);

  function enrichPerformace(aPerformance) {
    const result = Object.assign({}, aPerformance);
    result.play = playFor(result);
    return result;
  }

  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }
}

function renderPlainText(data, invoice, plays) {
  let result = `청구 내역 (고객명: ${data.customer})\n`;
  for (let perf of data.performances) {  
-   result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)`;
+   result += ` ${perf.play.name}: ${usd(amountFor(perf))} (${perf.audience}석)`;
  }
  result += `총액: ${usd(totalAmount())}\n`
  result += `적립 포인트: ${totalVolumeCredits()}점\n`
  return result;

  function totalAmount() {  
    let result = 0;
    for (let perf of data.performances) {  
      result += amountFor(perf);
    }
    return result;
  }

  function totalVolumeCredits() {
    let result = 0;
    for (let perf of data.performances) {  
      result += volumeCreditsFor(perf);
    }
    return result;
  }

  function usd(aNumber) {  
    return new Intl.NumberFormat("en-US", {
      style: "currency", 
      currency: "USD",
      minimumFractionDigits: 2,
    }).format(aNumber/100);
  }

  function volumeCreditsFor(aPerformance) {  
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
-   if ("comedy" === playFor(aPerformance).type) volumeCredits += Math.floor(aPerformance.audience / 5);
+   if ("comedy" === aPerformance.play.type) result += Math.floor(aPerformance.audience / 5);
    return result;
  }

  function amountFor(aPerformance) {  
    let result = 0;
-   switch(playFor(aPerformance).type) {
+   switch(aPerformance.play.type) {
      case "tragedy": // 비극
        result = 40000;
        if (aPerformance.audience > 30) {  
          result += 1000 * (aPerformance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (aPerformance.audience > 20) {  
          result += 10000 + 500 * (aPerformance.audience - 30);
        }
        result += 300 * aPerformance.audience;
        break;
      default:
-       throw new Error(`알 수 없는 장르: ${playFor(aPerformance).type}`);
+       throw new Error(`알 수 없는 장르: ${aPerformance.play.type}`);
    }
    return result;
  }  
}
```
#### STEP 7
이어서 `amountFor()`도 비슷한 방법으로 옮긴다(컴파일-테스트-커밋).
``` diff
function statement(invoice, plays) {
  const statementData = {};
  statementData.customer = invoice.customer;
  statementData.performances = invoice.performances.map(enrichPerformace);
  return renderPlainText(statementData, plays);

  function enrichPerformace(aPerformance) {
    const result = Object.assign({}, aPerformance);
    result.play = playFor(result);
+   result.amount = amountFor(result);
    return result;
  }

  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }

+ function amountFor(aPerformance) {
+   let result = 0;
+   switch(aPerformance.play.type) {
+     case "tragedy": // 비극
+       result = 40000;
+       if (aPerformance.audience > 30) {  
+         result += 1000 * (aPerformance.audience - 30);
+       }
+       break;
+     case "comedy": // 희극
+       result = 30000;
+       if (aPerformance.audience > 20) {  
+         result += 10000 + 500 * (aPerformance.audience - 30);
+       }
+       result += 300 * aPerformance.audience;
+       break;
+     default:
+       throw new Error(`알 수 없는 장르: ${aPerformance.play.type}`);
+   }
+   return result;
+ }
}

function renderPlainText(data, invoice, plays) {
  let result = `청구 내역 (고객명: ${data.customer})\n`;
  for (let perf of data.performances) {  
-   result += ` ${perf.play.name}: ${usd(amountFor(perf))} (${perf.audience}석)`;
+   result += ` ${perf.play.name}: ${perf.amount)} (${perf.audience}석)`;
  }
  result += `총액: ${usd(totalAmount())}\n`
  result += `적립 포인트: ${totalVolumeCredits()}점\n`
  return result;

  function totalAmount() {  
    let result = 0;
    for (let perf of data.performances) {  
-     result += amountFor(perf);
+     result += perf.amount;
    }
    return result;
  }

  function totalVolumeCredits() {
    let result = 0;
    for (let perf of data.performances) {  
      result += volumeCreditsFor(perf);
    }
    return result;
  }

  function usd(aNumber) {  
    return new Intl.NumberFormat("en-US", {
      style: "currency", 
      currency: "USD",
      minimumFractionDigits: 2,
    }).format(aNumber/100);
  }

  function volumeCreditsFor(aPerformance) {  
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
    if ("comedy" === aPerformance.play.type) result += Math.floor(aPerformance.audience / 5);
    return result;
  }

- function amountFor(aPerformance) {
-   let result = 0;
-   switch(aPerformance.play.type) {
-     case "tragedy": // 비극
-       result = 40000;
-       if (aPerformance.audience > 30) {  
-         result += 1000 * (aPerformance.audience - 30);
-       }
-       break;
-     case "comedy": // 희극
-       result = 30000;
-       if (aPerformance.audience > 20) {  
-         result += 10000 + 500 * (aPerformance.audience - 30);
-       }
-       result += 300 * aPerformance.audience;
-     break;
-     default:
-       throw new Error(`알 수 없는 장르: ${aPerformance.play.type}`);
-   }
-   return result;
- }  
}
```
#### STEP 8
다음으로 적립 포인트 계산 부분을 옮긴다(컴파일-테스트-커밋)
``` diff
function statement(invoice, plays) {
  const statementData = {};
  statementData.customer = invoice.customer;
  statementData.performances = invoice.performances.map(enrichPerformace);
  return renderPlainText(statementData, plays);

  function enrichPerformace(aPerformance) {
    const result = Object.assign({}, aPerformance);
    result.play = playFor(result);
    result.amount = amountFor(result);
+   result.volumeCredits = volumeCreditsFor(result);
    return result;
  }

  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }

  function amountFor(aPerformance) {
    let result = 0;
    switch(aPerformance.play.type) {
      case "tragedy": // 비극
        result = 40000;
        if (aPerformance.audience > 30) {  
          result += 1000 * (aPerformance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (aPerformance.audience > 20) {  
          result += 10000 + 500 * (aPerformance.audience - 30);
        }
        result += 300 * aPerformance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${aPerformance.play.type}`);
    }
    return result;
  }

+ function volumeCreditsFor(aPerformance) {  
+   let result = 0;
+   result += Math.max(aPerformance.audience - 30, 0);
+   if ("comedy" === aPerformance.play.type) result += Math.floor(aPerformance.audience / 5);
+   return result;
+ }  
}

function renderPlainText(data, invoice, plays) {
  let result = `청구 내역 (고객명: ${data.customer})\n`;
  for (let perf of data.performances) {  
    result += ` ${perf.play.name}: ${perf.amount)} (${perf.audience}석)`;
  }
  result += `총액: ${usd(totalAmount())}\n`
  result += `적립 포인트: ${totalVolumeCredits()}점\n`
  return result;

  function totalAmount() {  
    let result = 0;
    for (let perf of data.performances) {  
      result += perf.amount;
    }
    return result;
  }

  function totalVolumeCredits() {
    let result = 0;
    for (let perf of data.performances) {  
-   result += volumeCreditsFor(perf);
+   result += perf.volumeCredits;
    }
    return result;
  }

  function usd(aNumber) {  
    return new Intl.NumberFormat("en-US", {
      style: "currency", 
      currency: "USD",
      minimumFractionDigits: 2,
    }).format(aNumber/100);
  }

- function volumeCreditsFor(aPerformance) {  
-   let result = 0;
-   result += Math.max(aPerformance.audience - 30, 0);
-   if ("comedy" === aPerformance.play.type) result += Math.floor(aPerformance.audience / 5);
-   return result;
- }
}
```
#### STEP 9
마지막으로 총합을 구하는 부분을 옮긴다.
``` diff
function statement(invoice, plays) {
  const statementData = {};
  statementData.customer = invoice.customer;
  statementData.performances = invoice.performances.map(enrichPerformace);
+ statementData.totalAmount = totalAmount(statementData);
+ statementData.totalVolumeCredits = totalVolumeCredits(statementData);
  return renderPlainText(statementData, plays);

  function enrichPerformace(aPerformance) {
    const result = Object.assign({}, aPerformance);
    result.play = playFor(result);
    result.amount = amountFor(result);
    result.volumeCredits = volumeCreditsFor(result);
    return result;
  }

  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }

  function amountFor(aPerformance) {
    let result = 0;
    switch(aPerformance.play.type) {
      case "tragedy": // 비극
        result = 40000;
        if (aPerformance.audience > 30) {  
          result += 1000 * (aPerformance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (aPerformance.audience > 20) {  
          result += 10000 + 500 * (aPerformance.audience - 30);
        }
        result += 300 * aPerformance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${aPerformance.play.type}`);
    }
    return result;
  }

  function volumeCreditsFor(aPerformance) {  
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
    if ("comedy" === aPerformance.play.type) result += Math.floor(aPerformance.audience / 5);
    return result;
  }

+ function totalAmount(data) {  
+   let result = 0;
+   for (let perf of data.performances) {  
+     result += perf.amount;
+   }
+   return result;
+ }

+ function totalVolumeCredits(data) {
+   let result = 0;
+   for (let perf of data.performances) {  
+     result += perf.volumeCredits;
+   }
+   return result;
+ }
}

function renderPlainText(data, invoice, plays) {
  let result = `청구 내역 (고객명: ${data.customer})\n`;
  for (let perf of data.performances) {  
    result += ` ${perf.play.name}: ${perf.amount)} (${perf.audience}석)`;
  }
- result += `총액: ${usd(totalAmount())}\n`
+ result += `총액: ${usd(data.totalAmount)}\n`
- result += `적립 포인트: ${totalVolumeCredits()}점\n`
+ result += `적립 포인트: ${data.totalVolumeCredits}점\n`
  return result;

- function totalAmount() {
-   let result = 0;
-   for (let perf of data.performances) {  
-     result += perf.amount;
-   }
-   return result;
- }

- function totalVolumeCredits() {
-   let result = 0;
-   for (let perf of data.performances) {  
-     result += perf.volumeCredits;
-   }
-   return result;
- }

  function usd(aNumber) {  
    return new Intl.NumberFormat("en-US", {
      style: "currency", 
      currency: "USD",
      minimumFractionDigits: 2,
    }).format(aNumber/100);
  }
}
```
이때 총합을 구하는 두 함수 `totalAmount()`와 `totalVolumeCredits()`의 본문에서(유효범위 안에 있으므로) `statement` 변수를 사용할 수도 있지만, 내가 명확히 매개변수로 전달하는 방식을 선호하여 이렇게 수정했다.
#### STEP 10
이렇게 옮기고 컴파일-테스트-커밋하고 나니, 가볍게 [8.8 반복문을 파이프라인으로 바꾸기(Replace Loop with Pipeline)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-8.md)까지 적용하고 싶어졌다.
``` diff
function statement(invoice, plays) {
  const statementData = {};
  statementData.customer = invoice.customer;
  statementData.performances = invoice.performances.map(enrichPerformace);
  statementData.totalAmount = totalAmount(statementData);
  statementData.totalVolumeCredits = totalVolumeCredits(statementData);
  return renderPlainText(statementData, plays);

  function enrichPerformace(aPerformance) {
    const result = Object.assign({}, aPerformance);
    result.play = playFor(result);
    result.amount = amountFor(result);
    result.volumeCredits = volumeCreditsFor(result);
    return result;
  }

  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }

  function amountFor(aPerformance) {
    let result = 0;
    switch(aPerformance.play.type) {
      case "tragedy": // 비극
        result = 40000;
        if (aPerformance.audience > 30) {  
          result += 1000 * (aPerformance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (aPerformance.audience > 20) {  
          result += 10000 + 500 * (aPerformance.audience - 30);
        }
        result += 300 * aPerformance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${aPerformance.play.type}`);
    }
    return result;
  }

  function volumeCreditsFor(aPerformance) {  
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
    if ("comedy" === aPerformance.play.type) result += Math.floor(aPerformance.audience / 5);
    return result;
  }

  function totalAmount(data) {  
-   let result = 0;
-   for (let perf of data.performances) {  
-     result += perf.amount;
-   }
-   return result;
+   return data.performances.reduce((total, p) => total + p.amount, 0); // for 반복문을 파이프라인으로 바꿈
  }

  function totalVolumeCredits(data) {
    let result = 0;
-   for (let perf of data.performances) {
-     result += perf.volumeCredits;
-   }
-   return result;
+   return data.performances.reduce((total, p) => total + p.volumeCredits, 0); // for 반복문을 파이프라인으로 바꿈
  }
}

function renderPlainText(data, invoice, plays) {
  let result = `청구 내역 (고객명: ${data.customer})\n`;
  for (let perf of data.performances) {  
    result += ` ${perf.play.name}: ${perf.amount)} (${perf.audience}석)`;
  }
  result += `총액: ${usd(data.totalAmount)}\n`
  result += `적립 포인트: ${data.totalVolumeCredits}점\n`
  return result;

  function usd(aNumber) {  
    return new Intl.NumberFormat("en-US", {
      style: "currency", 
      currency: "USD",
      minimumFractionDigits: 2,
    }).format(aNumber/100);
  }
}
```
#### STEP 11
이제 첫 단계인 `'statement()`에 필요한 데이터 처리'에 해당하는 코드를 모두 별도 함수로 빼낸다(컴파일-테스트-커밋).
``` diff
function statement(invoice, plays) {
- const statementData = {};
- statementData.customer = invoice.customer;
- statementData.performances = invoice.performances.map(enrichPerformace);
- statementData.totalAmount = totalAmount(statementData);
- statementData.totalVolumeCredits = totalVolumeCredits(statementData);
- return renderPlainText(statementData, plays);
+ return renderPlainText(createStatementData(invoice, plays));

- function enrichPerformace(aPerformance) {
-   const result = Object.assign({}, aPerformance);
-   result.play = playFor(result);
-   result.amount = amountFor(result);
-   result.volumeCredits = volumeCreditsFor(result);
-   return result;
- }

- function playFor(aPerformance) {
-   return plays[aPerformance.playID];
- }

- function amountFor(aPerformance) {
-   let result = 0;
-   switch(aPerformance.play.type) {
-     case "tragedy": // 비극
-       result = 40000;
-       if (aPerformance.audience > 30) {  
-         result += 1000 * (aPerformance.audience - 30);
-       }
-       break;
-     case "comedy": // 희극
-       result = 30000;
-       if (aPerformance.audience > 20) {  
-         result += 10000 + 500 * (aPerformance.audience - 30);
-       }
-       result += 300 * aPerformance.audience;
-       break;
-     default:
-       throw new Error(`알 수 없는 장르: ${aPerformance.play.type}`);
-   }
-   return result;
- }

- function volumeCreditsFor(aPerformance) {  
-   let result = 0;
-   result += Math.max(aPerformance.audience - 30, 0);
-   if ("comedy" === aPerformance.play.type) result += Math.floor(aPerformance.audience / 5);
-   return result;
- }

- function totalAmount(data) {  
-   return data.performances.reduce((total, p) => total + p.amount, 0); // for 반복문을 파이프라인으로 바꿈
- }

- function totalVolumeCredits(data) {
-   let result = 0;
-   return data.performances.reduce((total, p) => total + p.volumeCredits, 0); // for 반복문을 파이프라인으로 바꿈
- }
}

+function createStatementData(invoice, plays) { // 중간 데이터 생성을 전달
+ const statementData = {};
+ statementData.customer = invoice.customer;
+ statementData.performances = invoice.performances.map(enrichPerformace);
+ statementData.totalAmount = totalAmount(statementData);
+ statementData.totalVolumeCredits = totalVolumeCredits(statementData);
+ return statementData;

+ function enrichPerformace(aPerformance) {
+   const result = Object.assign({}, aPerformance);
+   result.play = playFor(result);
+   result.amount = amountFor(result);
+   result.volumeCredits = volumeCreditsFor(result);
+   return result;
+ }

+ function playFor(aPerformance) {
+   return plays[aPerformance.playID];
+ }

+ function amountFor(aPerformance) {
+   let result = 0;
+   switch(aPerformance.play.type) {
+     case "tragedy": // 비극
+       result = 40000;
+       if (aPerformance.audience > 30) {  
+         result += 1000 * (aPerformance.audience - 30);
+       }
+       break;
+     case "comedy": // 희극
+       result = 30000;
+       if (aPerformance.audience > 20) {  
+         result += 10000 + 500 * (aPerformance.audience - 30);
+       }
+       result += 300 * aPerformance.audience;
+       break;
+     default:
+       throw new Error(`알 수 없는 장르: ${aPerformance.play.type}`);
+   }
+   return result;
+ }

+ function volumeCreditsFor(aPerformance) {  
+   let result = 0;
+   result += Math.max(aPerformance.audience - 30, 0);
+   if ("comedy" === aPerformance.play.type) result += Math.floor(aPerformance.audience / 5);
+   return result;
+ }

+ function totalAmount(data) {
+   return data.performances.reduce((total, p) => total + p.amount, 0); // for 반복문을 파이프라인으로 바꿈
+ }

+ function totalVolumeCredits(data) {
+   let result = 0;
+   return data.performances.reduce((total, p) => total + p.volumeCredits, 0); // for 반복문을 파이프라인으로 바꿈
+ }
+}

function renderPlainText(data, invoice, plays) {
  let result = `청구 내역 (고객명: ${data.customer})\n`;
  for (let perf of data.performances) {  
    result += ` ${perf.play.name}: ${perf.amount)} (${perf.audience}석)`;
  }
  result += `총액: ${usd(data.totalAmount)}\n`
  result += `적립 포인트: ${data.totalVolumeCredits}점\n`
  return result;

  function usd(aNumber) {  
    return new Intl.NumberFormat("en-US", {
      style: "currency", 
      currency: "USD",
      minimumFractionDigits: 2,
    }).format(aNumber/100);
  }
}
```
#### STEP 12
두 단계가 명확히 분리됐으니 각 코드를 별도 파일에 저장한다(그러면서 반환 결과를 저장할 변수의 이름도 내 코딩 스타일에 맞게 바꾼다).
``` diff
// statement.js
+import createStatementData from './createStatementData.js';

function statement(invoice, plays) {
  return renderPlainText(createStatementData(invoice, plays));
}

function renderPlainText(data, invoice, plays) {
  let result = `청구 내역 (고객명: ${data.customer})\n`;
  for (let perf of data.performances) {  
    result += ` ${perf.play.name}: ${perf.amount)} (${perf.audience}석)`;
  }
  result += `총액: ${usd(data.totalAmount)}\n`
  result += `적립 포인트: ${data.totalVolumeCredits}점\n`
  return result;

  function usd(aNumber) {  
    return new Intl.NumberFormat("en-US", {
      style: "currency", 
      currency: "USD",
      minimumFractionDigits: 2,
    }).format(aNumber/100);
  }
}

// createStatementData.js
-function createStatementData(invoice, plays) {
+export default function createStatementData(invoice, plays) {
- const statementData = {};
+ const result = {};
- statementData.customer = invoice.customer;
+ result.customer = invoice.customer;
- statementData.performances = invoice.performances.map(enrichPerformace);
+ result.performances = invoice.performances.map(enrichPerformace);
- statementData.totalAmount = totalAmount(statementData);
+ result.totalAmount = totalAmount(statementData);
- statementData.totalVolumeCredits = totalVolumeCredits(statementData);
+ result.totalVolumeCredits = totalVolumeCredits(statementData);
- return statementData;
+ return result;

  function enrichPerformace(aPerformance) {
    const result = Object.assign({}, aPerformance);
    result.play = playFor(result);
    result.amount = amountFor(result);
    result.volumeCredits = volumeCreditsFor(result);
    return result;
  }

  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }

  function amountFor(aPerformance) {
    let result = 0;
    switch(aPerformance.play.type) {
      case "tragedy": // 비극
        result = 40000;
        if (aPerformance.audience > 30) {  
          result += 1000 * (aPerformance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (aPerformance.audience > 20) {  
          result += 10000 + 500 * (aPerformance.audience - 30);
        }
        result += 300 * aPerformance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${aPerformance.play.type}`);
    }
    return result;
  }

  function volumeCreditsFor(aPerformance) {  
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
    if ("comedy" === aPerformance.play.type) result += Math.floor(aPerformance.audience / 5);
    return result;
  }

  function totalAmount(data) {
    return data.performances.reduce((total, p) => total + p.amount, 0); // for 반복문을 파이프라인으로 바꿈
  }

  function totalVolumeCredits(data) {
    let result = 0;
    return data.performances.reduce((total, p) => total + p.volumeCredits, 0); // for 반복문을 파이프라인으로 바꿈
  }
}
```
#### STEP 13
마지막으로 컴파일-테스트-커밋하고 나면 드디어 HTML 버전을 작성할 준비가 끝난다.
``` diff
// statement.js
import createStatementData from './createStatementData.js';

function statement(invoice, plays) {
  return renderPlainText(createStatementData(invoice, plays));
}

function renderPlainText(data, invoice, plays) {
  let result = `청구 내역 (고객명: ${data.customer})\n`;
  for (let perf of data.performances) {  
    result += ` ${perf.play.name}: ${perf.amount)} (${perf.audience}석)`;
  }
  result += `총액: ${usd(data.totalAmount)}\n`
  result += `적립 포인트: ${data.totalVolumeCredits}점\n`
  return result;

- function usd(aNumber) {
-   return new Intl.NumberFormat("en-US", {
-     style: "currency", 
-     currency: "USD",
-     minimumFractionDigits: 2,
-   }).format(aNumber/100);
- }
}

+function htmlStatement(invoice, plays) {
+ return renderHtml(createStatementData(invoice, plays)); // 중간 데이터 생성 함수를 공유
+}

+function renderHtml(data) {
+ let result = `<h1>청구 내역 (고객명: ${data.customer})</h1>\n`;
+ result += "<table>\n";
+ result += "<tr><th>연극</th><th>좌석 수</th><th>금액</th></tr>";
+ for (let perf of data.performances) {
+   result += `   <tr><td>${perf.play.name}</td><td>${perf.audience}석</td>`
+   result += `<td>${usd(perf.amount)}</td></tr>\n`;
+ }
+ result += "</table>\n";
+ result += `<p>총액: <em>${usd(data.totalAmount)}</em></p>\n`
+ result += `<p>적립 포인트: <em>${data.totalVolumeCredits}</em>점</p>\n`
+ return result;
+}

+function usd(aNumber) {
+ return new Intl.NumberFormat("en-US", {
+   style: "currency", 
+   currency: "USD",
+   minimumFractionDigits: 2,
+ }).format(aNumber/100);
+}

// createStatementData.js
export default function createStatementData(invoice, plays) {
  const result = {};
  result.customer = invoice.customer;
  result.performances = invoice.performances.map(enrichPerformace);
  result.totalAmount = totalAmount(statementData);
  result.totalVolumeCredits = totalVolumeCredits(statementData);
  return result;

  function enrichPerformace(aPerformance) {
    const result = Object.assign({}, aPerformance);
    result.play = playFor(result);
    result.amount = amountFor(result);
    result.volumeCredits = volumeCreditsFor(result);
    return result;
  }

  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }

  function amountFor(aPerformance) {
    let result = 0;
    switch(aPerformance.play.type) {
      case "tragedy": // 비극
        result = 40000;
        if (aPerformance.audience > 30) {  
          result += 1000 * (aPerformance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (aPerformance.audience > 20) {  
          result += 10000 + 500 * (aPerformance.audience - 30);
        }
        result += 300 * aPerformance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${aPerformance.play.type}`);
    }
    return result;
  }

  function volumeCreditsFor(aPerformance) {  
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
    if ("comedy" === aPerformance.play.type) result += Math.floor(aPerformance.audience / 5);
    return result;
  }

  function totalAmount(data) {
    return data.performances.reduce((total, p) => total + p.amount, 0); // for 반복문을 파이프라인으로 바꿈
  }

  function totalVolumeCredits(data) {
    let result = 0;
    return data.performances.reduce((total, p) => total + p.volumeCredits, 0); // for 반복문을 파이프라인으로 바꿈
  }
}
```
> `usd()`를 `renderHtml()`에서도 사용할 수 있도록 최상위로 옮긴다.