### 1.6 계산 단계와 포맷팅 단계 분리하기
지금까지는 프로그램의 논리적인 요소를 파악하기 쉽도록 코드의 구조를 보강하는 데 주안점을 두고 리팩터링했다. 리팩터링 초기 단계에서 흔히 수행하는 일이다. 복잡하게 얽힌 덩어리를 잘게 쪼개는 작업은 이름을 잘 짓는 일만큼 중요하다.

골격은 충분히 개선됐으니 이제 원하던 기능 기능 변경, 즉 `statement()`의 HTML 버전을 만드는 작업을 살펴보자. 여러 각도에서 볼 때 확실히 처음 코드보다 작업하기 편해졌다. 계산 코드가 모두 분리됐기 때문에 일곱 줄짜리 최상단 코드에 대응하는 HTML 버전만 작성하면 된다. 그런데 문제가 하나 있다. 분리된 계산 함수들이 텍스트 버전인 `statement()` 안에 중첩 함수로 들어가 있는 게 아닌가. 이 모두를 그대로 복사해 붙이는 방식으로 HTML 버전을 만들고 싶진 않다. 텍스트 버전과 HTML 버전 함수 모두가 똑같은 계산 함수들을 사용하게 만들고 싶다.

다양한 해결책 중 내가 가장 선호하는 방식은 [6.11 단계 쪼개기(Split Phase)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-11.md)다. 내 목표는 `statement()`의 로직을 두 단계로 나누는 것이다. 첫 단계에서는 `statement()`에 필요한 데이터를 처리하고, 다음 단계에서는 앞서 처리한 결과를 텍스트나 HTML로 표현하도록 하자. 다시 말해 첫 번째 단계에서는 두 번째 단계로 전달할 중간 데이터 구조를 생성하는 것이다.

#### STEP 1
단계를 쪼개려면 먼저 두 번째 단계가 될 코드들을 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md)로 뽑아내야 한다. 이 예에서 두 번째 단계는 청구 내역을 출력하는 코드인데, 현재는 `statement()`의 본문 전체가 여기 해당한다.
``` diff
function statement(invoice, plays) {
+ return renderPlainText(invoice, plays); // 본문 전체를 별도의 함수로 추출
+}

+function renderPlainText(invoice, plays) { // 본문 전체를 별도의 함수로 추출
  let result = `청구 내역 (고객명: ${invoice.customer})\n`;
  for (let perf of invoice.performances) {
    // 청구 내역을 출력한다.
    result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)`;
  }
  result += `총액: ${usd(totalAmount())}\n`
  result += `적립 포인트: ${totalVolumeCredits()}점\n`
  return result;

  function totalAmount() {  
    let result = 0;
    for (let perf of invoice.performances) {
      result += amountFor(perf);
    }
    return result;
  }

  function totalVolumeCredits() {
    let result = 0;
    for (let perf of invoice.performances) {
      result += volumeCreditsFor(perf);
    }
    return result;
  }

  function usd(aNumber) {  
    return new Intl.NumberFormat("en-US", {
      style: "currency", 
      currency: "USD",
      minimumFractionDigits: 2,
    }).format(aNumber/100);
  }

  function volumeCreditsFor(aPerformance) {  
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
    if ("comedy" === playFor(aPerformance).type) volumeCredits += Math.floor(aPerformance.audience / 5);
    return result;
  }

  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }

  function amountFor(aPerformance) {  
    let result = 0;
    switch(playFor(aPerformance).type) {
      case "tragedy": // 비극
        result = 40000;
        if (aPerformance.audience > 30) {  
          result += 1000 * (aPerformance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (aPerformance.audience > 20) {  
          result += 10000   500 * (aPerformance.audience - 30);
        }
        result += 300 * aPerformance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${playFor(aPerformance).type}`);
    }
    return result;
  }  
}
```
항상 하듯이 수정한 코드를 컴파일-테스트-커밋한다.
#### STEP 2
다음으로 두 단계 사이의 중간 데이터 구조 역할을 할 객체를 만들어서 `renderPlainText()`에 인수로 전달한다(컴파일-테스트-커밋).
``` diff
function statement(invoice, plays) {
+ const statementData = {};
- return renderPlainText(invoice, plays);
+ return renderPlainText(statementData, invoice, plays); // 중간 데이터 구조를 인수로 전달
}

-function renderPlainText(invoice, plays) {
+function renderPlainText(data, invoice, plays) { // 중간 데이터 구조를 인수로 전달
  let result = `청구 내역 (고객명: ${invoice.customer})\n`;
  for (let perf of invoice.performances) {
    // 청구 내역을 출력한다.
    result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)`;
  }
  result += `총액: ${usd(totalAmount())}\n`
  result += `적립 포인트: ${totalVolumeCredits()}점\n`
  return result;

  function totalAmount() {  
    let result = 0;
    for (let perf of invoice.performances) {
      result += amountFor(perf);
    }
    return result;
  }

  function totalVolumeCredits() {
    let result = 0;
    for (let perf of invoice.performances) {
      result += volumeCreditsFor(perf);
    }
    return result;
  }

  function usd(aNumber) {  
    return new Intl.NumberFormat("en-US", {
      style: "currency", 
      currency: "USD",
      minimumFractionDigits: 2,
    }).format(aNumber/100);
  }

  function volumeCreditsFor(aPerformance) {  
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
    if ("comedy" === playFor(aPerformance).type) volumeCredits += Math.floor(aPerformance.audience / 5);
    return result;
  }

  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }

  function amountFor(aPerformance) {  
    let result = 0;
    switch(playFor(aPerformance).type) {
      case "tragedy": // 비극
        result = 40000;
        if (aPerformance.audience > 30) {  
          result += 1000 * (aPerformance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (aPerformance.audience > 20) {  
          result += 10000   500 * (aPerformance.audience - 30);
        }
        result += 300 * aPerformance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${playFor(aPerformance).type}`);
    }
    return result;
  }  
}
```
#### STEP 2
이번에는 `renderPlainText()`의 다른 두 인수(`invoice`와 `plays`)를 살펴보자. 이 인수들을 통해 전달되는 데이터를 모두 방금 만든 중간 데이터 구조로 옮기면, 계산 관련 코드는 전부 `statement()` 함수로 모으고 `renderPlainText()`는 `data` 매개변수로 전달된 데이터만 처리하게 만들 수 있다.

가장 먼저 고객 정보부터 중간 데이터 구조로 옮긴다(컴파일-테스트-커밋).
``` diff
function statement(invoice, plays) {
  const statementData = {};
+ statementData.customer = invoice.customer;  // 고객 데이터를 중간 데이터로 옮김
  return renderPlainText(statementData, invoice, plays);
}

function renderPlainText(data, invoice, plays) {
- let result = `청구 내역 (고객명: ${invoice.customer})\n`;
+ let result = `청구 내역 (고객명: ${data.customer})\n`; // 고객 데이터를 중간 데이터로부터 얻음
  for (let perf of invoice.performances) {
    // 청구 내역을 출력한다.
    result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)`;
  }
  result += `총액: ${usd(totalAmount())}\n`
  result += `적립 포인트: ${totalVolumeCredits()}점\n`
  return result;

  function totalAmount() {  
    let result = 0;
    for (let perf of invoice.performances) {
      result += amountFor(perf);
    }
    return result;
  }

  function totalVolumeCredits() {
    let result = 0;
    for (let perf of invoice.performances) {
      result += volumeCreditsFor(perf);
    }
    return result;
  }

  function usd(aNumber) {  
    return new Intl.NumberFormat("en-US", {
      style: "currency", 
      currency: "USD",
      minimumFractionDigits: 2,
    }).format(aNumber/100);
  }

  function volumeCreditsFor(aPerformance) {  
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
    if ("comedy" === playFor(aPerformance).type) volumeCredits += Math.floor(aPerformance.audience / 5);
    return result;
  }

  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }

  function amountFor(aPerformance) {  
    let result = 0;
    switch(playFor(aPerformance).type) {
      case "tragedy": // 비극
        result = 40000;
        if (aPerformance.audience > 30) {  
          result += 1000 * (aPerformance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (aPerformance.audience > 20) {  
          result += 10000   500 * (aPerformance.audience - 30);
        }
        result += 300 * aPerformance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${playFor(aPerformance).type}`);
    }
    return result;
  }  
}
```
#### STEP 3
같은 방식으로 공연 정보까지 중간 데이터 구조로 옮기고 나면 `renderPlainText()`의 `invoice` 매개변수를 삭제해도 된다(컴파일-테스트-커밋).
``` diff
function statement(invoice, plays) {
  const statementData = {};
  statementData.customer = invoice.customer;
+ statementData.performances = invoice.performances; // 공연 정보를 중간 데이터로 옮김
- return renderPlainText(statementData, invoice, plays);
+ return renderPlainText(statementData, plays); // 필요 없어진 인수 삭제
}

function renderPlainText(data, invoice, plays) {
  let result = `청구 내역 (고객명: ${data.customer})\n`;
- for (let perf of invoice.performances) {
+ for (let perf of data.performances) {  
    // 청구 내역을 출력한다.
    result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)`;
  }
  result += `총액: ${usd(totalAmount())}\n`
  result += `적립 포인트: ${totalVolumeCredits()}점\n`
  return result;

  function totalAmount() {  
    let result = 0;
-   for (let perf of invoice.performances) {
+   for (let perf of data.performances) {  
      result += amountFor(perf);
    }
    return result;
  }

  function totalVolumeCredits() {
    let result = 0;
-   for (let perf of invoice.performances) {
+   for (let perf of data.performances) {  
      result += volumeCreditsFor(perf);
    }
    return result;
  }

  function usd(aNumber) {  
    return new Intl.NumberFormat("en-US", {
      style: "currency", 
      currency: "USD",
      minimumFractionDigits: 2,
    }).format(aNumber/100);
  }

  function volumeCreditsFor(aPerformance) {  
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
    if ("comedy" === playFor(aPerformance).type) volumeCredits += Math.floor(aPerformance.audience / 5);
    return result;
  }

  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }

  function amountFor(aPerformance) {  
    let result = 0;
    switch(playFor(aPerformance).type) {
      case "tragedy": // 비극
        result = 40000;
        if (aPerformance.audience > 30) {  
          result += 1000 * (aPerformance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (aPerformance.audience > 20) {  
          result += 10000   500 * (aPerformance.audience - 30);
        }
        result += 300 * aPerformance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${playFor(aPerformance).type}`);
    }
    return result;
  }  
}
```
#### STEP 4
이제 연극 제목도 중간 데이터 구조에서 가져오도록 한다. 이를 위해 공연 정보 레코드에 연극 데이터를 추가해야 한다(컴파일-테스트-커밋).
``` diff
function statement(invoice, plays) {
  const statementData = {};
  statementData.customer = invoice.customer;
  statementData.performances = invoice.performances;
  return renderPlainText(statementData, plays);

+ function enrichPerformace(aPerformance) {
+   const result = Object.assign({}, aPerformance); // 얕은 복사 수행
+   return result;
+ }
}

function renderPlainText(data, invoice, plays) {
  let result = `청구 내역 (고객명: ${data.customer})\n`;
  for (let perf of data.performances) {  
    // 청구 내역을 출력한다.
    result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)`;
  }
  result += `총액: ${usd(totalAmount())}\n`
  result += `적립 포인트: ${totalVolumeCredits()}점\n`
  return result;

  function totalAmount() {  
    let result = 0;
    for (let perf of data.performances) {  
      result += amountFor(perf);
    }
    return result;
  }

  function totalVolumeCredits() {
    let result = 0;
    for (let perf of data.performances) {  
      result += volumeCreditsFor(perf);
    }
    return result;
  }

  function usd(aNumber) {  
    return new Intl.NumberFormat("en-US", {
      style: "currency", 
      currency: "USD",
      minimumFractionDigits: 2,
    }).format(aNumber/100);
  }

  function volumeCreditsFor(aPerformance) {  
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
    if ("comedy" === playFor(aPerformance).type) volumeCredits += Math.floor(aPerformance.audience / 5);
    return result;
  }

  function playFor(aPerformance) {
    return plays[aPerformance.playID];
  }

  function amountFor(aPerformance) {  
    let result = 0;
    switch(playFor(aPerformance).type) {
      case "tragedy": // 비극
        result = 40000;
        if (aPerformance.audience > 30) {  
          result += 1000 * (aPerformance.audience - 30);
        }
        break;
      case "comedy": // 희극
        result = 30000;
        if (aPerformance.audience > 20) {  
          result += 10000   500 * (aPerformance.audience - 30);
        }
        result += 300 * aPerformance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${playFor(aPerformance).type}`);
    }
    return result;
  }  
}
```
여기서는 공연 객체를 복사하기만 했지만, 잠시 후 이렇게 새로 만든 레코드에 데이터를 채울 것이다. 이때 복사를 한 이유는 함수로 건넨 데이터를 수정하기 싫어서다. 가변(mutable) 데이터는 금방 상하기 때문에 나는 데이터를 최대한 불변(mutable)처럼 취급한다.