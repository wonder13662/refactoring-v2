# 8.6 문장 슬라이드하기(Slide Statements)
```diff
const pricingPlan = retrievePricingPlan();
+const chargePerUnit = pricingPlan.unit;
const order = retreiveOrder();
let charge;
-const chargePerUnit = pricingPlan.unit;
```
## 배경
관련된 코드들이 가까이 모여 있다면 이해하기가 더 쉽다. 예컨대 하나의 데이터 구조를 이용하는 문장들은 (다른 데이터를 이용하는 코드 사이에 흩어져 있기보다는) 한데 모여 있어야 좋다. 실제로 나는 문장 슬라이드하기 리팩터링으로 이런 코드들을 한데 모아둔다. 가장 흔한 사례는 변수를 선언하고 사용할 때다. 모든 변수 선언을 함수 첫머리에 모아두는 사람도 있는데, 나는 변수를 처음 사용할 때 선언하는 스타일을 선호한다.

관련 코드끼리 모으는 작업은 다른 리팩터링([6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md))의 준비 단계로 자주 행해진다. 관련 있는 코드들을 명확히 구분되는 함수로 추출하는 게 그저 문장들을 한데로 모으는 것보다 나은 분리법이다. 하지만 코드들이 모여 있지 않다면 함수 추출은 애초에 수행할 수 조차 없다.
## 절차
### (1)
코드 조각(문장들)을 이동할 목표 위치를 찾는다. 코드 조각의 원래 위치와 목표 위치 사이의 코드들을 훑어보면서, 조각을 모으고 나면 동작이 달라지는 코드가 있는지 살핀다. 다음과 같은 간섭이 있다면 이 리팩터링을 포기한다.
  - 코드 조각에서 참조하는 요소를 선언하는 문장 앞으로는 이동할 수 없다.
  - 코드 조각을 참조하는 요소의 뒤로는 이동할 수 없다.
  - 코드 조각에서 참조하는 요소를 수정하는 문장을 건너뛰어 이동할 수 없다.
  - 코드 조각이 수정하는 요소를 참조하는 요소를 건너뛰어 이동할 수 없다.
### (2)
코드 조각을 원래 위치에서 잘라내어 목표 위치에 붙여 넣는다.
### (3)
테스트한다.

테스트가 실패한다면 더 작게 나눠 시도해보라. 이동 거리를 줄이는 방법과 한 번에 옮기는 조각의 크기를 줄이는 방법이 있다.

## 예시
코드 조각을 슬라이드할 때는 두 가지를 확인해야 한다. 무엇을 슬라이드할지와 슬라이드할 수 있는지 여부다. 무엇을 슬라이드할지는 맥락과 관련이 깊다. 가장 단순하게는, 요소를 선언하는 곳과 사용하는 곳을 가까이 두기를 좋아하는 나는 선언 코드를 슬라이드하여 처음 사용하는 곳까지 끌어내리는 일을 자주 한다. 그 외에도 다른 리팩터링을 하기 위해서는 거의 항상 코드를 슬라이드하게 된다. 예컨대 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md) 전에 추출할 코드를 한데 모을 때 적용한다.

코드 조각을 슬라이드하기로 했다면, 다음 단계로는 그 일이 실제로 가능한지를 점검해야 한다. 그러려면 슬라이드할 코드 자체와 그 코드가 건너뛰어야 할 코드를 모두 살펴야 한다. 이 코드들의 순서가 바뀌면 프로그램의 겉보기 동작이 달라지는가?

다음 코드를 예로 살펴보자.
``` javascript
(01) const pricingPlan = retreivePricingPlan();
(02) const order = retreiveOrder();
(03) const baseCharge = pricingPlan.base;
(04) let charge;
(05) const chargePerUnit = pricingPlan.unit;
(06) const units = order.units;
(07) let discount;
(08) charge = baseCharge + units * chargePerUnit;
(09) let discountableUnits = Math.max(units - pricingPlan.discountThresold, 0);
(10) discount = discountableUnits * pricingPlan.discountFactor;
(11) if (order.isRepeat) discount += 20;
(12) charge = charge - discount;
(13) chargeOrder(charge);
```
처음 일곱 줄은 선언이므로 이동하기가 상대적으로 쉽다. 예컨대 할인 관련 코드를 한데 모으고 싶다면 (07)번 줄(`let discount;`)을 (10)번 줄(`discount = ...`) 바로 위까지 내리면 된다. 선언은 부수효과가 없고 다른 변수를 참조하지도 않으므로 `discount` 자신을 참조하는 첫 번째 코드 바로 앞까지는 어디로든 옮겨도 안전하다. 이런 이동은 여러 상황에서 공통적으로 행해진다. 예컨대 할인 로직을 별도 함수로 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md)하고 싶다면, 추출하기 전에 이 선언의 위치부터 옮겨줘야 한다.

부수효과가 없는 다른 코드에도 비슷한 분석을 수행해보면 (02)번 줄(`const order = ...`)도 (06)번 줄(`const units = ...`) 바로 위로 옮겨도 문제가 없음을 알 수 있다.

이 경우 건너뛰어지는 코드들도 부수효과가 없다는 점이 도움이 됐다. 사실 부수효과가 없는 코드들끼리는 마음 가는 대로 재배치할 수 있다. 현명한 프로그래머들이 되도록 부수효과 없는 코드들로 프로그래밍하는 이유 중 하나다.

여기서 짚고 넘어갈 게 있다. 나는 (02)번 줄이 부수효과가 없다는 걸 어떻게 알았을까? 확실히 하려면 `retreiveOrder()`의 내부(그리고 그 안에서 호출하는 모든 함수의 내부도...또 그 내부도...)를 살펴 아무 부수효과가 없음을 확인해야 한다. 하지만 나는 거의 [명령-질의 분리 원칙](https://martinfowler.com/bliki/CommandQuerySeparation.html)을 지켜가며 코딩하므로, 내가 직접 작성한 코드라면 값을 반환하는 함수는 모두 부수효과가 없음을 알고 있던 것이다. 단, 코드베이스에 대해 잘 알 때만 이 점을 확신할 수 있다. 잘 모르는 코드베이스에서 작업한다면 더욱 주의해야 한다. 어쨌든 사용하는 코드가 부수효과가 없음을 안다는 것의 가치는 아주 크므로, 나는 내 코드에서만이라도 항상 [명령-질의 분리 원칙](https://martinfowler.com/bliki/CommandQuerySeparation.html)을 지키려 노력한다.

부수효과가 있는 코드를 슬라이드하거나 부수효과가 있는 코드를 건너뛰어야 한다면 훨씬 신중해야 한다. 두 코드 조각 사이에 간섭이 있는지를 확인해야 한다. 자, (11)번 줄(`if (order.isRepeat) ...`)을 코드 끝으로 슬라이드하고 싶다고 해보자. 이 작업은 (12)번 줄(`charge = charge - discount;`) 때문에 가로막히는데, (11)번 줄에서 상태를 수정한 변수 `discount`를 (12)번 줄에서 참조하기 때문이다. 비슷하게, (13)번 줄(`chargeOrder(charge);`)도 (12)번 줄 앞으로 이동할 수 없다. (13)번 줄이 참조하는 변수 `charge`를 (12)번 줄에서 수정하기 때문이다. 하지만 (08)번 줄(`charge = baseCharge + ...`)은 (09)~(11)번 줄을 건너 뛸 수 있다. 이 코드들에서는 공통된 상태를 수정하는 일이 전혀 없기 때문이다.

슬라이드할 코드 조각과 건너뛸 코드 중 어느 한쪽이 다른 쪽에서 참조하는 데이터를 수정한다면 슬라이드를 할 수 없다.이것이 가장 직관적인 규칙이다. 하지만 완벽한 규칙은 아닌 것이, 다음 두 줄은 순서를 바꿔도 안전하다.
``` javascript
a = a + 10;
a = a + 5;
```
슬라이드가 안전한 지를 판단하려면 관련된 연산이 무엇이고 어떻게 구성되는지를 완벽히 이해해야 한다. 

상태 갱신에 특히나 신경 써야 하기 때문에 상태를 갱신하는 코드 자체를 최대한 제거하는 게 좋다. 그래서 나라면 이 코드에 다른 어떤 슬라이드를 시도하기 앞서 `charge` 변수를 쪼갤 것이다([9.1 변수 쪼개기(Split Variable)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter09/9-1.md)).

지금 예에서는 지역 변수만 수정하고 있으니 분석하기가 상대적으로 쉽다. 데이터 구조가 더 복잡했다면 간섭 여부를 확신하기가 훨씬 어려웠을 거다. 그래서 테스트가 중요한 역할을 한다. 조각을 슬라이드한 후 테스트를 수행해서 깨지는 게 없는지 살피자. 테스트 커버리지가 높다면 마음 편히 리팩터링할 수 있다. 테스트를 믿을 수 없다면 리팩터링을 더 신중히 진행한다. 혹은 (더 흔하게는) 당장의 리팩터링에 영향받는 코드의 테스트를 보강한다.

슬라이드 후 테스트가 실패했을 때 가장 좋은 대처는 더 작게 슬라이드해보는 것이다. 열 줄을 건너뛰는 대신 다섯 줄만 건너뛰거나, 위험해 보이는 줄까지만 슬라이드해보자. 테스트 실패는 그 슬라이드를 수행할 가치가 없거나, 다른 무언가를 먼저 하라는 뜻일 수도 있다.
## 예시: 조건문이 있을 때의 슬라이드
조건문의 안팎으로 슬라이드해야 할 때도 있다. 조건문 밖으로 슬라이드할 때는 중복 로직이 제거될 것이고, 조건문 안으로 슬라이드할 때는 반대로 중복 로직이 추가될 것이다.

다음 조건문의 두 분기에는 똑같은 문장이 포함되어 있다.
``` javascript
let result;
if (availableResources.length === 0) {
  result = createResource();
  allocateResources.push(result);
} else {
  result = allocateResources.pop();
  allocateResources.push(result);
}
return result;
```
### STEP 1
이때 중복된 문장들을 조건문 밖으로 슬라이드 할 수 있는데, 조건문 블록 밖으로 꺼내는 순간 한 문장으로 합쳐진다.
``` diff
let result;
if (availableResources.length === 0) {
  result = createResource();
- allocateResources.push(result);
} else {
  result = allocateResources.pop();
- allocateResources.push(result);
}
+allocateResources.push(result);
return result;
```
반대의 상황, 즉 코드 조각을 조건문 안으로 슬라이드하면 조건문의 모든 분기에 복제되어 들어간다.
#### 더 읽을거리
[문장 교환하기(Swap Statement)](https://www.industriallogic.com/blog/swap-statement-refactoring/)라는 이름의 거의 똑같은 리팩터링도 있다. 문장 교환하기는 인접한 코드 조각을 이동하지만, 문장 하나짜리 조각만 취급한다. 따라서 이동할 조각과 건너뛸 조각 모두 단일 문장으로 구성된 문장 슬라이드로 생각해도 된다.이 리팩터링도 매력적이다. 나는 항상 단계를 잘게 나눠 리팩터링하는데, 리팩터링을 처음 접하는 이들도 보기에는 어리석어 보일 정도로 작은 단계들을 밟는다.

하지만 종국에는 큰 조각을 다루는 리팩터링들만 책에 싣기로 했다. 실제로 내가 그렇게 하기 때문이다. 나는 클 슬라이드를 수행하기 어려울 때만 한 문장씩 이동한다. 큰 슬라이드에서 어려움을 겪는 일은 드물었다. 하지만 더 지저분한 코드를 정리할 때는 더 작게 슬라이드하는 편이 나을 것이다.

- [8.5 인라인 코드를 함수 호출로 바꾸기(Replace Inline Code with Function Call)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-5.md)
- [8.7 반복문 쪼개기(Split loop)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-7.md)
