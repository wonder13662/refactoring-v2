### 8.8 반복문을 파이프라인으로 바꾸기(Replace Loop with Pipeline)
``` diff
-const names = [];
-for (const i of input) {
- if (i.job === "programmer")
-   names.push(i.name);
-}
+const names = input.filter(i => i.job === "programmer").map(i => i.name);
```
#### 배경
프로그래머 대부분이 그렇듯 나도 객체 컬렉션을 순회할 때 반복문을 사용하라고 배웠다. 하지만 언어는 계속해서 더 나은 구조를 제공하는 쪽으로 발전해왔다. 예컨대 이번 이야기의 주인공인 [컬렉션 파이프라인(Collection Pipeline)](https://martinfowler.com/articles/collection-pipeline/)을 이용하면 처리 과정을 일련의 연산으로 표현할 수 있다. 이때 각 연산은 컬렉션을 입력받아 다른 컬렉션을 내밷는다. 대표적인 연산은 map과 filter다. map은 함수를 사용해 입력 컬렉션의 각 원소를 변환하고, filter는 또 다른 함수를 사용해 입력 컬렉션을 필터링해 부분집합을 만든다. 이 부분집합은 파이프라인의 다음 단계를 위한 컬렉션으로 쓰인다. 논리를 파이프라인으로 표현하면 이해하기 훨씬 쉬워진다. 객체가 파이프라인을 따라 흐르며 어떻게 처리되는지를 읽을 수 있기 때문이다.
#### 절차
##### (1)
- 반복문에서 사용하는 컬렉션을 가리키는 변수를 하나 만든다.
   - 기존 변수를 단순히 복사한 것일 수도 있다.
##### (2)
- 반복문의 첫 줄부터 시작해서, 각각의 단위 행위를 적절한 컬렉션 파이프라인 연산으로 대체한다. 이 때 컬렉션 파이프라인 연산은 [(1)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-8.md#1)에서 만든 반복문 컬렉션 변수에서 시작하여, 이전 연산의 결과를 기초로 연쇄적으로 수행된다. 하나를 대체할 때마다 테스트한다.
##### (3)
- 반복문의 모든 동작을 대체했다면 반복문 자체를 지운다.
   - 반복문이 결과를 누적 변수(accumulator)에 대입했다면 파이프라인의 결과를 그 누적 변수에 대입한다.
#### 예시
다음은 예시를 위한 데이터로, 내 회사의 지점 사무실 정보를 CSV 형태로 정리한 것이다.
``` csv
office, country, telephone
Chicago, USA, +1 312 373 1000
Beijing, China +86 4008 900 505
Bangalore, India, +91 80 4064 9570
Porto Alegre, Brazil, +55 51 3079 3550
Chennai, India, +91 44 660 44766
...(더 많은 데이터)
```
다음 함수는 인도(India)에 자리한 사무실을 찾아서 도시명과 전화번호를 반환한다.
``` javascript
function acquireData(input) {
  const lines = input.split("\n"); // 컬렉션
  let firstLine = true;
  const result = [];
  for (const line of lines) { // 반복문
    if (firstLine) {
      firstLine = false;
      continue;
    }
    if (line.trim() === "") continue;
    const record = line.split(",");
    if (record[1].trim() === "India") {
      result.push({
        city: record[0].trim(),
        phone: record[2].trim(),
      });
    }
  }

  return result;
}
```
##### STEP 1
이 코드의 반복문을 컬렉션 파이프라인으로 바꿔보자.[(1)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-8.md#1)첫번째로 할 일은 반복문에서 사용하는 컬렉션을 가리키는 별도 변수를 새로 만드는 것이다. 이 변수를 `루프변수(loop variable)`라 하겠다.
``` diff
function acquireData(input) {
  const lines = input.split("\n"); // 컬렉션
  let firstLine = true;
  const result = [];
+ const loopItems = lines;
- for (const line of lines) {
+ for (const line of loopItems) {
    if (firstLine) {
      firstLine = false;
      continue;
    }
    if (line.trim() === "") continue;
    const record = line.split(",");
    if (record[1].trim() === "India") {
      result.push({
        city: record[0].trim(),
        phone: record[2].trim(),
      });
    }
  }

  return result;
}
```
##### STEP 2
[(2)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-8.md#2)이 코드의 반복문에서 첫 if 문은 CSV 데이터의 첫 줄을 건너뛰는 역할이다. 이 작업은 `slice()` 연산을 떠올리게 한다. 자, 이제 `slice()` 연산을 루프 변수에서 수행하고 반복문 안의 if문은 제거하자.
``` diff
function acquireData(input) {
  const lines = input.split("\n"); // 컬렉션
- let firstLine = true;
  const result = [];
- const loopItems = lines;
+ const loopItems = lines.slice(1);
  for (const line of loopItems) {
-   if (firstLine) {
-     firstLine = false;
-     continue;
-   }
    if (line.trim() === "") continue;
    const record = line.split(",");
    if (record[1].trim() === "India") {
      result.push({
        city: record[0].trim(),
        phone: record[2].trim(),
      });
    }
  }

  return result;
}
```
이 단계에서 보너스로 `firstLine` 변수도 지울 수 있게 됐다. 제어용 변수를 지우는 일은 언제나 즐겁다.
##### STEP 3
반복문에서 수행하는 다음 작업은 빈 줄 지우기(trim)다. 이 작업은 filter() 연산으로 대체할 수 있다.
``` diff
function acquireData(input) {
  const lines = input.split("\n"); // 컬렉션
  const result = [];
- const loopItems = lines.slice(1);
+ const loopItems = lines
+                     .slice(1)
+                     .filter(line => line.trim() !== "")
+                     ;
  for (const line of loopItems) {
-   if (line.trim() === "") continue;
    const record = line.split(",");
    if (record[1].trim() === "India") {
      result.push({
        city: record[0].trim(),
        phone: record[2].trim(),
      });
    }
  }

  return result;
}
```
파이프라인을 사용할 때는 문장 종료 세미콜론(;)을 별도 줄에 적어주면 편하다.

##### STEP 4
다음으로 `map()` 연산을 사용해 여러 줄짜리 CSV 데이터를 문자열 배열로 변환한다. 수정 전 코드에서의 `record`라는 변수 이름은 적절치 않은데, 리팩터링을 안전하게 진행하기 위해 지금은 그냥 두고 나중에 수정하겠다.
``` diff
function acquireData(input) {
  const lines = input.split("\n"); // 컬렉션
  const result = [];
  const loopItems = lines
                      .slice(1)
                      .filter(line => line.trim() !== "")
+                     .map(line => line.split(","))
                      ;
  for (const line of loopItems) {
-   const record = line.split(",");
+   const record = line;
    if (record[1].trim() === "India") {
      result.push({
        city: record[0].trim(),
        phone: record[2].trim(),
      });
    }
  }

  return result;
}
```
##### STEP 5
다시 한번 `filter()` 연산을 수행하여 인도에 위치한 사무실 레코드를 뽑아낸다.
``` diff
function acquireData(input) {
  const lines = input.split("\n"); // 컬렉션
  const result = [];
  const loopItems = lines
                      .slice(1)
                      .filter(line => line.trim() !== "")
                      .map(line => line.split(","))
+                     .filter(record => record[1].trim() === "India")
                      ;
  for (const line of loopItems) {
    const record = line;
-   if (record[1].trim() === "India") {
      result.push({
        city: record[0].trim(),
        phone: record[2].trim(),
      });
-   }
  }

  return result;
}
```
##### STEP 6
`map()`을 사용해 결과 레코드를 생성한다.
``` diff
function acquireData(input) {
  const lines = input.split("\n"); // 컬렉션
  const result = [];
  const loopItems = lines
                      .slice(1)
                      .filter(line => line.trim() !== "")
                      .map(line => line.split(","))
                      .filter(record => record[1].trim() === "India")
+                     .map(record => ({ city: record[0].trim(), phone: record[2].trim() }))
                      ;
  for (const line of loopItems) {
    const record = line;
-   result.push({
-     city: record[0].trim(),
-     phone: record[2].trim(),
-   });
+   result.push(line);
  }

  return result;
}
```
##### STEP 7
반복문이 하는 일은 이제 하나만 남았다. 바로 결과를 누적 변수에 추가하는 일이다.[(3)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-8.md#3)파이프 라인의 결과를 누적 변수에 대입해주면 이 코드도 제거할 수 있다.
``` diff
function acquireData(input) {
  const lines = input.split("\n"); // 컬렉션
- const result = [];
- const loopItems = lines
+ const result = lines
                  .slice(1)
                  .filter(line => line.trim() !== "")
                  .map(line => line.split(","))
                  .filter(record => record[1].trim() === "India")
                  .map(record => ({ city: record[0].trim(), phone: record[2].trim() }))
                  ;
- for (const line of loopItems) {
-   const record = line;
-   result.push(line);
- }

  return result;
}
```
#### 더 가다듬기
여기까지가 이번 리팩터링의 핵심이다. 하지만 코드를 좀 더 정리해보자. `result` 변수를 인라인하고, 람다(lamda) 변수 중 일부의 이름을 바꾸고, 코드를 읽기 쉽도록 레이아웃을 표 형태로 정돈하면 다음처럼 된다.
``` diff
function acquireData(input) {
  const lines = input.split("\n"); // 컬렉션
- const result = lines
+ return lines
          .slice(1)
          .filter(line => line.trim() !== "")
          .map(line => line.split(","))
          .filter(record => record[1].trim() === "India")
          .map(record => ({ city: record[0].trim(), phone: record[2].trim() }))
          ;
- return result;
}
```
`lines`도 인라인할까 생각했지만, 그대로 두는 편이 코드가 수행하는 일을 더 잘 설명해 준다고 판단하여 그대로 뒀다.
#### 더 읽을거리
반복문을 파이프라인으로 대체하는 예를 더 보고 싶다면 내 블로그의 [Refactoring with Loops and Collection Pipelines](https://martinfowler.com/articles/refactoring-pipelines.html)를 참고하기 바란다.