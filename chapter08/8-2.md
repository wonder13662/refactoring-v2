### 8.2 필드 옮기기(Move Field)
``` diff
class Customer {
  get plan() { return this._plan; }
- get discountRate() { return this._discountRate; }
+ get discountRate() { return this.plan.discountRate; }
}
```
#### 배경
프로그램의 상당 부분이 동작을 구현하는 코드로 이뤄지지만 프로그램의 진짜 힘은 데이터 구조에서 나온다. 주어진 문제에 적합한 데이터 구조를 활용하면 동작 코드는 자연스럽게 단순하고 직관적으로 짜여진다. 반면 데이터 구조를 잘못 선택하면 아귀가 맞지 않는 데이터를 다루기 위한 코드로 범벅이 된다. 이해하기 어려운 코드가 만들어지는 데서 끝나지 않고, 데이터 구조 자체도 그 프로그램이 어떤 일을 하는지 파악하기 어렵게 한다.

그래서 데이터 구조가 중요하다. 하지만 훌륭한 프로그램이 갖춰야 할 다른 요인들과 마찬가지로, 제대로 하기 어렵다. 가장 적합한 데이터 구조를 알아내고자 프로젝트 초기에 분석을 해본 결과, 경험과 도메인 주도 설계 같은 기술이 내 능력을 개선하줌을 알아냈다. 하지만 나의 모든 기술과 경험에도 불구하고 초기 설계에서는 실수가 빈번했다. 프로젝트를 진행할수록 우리는 문제 도메인과 데이터 구조에 대해 더 많은 것을 배우게 된다. 그래서 오늘까지는 합리적이고 올바른 설계가 다음 주가 되면 잘못된 것으로 판명나곤 한다.

현재 데이터 구조가 적절치 않음을 깨닫게 되면 곧바로 수정해야 한다. 고치지 않고 데이터 구조에 남겨진 흠들은 우리 머릿속을 혼란스럽게 하고 훗날 작성하게 될 코드를 더욱 복잡하게 만들어 버린다.

예컨대 함수에 어떤 레코드를 넘길 때마다 또 다른 레코드의 필드도 함께 넘기고 있다면 데이터 위치를 옮겨야 할 것이다. 함수에 항상 함께 건네지는 데이터 조각들은 상호 관계가 명확하게 드러나도록 한 레코드에 담는 게 가장 좋다. 변경 역시 주요한 요인이다. 한 레코드를 변경하려 할 때 다른 레코드의 필드까지 변경해야 한다면 필드의 위치가 잘못되었다는 신호다. 구조체 여러 개에 정의된 똑같은 필드들을 갱신해야 한다면 한 번만 갱신해도 되는 다른 위치로 옮기라는 신호다.

필드 옮기기 리팩터링은 대체로 더 큰 변경의 일환으로 수행된다. 예컨대 필드 하나를 잘 옮기면, 그 필드를 사용하던 많은 코드가 원래 위치보다 옮겨진 위칭에서 사용하는 게 더 수월할 수 있다. 그렇다면 리팩터링을 마저 진행하여 호출 코드들까지 모두 변경한다. 비슷하게, 옮기려는 데이ㅓ가 쓰이는 패턴 때문에 당장은 필드를 옮길 수 없을 때도 있다. 이럴 땐 사용 패턴을 먼저 리팩터링한 다음에 필드를 옮겨준다.

지금까지의 설명에서 레코드라는 용어를 썼지만, 레코드 대신 클래스나 객체가 와도 똑같다. 클래스는 함수가 곁들여진 레코드라 할 수 있으며, 다른 데이터와 마찬가지로 건강하게 관리돼야 한다. 클래스의 데이터들은 접근자 메서드들 뒤에 감춰져(캡슐화되어) 있으므로 클래스에 곁들여진 함수(메서드)들은 데이터를 이러저리 옮기는 작업을 쉽게 해준다. 데이터의 위치를 옮기더라도 접근자만 그에 맞게 수정하면 클라이언트 코드들은 아무 수정 없이도 동작할 것이다. 따라서 클래스를 사용하면 이 리팩터링을 수행하기가 더 쉬워지며, 그래서 이어지는 설명에서는 클래스를 사용한다고 가정한다. 캠슐화되지 않는 날(bare) 것의 레코드를 사용해도 똑같이 변경 할 수는 있지만, 더 까다로울 것이다.
#### 절차
##### (1)
- 소스 필드가 캡슐화되어 있지 않다면 캡슐화한다.
##### (2)
- 테스트한다.
##### (3)
- 타깃 객체에 필드(와 접근자 메서드들)를 생성한다.
##### (4)
- 정적 검사를 수행한다.
##### (5)
- 소스 객체에서 타깃 객체를 참조할 수 있는지 확인한다.
   - 기존 필드나 메서드 중 타깃 객체를 넘겨주는 게 있을지 모른다. 없다면 이런 기능의 메서드를 쉽게 만들 수 있는지 살펴본다. 간단치 않다면 타깃 객체를 저장할 새 필드를 소스 객체에 생성하자.이는 영구적인 변경이 되겠지만, 더 넓은 맥락에서 리팩터링을 충분히 하고 나면 다시 없앨 수 있을 때도 있다.
##### (6)
- 접근자들이 타깃 필드를 사용하도록 수정한다.
   - 여러 소스에서 같은 타깃을 공유한다면 먼저 세터를 수정하여 타깃 필드와 소스 필드 모두를 갱신하게 하고, 이어서 일관성을 깨뜨리는 갱신을 검출할 수 있도록 [10.6 어서션 추가하기(Introduce Assertion)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-6.md)를 하자. 모든 게 잘 마무리되었다면 접근자들이 타깃 필드를 사용하도록 수정한다.
##### (7)
- 테스트한다.
##### (8)
- 소스 필드를 제거한다.
##### (9)
- 테스트한다.