# 8.2 필드 옮기기(Move Field)
``` diff
class Customer {
  get plan() { return this._plan; }
- get discountRate() { return this._discountRate; }
+ get discountRate() { return this.plan.discountRate; }
}
```
## 배경
프로그램의 상당 부분이 동작을 구현하는 코드로 이뤄지지만 프로그램의 진짜 힘은 데이터 구조에서 나온다. 주어진 문제에 적합한 데이터 구조를 활용하면 동작 코드는 자연스럽게 단순하고 직관적으로 짜여진다. 반면 데이터 구조를 잘못 선택하면 아귀가 맞지 않는 데이터를 다루기 위한 코드로 범벅이 된다. 이해하기 어려운 코드가 만들어지는 데서 끝나지 않고, 데이터 구조 자체도 그 프로그램이 어떤 일을 하는지 파악하기 어렵게 한다.

그래서 데이터 구조가 중요하다. 하지만 훌륭한 프로그램이 갖춰야 할 다른 요인들과 마찬가지로, 제대로 하기 어렵다. 가장 적합한 데이터 구조를 알아내고자 프로젝트 초기에 분석을 해본 결과, 경험과 도메인 주도 설계 같은 기술이 내 능력을 개선해주는 것을 알아냈다. 하지만 나의 모든 기술과 경험에도 불구하고 초기 설계에서는 실수가 빈번했다. 프로젝트를 진행할수록 우리는 문제 도메인과 데이터 구조에 대해 더 많은 것을 배우게 된다. 그래서 오늘까지는 합리적이고 올바른 설계가 다음 주가 되면 잘못된 것으로 판명나곤 한다.

현재 데이터 구조가 적절치 않음을 깨닫게 되면 곧바로 수정해야 한다. 고치지 않고 데이터 구조에 남겨진 흠들은 우리 머릿속을 혼란스럽게 하고 훗날 작성하게 될 코드를 더욱 복잡하게 만들어 버린다.

예컨대 함수에 어떤 레코드를 넘길 때마다 또 다른 레코드의 필드도 함께 넘기고 있다면 데이터 위치를 옮겨야 할 것이다. 함수에 항상 함께 건네지는 데이터 조각들은 상호 관계가 명확하게 드러나도록 한 레코드에 담는 게 가장 좋다. 변경 역시 주요한 요인이다. 한 레코드를 변경하려 할 때 다른 레코드의 필드까지 변경해야 한다면 필드의 위치가 잘못되었다는 신호다. 구조체 여러 개에 정의된 똑같은 필드들을 갱신해야 한다면 한 번만 갱신해도 되는 다른 위치로 옮기라는 신호다.

필드 옮기기 리팩터링은 대체로 더 큰 변경의 일환으로 수행된다. 예컨대 필드 하나를 잘 옮기면, 그 필드를 사용하던 많은 코드가 원래 위치보다 옮겨진 위칭에서 사용하는 게 더 수월할 수 있다. 그렇다면 리팩터링을 마저 진행하여 호출 코드들까지 모두 변경한다. 비슷하게, 옮기려는 데이터가 쓰이는 패턴 때문에 당장은 필드를 옮길 수 없을 때도 있다. 이럴 땐 사용 패턴을 먼저 리팩터링한 다음에 필드를 옮겨준다.

지금까지의 설명에서 레코드라는 용어를 썼지만, 레코드 대신 클래스나 객체가 와도 똑같다. 클래스는 함수가 곁들여진 레코드라 할 수 있으며, 다른 데이터와 마찬가지로 건강하게 관리돼야 한다. 클래스의 데이터들은 접근자 메서드들 뒤에 감춰져(캡슐화되어) 있으므로 클래스에 곁들여진 함수(메서드)들은 데이터를 이러저리 옮기는 작업을 쉽게 해준다. 데이터의 위치를 옮기더라도 접근자만 그에 맞게 수정하면 클라이언트 코드들은 아무 수정 없이도 동작할 것이다. 따라서 클래스를 사용하면 이 리팩터링을 수행하기가 더 쉬워지며, 그래서 이어지는 설명에서는 클래스를 사용한다고 가정한다. 캡슐화되지 않는 날(bare) 것의 레코드를 사용해도 똑같이 변경 할 수는 있지만, 더 까다로울 것이다.
## 절차
### (1)
소스 필드가 캡슐화되어 있지 않다면 캡슐화한다.
### (2)
테스트한다.
### (3)
타깃 객체에 필드(와 접근자 메서드들)를 생성한다.
### (4)
정적 검사를 수행한다.
### (5)
소스 객체에서 타깃 객체를 참조할 수 있는지 확인한다.
  - 기존 필드나 메서드 중 타깃 객체를 넘겨주는 게 있을지 모른다. 없다면 이런 기능의 메서드를 쉽게 만들 수 있는지 살펴본다. 간단치 않다면 타깃 객체를 저장할 새 필드를 소스 객체에 생성하자.이는 영구적인 변경이 되겠지만, 더 넓은 맥락에서 리팩터링을 충분히 하고 나면 다시 없앨 수 있을 때도 있다.
### (6)
접근자들이 타깃 필드를 사용하도록 수정한다.
  - 여러 소스에서 같은 타깃을 공유한다면 먼저 세터를 수정하여 타깃 필드와 소스 필드 모두를 갱신하게 하고, 이어서 일관성을 깨뜨리는 갱신을 검출할 수 있도록 [10.6 어서션 추가하기(Introduce Assertion)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-6.md)를 하자. 모든 게 잘 마무리되었다면 접근자들이 타깃 필드를 사용하도록 수정한다.
### (7)
테스트한다.
### (8)
소스 필드를 제거한다.
### (9)
테스트한다.
## 예시
다음의 고객 클래스(`Customer`)와 계약 클래스(`CustomerContract`)에서 시작하자.
``` javascript
class Customer {
  constructor(name, discountRate) {
    this._name = name;
    this._discountRate = discountRate;
    this._contract = new CustomerContract(dateToday());
  }

  get discountRate() { return this._discountRate; }
  becomePreferred() {
    this._discountRate += 0.03;
    // 다른 멋진 일들
  }
  applyDiscount(amount) {
    return amount.subtract(amount.multiply(this._discountRate));
  }
}
class CustomerContract {
  constructor(startDate) {
    this._startDate = startDate;
  }
}
```
### STEP 1-1
여기서 할인율을 뜻하는 `discountRate` 필드를 `Customer`에서 `CustomerContract`로 옮기고 싶다고 해보자.
[(1)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-2.md#1)가장 먼저 할 일은 이 필드를 캡슐화하는 것이다([6.6 변수 캡슐화하기(Encapsulate Variable)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-6.md)).
``` diff
class Customer {
  constructor(name, discountRate) {
    this._name = name;
-   this._discountRate = discountRate;
+   this._setDiscountRate(discountRate);
    this._contract = new CustomerContract(dateToday());
  }

  get discountRate() { return this._discountRate; }
+ _setDiscountRate(aNumber) { this._discountRate = aNumber; }
  becomePreferred() {
-   this._discountRate += 0.03;
+   this._setDiscountRate(this._discountRate + 0.03);
    // 다른 멋진 일들
  }
  applyDiscount(amount) {
-   return amount.subtract(amount.multiply(this._discountRate));
+   return amount.subtract(amount.multiply(this.discountRate));
  }
}
class CustomerContract {
  constructor(startDate) {
    this._startDate = startDate;
  }
}
```
할인율을 수정하는 public 세터를 만들고 싶지는 않아서 세터 속성이 아니라 메서드를 이용했다.
### STEP 1-2
[(3)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-2.md#3) 이제 `CustomerContract` 클래스에 필드 하나와 접근자들을 추가한다.
``` diff
class Customer {
  constructor(name, discountRate) {
    this._name = name;
    this._setDiscountRate(discountRate);
    this._contract = new CustomerContract(dateToday());
  }

  get discountRate() { return this._discountRate; }
  _setDiscountRate(aNumber) { this._discountRate = aNumber; }
  becomePreferred() {
    this._setDiscountRate(this._discountRate + 0.03);
    // 다른 멋진 일들
  }
  applyDiscount(amount) {
    return amount.subtract(amount.multiply(this.discountRate));
  }
}
class CustomerContract {
- constructor(startDate) {
+ constructor(startDate, discountRate) {
    this._startDate = startDate;
+   this._discountRate = discountRate;
  }

+ get discountRate() { return this._discountRate; }
+ set discountRate(arg) { this._discountRate = arg; }
}
```
### STEP 1-3
[(6)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-2.md#6) 그런 다음 `Customer`의 접근자들이 새로운 필드를 사용하도록 수정한다.
``` diff
class Customer {
  constructor(name, discountRate) {
    this._name = name;
-   this._setDiscountRate(discountRate);
+   this._contract = new CustomerContract(dateToday());
-   this._contract = new CustomerContract(dateToday());
+   this._setDiscountRate(discountRate);
  }

  get discountRate() { return this._discountRate; }
  _setDiscountRate(aNumber) { this._discountRate = aNumber; }
  becomePreferred() {
    this._setDiscountRate(this._discountRate + 0.03);
    // 다른 멋진 일들
  }
  applyDiscount(amount) {
    return amount.subtract(amount.multiply(this.discountRate));
  }
}
class CustomerContract {
  constructor(startDate, discountRate) {
    this._startDate = startDate;
    this._discountRate = discountRate;
  }

  get discountRate() { return this._discountRate; }
  set discountRate(arg) { this._discountRate = arg; }
}
```
다 수정하고 나면 "Cannot set property 'discountRate' of undefined"라는 오류가 날 것이다. 생성자에서 `Contract` 객체를 생성하기도 전에 `_setDiscountRate()`를 호출하기 때문이다. 이 오류를 고치려면 먼저 기존 상태로 되돌린 다음, [8.6 문장 슬라이드하기(Slide Statements)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-6.md)를 적용해 `_setDiscountRate()` 호출을 계약 생성 뒤로 옮겨야 한다.
### STEP 1-4
테스트에 성공하면 접근자들을 다시 수정하여 새로운 계약 인스턴스를 사용하도록 한다.
``` diff
class Customer {
  constructor(name, discountRate) {
    this._name = name;
    this._contract = new CustomerContract(dateToday());
    this._setDiscountRate(discountRate);
  }

- get discountRate() { return this._discountRate; }
+ get discountRate() { return this._contract.discountRate; }
- _setDiscountRate(aNumber) { this._discountRate = aNumber; }
+ _setDiscountRate(aNumber) { this._contract.discountRate = aNumber; }
  becomePreferred() {
    this._setDiscountRate(this._discountRate + 0.03);
    // 다른 멋진 일들
  }
  applyDiscount(amount) {
    return amount.subtract(amount.multiply(this.discountRate));
  }
}
class CustomerContract {
  constructor(startDate, discountRate) {
    this._startDate = startDate;
    this._discountRate = discountRate;
  }

  get discountRate() { return this._discountRate; }
  set discountRate(arg) { this._discountRate = arg; }
}
```
[(8)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-2.md#8) 자바스크립트를 사용하고 있으므로 소스 필드를 미리 선언할 필요는 없었다. 그래서 제거해야 할 것도 없다.
### STEP 1-5 - 날 레코드 변경하기
이 리팩터링은 대체로 객체를 활용할 때가 더 수월하다. 캡슐화 덕에 데이터 접근을 메서드로 자연스럽게 감싸주기 때문이다. 반면, 여러 함수가 날 레코드를 직접 사용하는 경우라면 이 리팩터링은 (여전히 수행할 가치는 있지만) 훨씬 까다롭다.

이럴 때는 접근자 함수들을 만들고, 날 레코드를 읽고 쓰는 모든 함수가 접근자를 거치도록 고치면 된다. 옮길 필드가 불변이라면 값을 처음 설정할 때 소스와 타깃 필드를 한꺼번에 갱신하게 하고, 읽기 함수들은 점진적으로 마이그레이션하자.

나라면 가장 먼저 [7.1 레코드 캡슐화하기(Encapsulate Record)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-1.md)하여 클래스로 바꿀 것이다. 물론 가능할 때의 얘기지만, 이렇게 하면 필드 옮기기 리팩터링이 수월해진다.

> 여기서 날 레코드(bare record)란 C 언어의 구조체(struct)처럼 데이터를 외부로 직접 노출하는 레코드를 뜻한다. 게터와 세터로 내부 데이터를 한 단계 감싸는 객체와 대비되는 의미로 쓰였다.
## 예시: 공유 객체로 이동하기
다른 사례를 보자. 다음 코드는 이자율(interest rate)을 계좌(account)별로 설정하고 있다.
``` javascript
class Account {
  constructor(number, type, interestRate) {
    this._number = number;
    this._type = type;
    this._interestRate = interestRate;
  }

  get interestRate() { return this._interestRate; }
}

class AccountType {
  constructor(nameString) {
    this._name = nameString;
  }
}
```
이 코드를 수정하여 이자율이 계좌 종류에 따라 정해지도록 하려고 한다.
### STEP 2-1
[(1)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-2.md#1) 이자율 필드는 이미 잘 캡슐화되어 있으니 [(3)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-2.md#3) 가볍게 타깃인 `AccountType`에 이자율 필드와 필요한 접근자 메서드를 생성해보자.
``` diff
class Account {
  constructor(number, type, interestRate) {
    this._number = number;
    this._type = type;
    this._interestRate = interestRate;
  }

  get interestRate() { return this._interestRate; }
}

class AccountType {
- constructor(nameString) {
+ constructor(nameString, interestRate) {
    this._name = nameString;
+   this._interestRate = interestRate;    
  }
+ get interestRate() { return this._interestRate; }
}
```
### STEP 2-2
그런데 `Account`가 `AccountType`의 이자율을 가져오도록 수정하면 문제가 생길 수 있다. 이 리팩터링 전에는 각 계좌가 자신만의 이자율을 갖고 있었고, 지금은 종류가 같은 모든 계좌가 이자유을 공유하기를 원한다. 만약 수정 전에도 이자율이 계좌 종류별로 같게 설정되어 있었다면 겉보기 동작이 달라지지 않으니 그대로 리팩터링하면 된다. 하지만 이자율이 다른 계좌가 하나라도 있었다면, 이건 더 이상 리팩터링이 아니다. 수정 전과 후의 겉보기 동작이 달라지기 때문이다. 따라서 (예컨데) 계좌 데이터를 데이터베이스에 보관한다면 먼저 데이터베이스를 확인해서 모든 계좌의 이자율이 계좌 종류에 부합하게 설정되어 있는지 확인해야 한다. 계좌 클래스에 [10.6 어서션 추가하기(Introduce Assertion)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-6.md)도 도움이 된다.
``` diff
class Account {
  constructor(number, type, interestRate) {
    this._number = number;
    this._type = type;
+   assert(interestRate === this._type.interestRate);
    this._interestRate = interestRate;
  }

  get interestRate() { return this._interestRate; }
}

class AccountType {
  constructor(nameString, interestRate) {
    this._name = nameString;
    this._interestRate = interestRate;    
  }
  get interestRate() { return this._interestRate; }
}
```
이와 같이 어서션을 적용한 채 시스템을 잠시 운영해보며 오류가 생기는지 지켜보는 것이다.
### STEP 2-3
어서션을 추가하는 대신 문제 발생 시 로깅하는 방법도 있다. [(6)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-2.md#6) 시스템의 겉보기 동작이 달라지지 않는다는 확신이 서면 이자율을 가져오는 부분을 변경하고 [(8)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-2.md#8) `Account`에서 이자율을 직접 수정하던 코드를 완전히 제거한다.
``` diff
class Account {
- constructor(number, type, interestRate) {
+ constructor(number, type) {  
    this._number = number;
    this._type = type;
-   this._interestRate = interestRate;
  }

- get interestRate() { return this._interestRate; }
+ get interestRate() { return this._type.interestRate; }
}

class AccountType {
  constructor(nameString, interestRate) {
    this._name = nameString;
    this._interestRate = interestRate;    
  }
  get interestRate() { return this._interestRate; }
}
```

- [8.1 함수 옮기기(Move Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-1.md)
- [8.3 문장을 함수로 옮기기(Move Statements into Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-3.md)
