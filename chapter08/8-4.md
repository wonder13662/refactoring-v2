# 8.4 문장을 호출한 곳으로 옮기기(Move Statements to Caller)
반대 리팩터링: [8.3 문장을 함수로 옮기기(Move Statements into Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-3.md)
```diff
emitPhotoData(outStream, person.photo);
+outStream.write(`<p>위치: ${photo.location}</p>\n`)

function emitPhotoData(outStream, photo) {
  outStream.write(`<p>제목: ${photo.title}</p>\n`);
- outStream.write(`<p>위치: ${photo.location}</p>\n`);
}
```
## 배경
함수는 프로그래머가 쌓아 올리는 추상화의 기본 빌딩 블록이다. 그런데 추상화라는 것이 그 경계를 항상 올바르게 긋기가 만만치 않다. 그래서 코드베이스의 기능 범위가 달라지면 추상화의 경계도 움직이게 된다. 함수 관점에서 생각해보면, 초기에는 응집도 높고 한 가지 일만 수행하던 함수가 어느새 둘 이상의 다른 일을 수행하게 바뀔 수 있다는 뜻이다.

예컨데 여러 곳에서 사용하던 기능이 일부 호출자에게는 다르게 동작하도록 바뀌어야 한다면 이런 일이 벌어진다. 그렇다면 개발자는 달라진 동작을 함수에서 꺼내 해당 호출자로 옮겨야 한다. 이런 상황에 맞닥뜨리면 우선 [8.6 문장 슬라이드하기(Slide Statements)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-6.md)를 적용해 달라지는 동작을 함수의 시작 혹은 끝으로 옮긴 다음, 바로 이어서 문장을 호출한 곳으로 옮기기 리팩터링을 적용하면 된다. 달라지는 동작을 호출지로 옮긴 뒤에는 필요할 때마다 독립적으로 수정할 수 있다.

작은 변경이라면 문장을 호출한 곳으로 옮기는 것으로 충분하지만, 호출자와 호출 대상의 경계를 완전히 다시 그어야 할 때도 있다. 후자의 경우라면 [6.2 함수 인라인하기(Inline Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-2.md)부터 적용한 다음, [8.6 문장 슬라이드하기(Slide Statements)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-6.md)와 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md)로 더 적합한 경계를 설정하면 된다.
## 절차
### (1)
호출자는 한두 개뿐이고 피호출 함수도 간단한 단순한 상황이면, 피호출 함수의 처음(혹은 마지막) 줄(들)을 잘라내어 호출자(들)로 복사해 넣는다(필요하다면 적당히 수정한다). 테스트만 통과하면 이번 리팩터링은 여기서 끝이다.
### (2)
더 복잡한 상황에서는, 이동하지 '않길' 원하는 모든 문장을 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md) 한 다음 검색하기 쉬운 임시 이름을 지어준다.
  - 대상 함수가 서브클래스에서 오버라이드됐다면 오버라이드한 서브클래스들의 메서드 모두에서 동일하게 남길 부분을 메서드로 추출한다. 이때 남겨질 메서드의 본문은 모든 클래스에서 똑같아야 한다. 그런 다음 (슈퍼클래스의 메서드만 남기고) 서브클래스들의 메서드를 제거한다.
### (3)
원래 함수를 [6.2 함수 인라인하기(Inline Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-2.md) 한다.
### (4)
추출된 함수의 이름을 원래 함수의 이름으로 변경한다([6.5 함수 선언 바꾸기(Change Function Declaration)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-5.md))
  - 더 나은 이름이 떠오르면 그 이름을 사용하자.
## 예시
호출자가 둘뿐인 단순한 상황을 살펴보자.
``` javascript
function renderPerson(outStream, person) {
  outStream.write(`<p>${person.name}</p>\n`);
  renderPhoto(outStream, person.photo);
  emitPhotoData(outStream, person.photo);
}

function listRecentPhotos(outStream, photos) {
  photos
    .filter(p => p.date > recentDateCutoff())
    .forEach(p => {
      outStream.write("<div>\n");
      emitPhotoData(outStream, p);
      outStream.write("</div>\n");
    });
}

function emitPhotoData(outStream, photo) {
  outStream.write(`<p>제목: ${photo.title}</p>\n`);
  outStream.write(`<p>날짜: ${photo.date.toDateString()}</p>\n`);
  outStream.write(`<p>위치: ${photo.location}</p>\n`);
}
```
### STEP 1
이 소프트웨어를 수정하여 `renderPerson()`은 그대로 둔 채 `listReentPhotos()`가 위치 정보(location)를 다르게 랜더링하도록 만들어야 한다고 해보자. 이 변경을 쉽게 처리하기 위해 마지막 문장을 호출한 곳으로 옮겨보겠다.

[(1)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-4.md#1) 사실 이렇게 단순한 상황에서는 `renderPerson()`의 마지막 줄을 잘라내어 두 호출 코드 아래에 붙여 넣으면 끝이다. 하지만 여러분이 더 까다로운 상황에도 대처할 수 있도록 더 복잡한, 하지만 더 안전한 길로 가보겠다.

[(2)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-4.md#2) 첫 단계로 `emitPhotoData()`에 남길 코드를 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md) 한다.
``` diff
function renderPerson(outStream, person) {
  outStream.write(`<p>${person.name}</p>\n`);
  renderPhoto(outStream, person.photo);
  emitPhotoData(outStream, person.photo);
}

function listRecentPhotos(outStream, photos) {
  photos
    .filter(p => p.date > recentDateCutoff())
    .forEach(p => {
      outStream.write("<div>\n");
      emitPhotoData(outStream, p);
      outStream.write("</div>\n");
    });
}

function emitPhotoData(outStream, photo) {
+ zztmp(outStream, photo);
- outStream.write(`<p>제목: ${photo.title}</p>\n`);
- outStream.write(`<p>날짜: ${photo.date.toDateString()}</p>\n`);
  outStream.write(`<p>위치: ${photo.location}</p>\n`);
}

+function zztmp(outStream, photo) { // 이동하지 않을 코드
+ outStream.write(`<p>제목: ${photo.title}</p>\n`);
+ outStream.write(`<p>날짜: ${photo.date.toDateString()}</p>\n`);
+}
```
추출된 함수의 이름은 임시로만 쓰이는 게 보통이니 의미 없는 이름을 사용해도 괜찮지만 이왕이면 검색하기 쉬운 이름이 좋다. 이쯤에서 수정된 코드가 함수 호출 경계를 넘어 잘 동작하는 지 테스트해본다.
### STEP 2
[(3)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-4.md#3) 다음으로 피호출 함수를 호출자들로 한 번에 하나씩 [6.2 함수 인라인하기(Inline Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-2.md) 한다. `renderPerson()`부터 시작하자.
``` diff
function renderPerson(outStream, person) {
  outStream.write(`<p>${person.name}</p>\n`);
  renderPhoto(outStream, person.photo);
- emitPhotoData(outStream, person.photo);
+ zztmp(outStream, person.photo);
+ outStream.write(`<p>위치: ${person.photo.location}</p>\n`); // 첫 번째 호출 위치로 인라인
}

function listRecentPhotos(outStream, photos) {
  photos
    .filter(p => p.date > recentDateCutoff())
    .forEach(p => {
      outStream.write("<div>\n");
      emitPhotoData(outStream, p);
      outStream.write("</div>\n");
    });
}

function emitPhotoData(outStream, photo) {
  zztmp(outStream, photo);
  outStream.write(`<p>위치: ${photo.location}</p>\n`);
}

function zztmp(outStream, photo) { // 이동하지 않을 코드
  outStream.write(`<p>제목: ${photo.title}</p>\n`);
  outStream.write(`<p>날짜: ${photo.date.toDateString()}</p>\n`);
}
```
이 호출이 올바르게 동작하는지 테스트한다.
### STEP 3
다음 함수도 [6.2 함수 인라인하기(Inline Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-2.md) 한다.
``` diff
function renderPerson(outStream, person) {
  outStream.write(`<p>${person.name}</p>\n`);
  renderPhoto(outStream, person.photo);
  zztmp(outStream, person.photo);
  outStream.write(`<p>위치: ${person.photo.location}</p>\n`);
}

function listRecentPhotos(outStream, photos) {
  photos
    .filter(p => p.date > recentDateCutoff())
    .forEach(p => {
      outStream.write("<div>\n");
-     emitPhotoData(outStream, p);
+     zztmp(outStream, p.photo);
+     outStream.write(`<p>위치: ${p.photo.location}</p>\n`); // 두 번째 호출 위치로 인라인
      outStream.write("</div>\n");
    });
}

function emitPhotoData(outStream, photo) {
  zztmp(outStream, photo);
  outStream.write(`<p>위치: ${photo.location}</p>\n`);
}

function zztmp(outStream, photo) { // 이동하지 않을 코드
  outStream.write(`<p>제목: ${photo.title}</p>\n`);
  outStream.write(`<p>날짜: ${photo.date.toDateString()}</p>\n`);
}
```
### STEP 4
이제 원래 함수를 지워 [6.2 함수 인라인하기(Inline Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-2.md)를 마무리한다.
``` diff
function renderPerson(outStream, person) {
  outStream.write(`<p>${person.name}</p>\n`);
  renderPhoto(outStream, person.photo);
  zztmp(outStream, person.photo);
  outStream.write(`<p>위치: ${person.photo.location}</p>\n`);
}

function listRecentPhotos(outStream, photos) {
  photos
    .filter(p => p.date > recentDateCutoff())
    .forEach(p => {
      outStream.write("<div>\n");
      zztmp(outStream, p.photo);
      outStream.write(`<p>위치: ${p.photo.location}</p>\n`);
      outStream.write("</div>\n");
    });
}

-function emitPhotoData(outStream, photo) {
- zztmp(outStream, photo);
- outStream.write(`<p>위치: ${photo.location}</p>\n`);
-}

function zztmp(outStream, photo) { // 이 함수는 여전히 남아 있음
  outStream.write(`<p>제목: ${photo.title}</p>\n`);
  outStream.write(`<p>날짜: ${photo.date.toDateString()}</p>\n`);
}
```
### STEP 5
[(4)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-4.md#4) 그런 다음 `zztmp()`의 이름을 원래 함수 이름으로 되돌린다.
``` diff
function renderPerson(outStream, person) {
  outStream.write(`<p>${person.name}</p>\n`);
  renderPhoto(outStream, person.photo);
- zztmp(outStream, person.photo);
+ emitPhotoData(outStream, person.photo);
  outStream.write(`<p>위치: ${person.photo.location}</p>\n`);
}

function listRecentPhotos(outStream, photos) {
  photos
    .filter(p => p.date > recentDateCutoff())
    .forEach(p => {
      outStream.write("<div>\n");
-     zztmp(outStream, p.photo);
+     emitPhotoData(outStream, p.photo);
      outStream.write(`<p>위치: ${p.location}</p>\n`);
      outStream.write("</div>\n");
    });
}

-function zztmp(outStream, photo) {
+function emitPhotoData(outStream, photo) {
  outStream.write(`<p>제목: ${photo.title}</p>\n`);
  outStream.write(`<p>날짜: ${photo.date.toDateString()}</p>\n`);
}
```

- [8.3 문장을 함수로 옮기기(Move Statements into Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-3.md)
- [8.5 인라인 코드를 함수 호출로 바꾸기(Replace Inline Code with Function Call)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-5.md)