### 8.7 반복문 쪼개기(Split loop)
``` diff
-let averageAge = 0;
let totalSalary = 0;
for (const p of people) {
- averageAge += p.age;
  totalSalary += p.salary;
}

+let averageAge = 0;
+for (const p of people) {
+ averageAge += p.age;
+}
averageAge = averageAge / people.length;
```
#### 배경
종종 반복문 하나에서 두 가지 일을 수행하는 모습을 보게 된다. 그저 두 일을 한꺼번에 처리할 수 있다는 이유에서 말이다. 하지만 이렇게 하면 반복문을 수정해야 할 때마다 두 가지 일 모두를 잘 이해하고 진행해야 한다. 반대로 각각의 반복문으로 분리해두면 수정할 동작 하나만 이해하면 된다.

반복문을 분리하면 사용하기도 쉬워진다. 한 가지 값만 계산하는 반복문이라면 그 값만 곧바로 반환할 수 있다. 반면 여러 일을 수행하는 반복문이라면 구조체를 반환하거나 지역 변수를 활용해야 한다. 참고로 반복문 쪼개기는 서로 다른 일들이 한 함수에서 이뤄지고 있다는 신호일 수 있고, 그래서 반복문 쪼개기와 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md)는 연이어 수행하는 일이 잦다.

반복문을 두 번 실행해야 하므로 이 리팩터링을 불편해하는 프로그래머도 많다. 다시 한번 이야기하지만, 리팩터링과 최적화를 구분하자. 최적화는 코드를 깔끔히 정리한 이후에 수행하자. 반복문을 두 번 실행하는 게 병목이라 밝혀지면 그때 다시 하나로 합치기는 식은 죽 먹기다. 하지만 심지어 긴 리스트를 반복하더라도 병목으로 이어지는 경우는 매우 드믈다. 오히려 반복문 쪼개기가 다른 더 강력한 최적화를 적용할 수 있는 길을 열어 주기도 한다.
#### 절차
##### (1)
- 반복문을 복제해 두개로 만든다.
##### (2)
- 반복문이 중복되어 생기는 부수효과를 파악해서 제거한다.
##### (3)
- 테스트한다.
##### (4)
- 완료되었으면, 각 반복문을 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md)할지 고민해본다.
#### 예시
전체 급여와 가장 어린 나이를 계산하는 코드에서 시작해보자.
``` javascript
let youngest = people[0] ? people[0].age: Infinity;
let totalSalary = 0;
for (const p of people) {
  if (p.age < youngest) youngest = p.age;
  totalSalary += p.salary;
}

return `최연소: ${youngest}, 총 급여: ${totalSalary}`;
```
##### STEP 1
아주 간단한 반복문이지만 관련없는 두 가지 계산을 수행한다.[(1)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-7.md#1)자, 반복문 쪼개기의 첫 단계는 단순히 반복문을 복제하는 것이다.
``` diff
let youngest = people[0] ? people[0].age: Infinity;
let totalSalary = 0;
for (const p of people) {
  if (p.age < youngest) youngest = p.age;
  totalSalary += p.salary;
}
+for (const p of people) {
+ if (p.age < youngest) youngest = p.age;
+ totalSalary += p.salary;
+}

return `최연소: ${youngest}, 총 급여: ${totalSalary}`;
```
##### STEP 2
[(2)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-7.md#2)반복문을 복제했으면 잘못된 결과를 초래할 수 있는 중복을 제거해야 한다. 부수효과가 없는 코드라면 반복문 안에 그대로 둬도 되지만, 지금 예에서는 부수효과가 있으니 찾아서 없애자.
``` diff
let youngest = people[0] ? people[0].age: Infinity;
let totalSalary = 0;
for (const p of people) {
- if (p.age < youngest) youngest = p.age; // 부수효과가 있는 코드는 한쪽만 남기고 제거
  totalSalary += p.salary;
}
for (const p of people) {
  if (p.age < youngest) youngest = p.age;
- totalSalary += p.salary; // 부수효과가 있는 코드는 한쪽만 남기고 제거
}

return `최연소: ${youngest}, 총 급여: ${totalSalary}`;
```
#### 더 가다듬기
공식적으로 반복문 쪼개기 리팩터링은 여기서 끝이다. 하지만 반복문 쪼개기의 묘미는 그 자체가 아닌, 다음 단계로 가는 디딤돌 역할에 있다. [(4)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-7.md#4)이 리팩터링을 할 때는 나뉜 각 반복문의 각각의 함수로 추출하면 어떨지까지 한 묶음으로 고민하자.
##### 더 가다듬기 - STEP 1
지금의 경우라면 코드 일부에 [8.6 문장 슬라이드하기(Slide Statements)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-6.md)부터 적용해야 한다.
``` diff
-let youngest = people[0] ? people[0].age: Infinity;
let totalSalary = 0;
for (const p of people) {
  totalSalary += p.salary;
}
+let youngest = people[0] ? people[0].age: Infinity;
for (const p of people) {
  if (p.age < youngest) youngest = p.age;
}

return `최연소: ${youngest}, 총 급여: ${totalSalary}`;
```
##### 더 가다듬기 - STEP 2
그런 다음 각 반복문을 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md)한다.
``` diff
-let totalSalary = 0;
-for (const p of people) {
- totalSalary += p.salary;
-}
-let youngest = people[0] ? people[0].age: Infinity;
-for (const p of people) {
- if (p.age < youngest) youngest = p.age;
-}

-return `최연소: ${youngest}, 총 급여: ${totalSalary}`;
+return `최연소: ${youngestAge()}, 총 급여: ${totalSalary()}`;

+function totalSalary() {
+ let totalSalary = 0;
+ for (const p of people) {
+   totalSalary += p.salary;
+ }
+}

+function youngestAge() {
+ let youngest = people[0] ? people[0].age: Infinity;
+ for (const p of people) {
+   if (p.age < youngest) youngest = p.age;
+ }
+}
```
##### 더 가다듬기 - STEP 3
추출된 총 급여 계산 함수의 코드를 보면 [8.8 반복문을 파이프라인으로 바꾸기(Replace Loop with Pipeline)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-8.md) 하고 싶은 충동을 떨치기 어렵고, 최연소 계산 코드에는 [7.9 알고리즘 교체하기(Subtitute Algorithm)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-9.md)를 적용하면 좋을 것 같다. 둘 다 적용해보자.
``` diff
return `최연소: ${youngestAge()}, 총 급여: ${totalSalary()}`;

function totalSalary() {
- let totalSalary = 0;
- for (const p of people) {
-   totalSalary += p.salary;
- }
+ return people.reduce((total, p) => total + p.salary, 0);
}

function youngestAge() {
- let youngest = people[0] ? people[0].age: Infinity;
- for (const p of people) {
-   if (p.age < youngest) youngest = p.age;
- }
+ return Math.min(...people.map(p => p.age));
}
```