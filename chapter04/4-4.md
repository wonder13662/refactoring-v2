# 4.4 테스트 추가하기(Add Another Test)
계속해서 테스트를 더 추가해보자. 이번에는 클래스가 하는 일을 모두 살펴보고 각각의 기능에서 오류가 생길 수 있는 조건을 하나씩 테스트하는 식으로 진행하겠다. 일부 프로그래머들이 선호하는 public 메서드를 빠짐없이 테스트하는 방식과는 다르다. 명심하자! 테스트는 위험요인을 중심으로 작성해야 한다! 테스트의 목적은 어디까지나 현재 혹은 향후에 발생하는 버그를 찾는데 있다. 따라서 단순히 필드를 일고 쓰기만 하는 접근자는 테스트할 필요가 없다. 이런 코드는 너무 단순해서 버그가 숨어들 가능성도 별로 없다.

테스트를 너무 많이 만들다 보면 오히려 필요한 테스트를 놓치기 쉽기 때문에 아주 중요한 포인트다. 나는 적은 수의 테스트만으로 큰 효과를 얻고 있다. 잘못될까봐 가장 걱정되는 영역을 집중적으로 테스트하는데, 이렇게 해서 테스트에 쏟는 노력의 효과를 극대화하는 것이다.

> 완벽하게 만드느라 테스트를 수행하지 못하느니, 불완전한 테스트라도 작성해 실행하는 게 낫다.

이 맥락에서 샘플 코드의 또 다른 주요 기능인 총수익 계산 로직을 테스트해보겠다. 앞에서와 마찬가지로 초기 픽스처로부터 총수익이 제대로 계산되는지 간단히 검사하도록 작성하다.

```diff
describe('province', function(){
  it('shortfall', function(){
    const asia = new Province(sampleProvinceData());
    expect(asia.shortfall).toBe(5);
  });

+ it('profit', function() {
+   const asia = new Province(sampleProvinceData());
+   expect(asia.profit).toBe(230);
+ })  
});
```

여기서 내가 기댓값 `230`을 구한 방식은 설명이 좀 필요해보인다. 사실 나는 먼저 기댓값 자리에 임의의 값을 넣고 테스트를 수행한 다음, 프로그램이 내놓는 실제 값(`230`)으로 대체했다. 직접 손으로 계산해도 되지만, 코드가 제대로 동작할 거라 믿고 일단 이렇게 했다. 그런 다음 테스트가 제대로 작동한다고 확인되면, 총수익 계산 로직에 `* 2`를 덧붙여서 잘못된 값이 나오도록 수정한다. 일부러 주입한 이 오류를 테스트가 걸러내는 게 확인되면, 만족해하며 원래 코드로 되돌린다. 임시 값을 설정했다가 실제 값으로 대체하고, 오류를 심었다가 되돌리는 이 패턴은 실제로 내가 기존 코드를 검사하는 테스트를 추가할 때 흔히 쓰는 방식이다.

지금까지 작성한 두 테스트에는 겹치는 부분이 좀 있다. 둘 다 첫 줄에서 똑같은 픽스처를 설정하는 게 보일 것이다. 일반 코드와 마찬가지로 테스트 코드에서도 중복은 의심해봐야 한다. 그러니 이 픽스처를 둘 모두에서 접근할 수 있는 장소로 옮겨 중복을 제거해보자. 먼저 바깥 범위로 끌어내는 방법을 시도해보자.

```diff
describe('province', function(){
+ const asia = new Province(sampleProvinceData()); // 이렇게 하면 안된다.
  it('shortfall', function(){
    const asia = new Province(sampleProvinceData());
    expect(asia.shortfall).toBe(5);
  });

  it('profit', function() {
    const asia = new Province(sampleProvinceData());
    expect(asia.profit).toBe(230);
  })  
});
```
그런데 주석에 적은 것처럼 나는 절대로 이렇게 하지 않는다. 일시적인 효과는 있겠지만, 테스트 관련 버그 중 가장 지저분한 유형인 '테스트끼리 상호작용하게 하는 공유 픽스처'를 생성하는 원인이 된다. 자바스크립트에서 `const` 키워드는 `asia` 객체의 '내용'이 아니라 `asia`를 키는 '참조'가 상수임을 뜻한다. 나중에 다른 테스트에서 이 공유 객체의 값을 수정하면 이 픽스처를 사용하는 또 다른 테스트가 실패할 수 있다. 즉, 테스트를 실행하는 순서에 따라 결과가 달라질 수 있다. 이렇게 되면 테스트 결과가 제멋대로가 되어 버그를 잡기 어렵고 오래 걸린다. 더 심하면 테스트 자체를 믿지 못하게 된다. 그래서 나는 다음 방식을 선호한다.
```diff
describe('province', function(){
- const asia = new Province(sampleProvinceData()); // 이렇게 하면 안된다.
+ let asia;
+ beforeEach(function(){
+   asia = new Province(sampleProvinceData());
+ });
  it('shortfall', function(){
    const asia = new Province(sampleProvinceData());
    expect(asia.shortfall).toBe(5);
  });

  it('profit', function() {
    const asia = new Province(sampleProvinceData());
    expect(asia.profit).toBe(230);
  });
});
```
`beforeEach` 구문은 각각의 테스트 바로 전에 실행되어 `asia`를 초기화하기 때문에 모든 테스트가 자신만의 새로운 `asia`를 사용하게 된다. 이처럼 개별 테스트를 실행할 때마다 픽스처를 새로 만들면 모든 테스트를 독립적으로 구성할 수 있어서, 결과를 예측할 수 없어 골치를 썩는 사태를 예방할 수 있다.

내가 이렇게 조언하면 매번 픽스처를 생성하느라 테스트가 느려지지 않냐고 묻는 사람이 있다. 눈에 띄게 느려지는 일은 거의 없다. 정말 문제가 될 때는 공유 픽스처를 사용하기도 하지만, 이럴 때는 어떠한 테스트도 값을 변경하지 못하도록 주의한다. 또한 불변임이 확실한 픽스처는 공유하기도 한다. 그래도 가장 선호하는 방식은 매번 새로운 픽스처를 만드는 것이다. 공유 픽스처를 사용하다가 저지른 실수 때문에 디버깅하는 데 엄청난 고생을 한 경험이 많기 때문이다.

테스트마다 `beforeEach` 구문이 실행된다면 그 안의 코드를 각각의 `it` 블록에 넣으면 되지 않냐고 물을 수 있다. 나는 내 테스트들이 모두 똑같은 픽스처에 기초하여 검증을 수행하기를 바란다. 그래야 표준 픽스처에 익숙해져서 테스트할 속성을 다양하게 찾아낼 수 있기 때문이다. `beforeEach` 블록의 등장은 내가 표준 픽스처를 사용한다는 사실을 알려준다. 그러면 코드를 읽는 이들은 해당 `describe` 블록 안의 모든 테스트가 똑같은 기준 데이터로부터 시작한다는 사실을 쉽게 알 수 있다.

- [목차](https://github.com/wonder13662/refactoring-v2/blob/writing/README.md)
- [4 테스트 구축하기](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter04)
- [4.3 첫 번째 테스트(A First Test)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter04/4-3.md)
- [4.5 픽스처 수정하기(Modifying the Fixture)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter04/4-5.md)