# 4.1 자가 테스트 코드의 가치(The Value of Self-Testing Code)
프로그래머들이 어떻게 일하는지 가만히 살펴보면 실제로 코드를 작성하는 시간의 비중은 그리 크지 않음을 발견할 수 있다. 현재 상황을 파악하기도 하고, 설계를 고민하기도 한다. 물론 대부분의 시간은 디버깅에 쓴다. 여러분도 디버깅하느라 밤늦게까지 고생한 경험이 있을 것이다. 프로그래머라면 누구나 꼬박 하루를 (혹은 그 이상을) 잡아먹은 디버깅 무용담을 하나씩은 간직하고 있을 것이다. 버그 수정 자체는 대체로 금방 끝난다. 진짜 끔찍한 건 버그를 찾는 여정이다. 또한 버그를 잡는 과정에서 다른 버그를 심기도 하는데, 그 사실을 한참이 지나서야 알아채기도 한다. 그래서 또다시 그 버그를 찾느라 수많은 시간을 날린다.

내가 자가 테스트 코드를 진지하게 고민하기 시작한 계기는 1992년 OOPSLA 컨퍼런스에서 발표하던 중 겪은 일 때문이다. 한창 발표하고 있는데 누군가 "클래스마다 테스트 코드를 갖춰 한다"는 말을 툭 던졌다(내 기억에 "베다라" 데이브 토마스 - "Bedarra Dave Thomas"였던 것 같다). 그때부터 나는 코드베이스에 프로덕션 코드와 테스트 코드를 함께 담기로 했다. 당시 반복적 개발 방법론(iterative development)을 따르고 있었기 때문에 반복 주기가 하나 끝날 때마다 가능하면 테스트 코드도 추가했다. 당시 내가 참여한 프로젝트는 규모가 작은 편이어서 반복 주기는 1주 정도였다. 테스트 작업은 꽤 쉽고 간단했지만 상당히 지루했다. 테스트 코드가 콘솔에 출력한 결과를 일일이 눈으로 확인해야 했기 때문이다. 그래서 프로그램이 제대로 된 값을 출력했는지 내가 직접 확인하지 말고, 그 일을 컴퓨터에게 맡겨야겠다고 생각했다. 테스트가 성공했는지 확인하려면 의도한 결과와 테스트 결과가 같은지만 비교하면 된다. 그래서 모든 테스트가 성공하면 화면에 "OK"만 출력하도록 만들었다. 이렇게 자가 테스트 소프트웨어가 탄생했다.

> 모든 테스트를 완전히 자동화하고 그 결과까지 스스로 검사하게 만들자.

이렇게 하니 테스트가 컴파일만큼 쉬워졌다. 그래서 다음부터는 컴파일할 때마다 테스트도 함께 했고, 곧바로 생산성이 급상승했다. 디버깅 시간이 크게 줄어든 것이다. 가장 최근 테스트로 잡은 버그를 다시 살려보면 테스트에 걸려 눈에 확 드러난다. 직전까지 테스트가 성공했다면 마지막 테스트 이후에 작성한 코드에서 버그가 발생했음을 알 수 있다. 이런 테스트를 몇 분 간격으로 자주 수행했기 때문에 버그가 발생한 지점은 조금 전에 작성한 코드에 있다는 사실도 알 수 있었다. 의심되는 코드의 양이 많지 않고 아직 기억이 생생하니 버그를 쉽게 찾을 수 있었다. 이렇게 하지 않았다면 몇 시간이 걸렸을지 모를 버그를 단 몇 분이면 해결할 수 있었다. 이처럼 자가 테스트 코드 자체뿐 아니라 테스트를 자주 수행하는 습관도 버그를 찾는 강력한 도구가 된다.

이 사실을 깨달은 후로 나는 테스트에 더 적극적을 나섰다. 반복 주기가 끝나길 기다리지 않고 함수 몇 개만 작성해도 곧바로 테스트를 추가하기 시작했다. 매일 두어 개의 새로운 기능과 그에 딸린 테스트 코드가 쌓여갔다. 그래서 회귀 버그(regression bug)를 잡는 데 몇 분 이상 걸린 적이 거의 없다.

> 회귀 버그란 잘 작동하던 기능에서 문제가 생기는 현상을 가리키며, 일반적으로 프로그램을 변경하는 중 뜻하지 않게 발생한다. 같은 맥락에서, 잘 작동하던 기능이 여전히 잘 작동하는지 확인하는 테스트를 회귀 테스트(regression test)라 한다.

> 테스트 스위트는 강력한 버그 검출 도구로, 버그를 찾는 데 걸리는 시간을 대폭 줄여준다.

이 경험 이후로 자가 테스트 코드를 작성하고 구성하는 수고를 덜어주는 도구들이 급격히 발전했다. OOPSLA 1997에 참석하기 위해 스위스에서 애틀랜타로 향하는 비행기에서 켄트 벡은 에릭 감마(Erich Gamma)와 함께 자신이 구현한 스몰토크 버전 단위 테스트 프레임워크를 자바로 포팅했다. 그 결과로 나온 것이 바로 JUnit이다. JUnit은 프로그램 테스트 분야에 지대한 영향을 끼쳤고, 수많은 언어용으로 비슷한 도구-[Xunit](https://martinfowler.com/bliki/Xunit.html)가 만들어지는데 밑거름이 됐다.

사실 다른 사람에게 이런 식으로 개발하라고 설득하기는 녹록지 않다. 테스트를 작성하려면 소프트웨어 제품 본체 외의 부가적인 코드를 상당량 작성해야 한다. 그래서 테스트가 실제로 프로그래밍 속도를 높여주는 경험을 직접 해보지 않고서는 자가 테스트의 진가를 납득하긴 어렵다. 게다가 테스트 작성법을 배운 적이 없는 프로그래머가 많을뿐더러, 테스트에 대해 생각조차 못 해본 이도 많다. 테스트를 수동으로 하면 좀이 쑤실 정도로 지겹다. 하지만 자동화한다면 테스트 코드를 작성하는 재미가 쏠쏠하다.

테스트를 작성하기 가장 좋은 시점은 프로그래밍을 시작하기 전이다. 나는 기능을 추가해야 할 때 테스트부터 작성한다. 얼핏 순서가 뒤바뀐 듯 들리지만, 전혀 그렇지 않다. 테스트를 작성하다 보면 원하는 기능을 추가하기 위해 무엇이 필요한지 고민하게 된다. 구현보다 인터페이스에 집중하게 된다는 장점도 있다(무조건 좋은 일이다). 게다가 코딩이 완료되는 시점을 정확하게 판단할 수 있다. 테스트를 모두 통과한 시점이 바로 코드를 완성한 시점이다.

켄트 벡은 이처럼 테스트부터 작성하는 습관을 바탕으로 [테스트 주도 개발-Test Driven](https://martinfowler.com/bliki/TestDrivenDevelopment.html)이란 기법을 창시했다. TDD에서는 (처음에는 통과하지 못할) 테스트를 작성하고, 이 테스트를 통과하게끔 코드를 작성하고, 결과 코드를 최대한 깔끔하게 리팩터링하는 과정을 짧은 주기로 반복한다. 이러한 테스팅-코딩-리팩터링 과정을 한 시간에도 여러 차례 진행하기 때문에 코드를 대단히 생산적이면서도 차분하게 작성할 수 있다. TDD에 대해서는 여기서 자세히 설명하지 않지만, 내가 프로그래밍하는 방식이자 추천하는 방식이다.

이 정도면 테스트가 중요한 이유는 충분히 설명한 것 같다. 자가 테스트 코드를 작성하면 누구나 효과를 볼 수 있다고 굳게 믿지만, 이 책의 주제는 어디까지나 리팩터링이다. 리팩터링에는 테스트가 필요하다. 그러니 리팩터링하고 싶다면 테스트를 반드시 작성해야 한다.

이번 장에서는 자바스크립트 프로그램용으로 테스트 코드를 작성하는 방법을 소개한다. 테스트가 주제인 책이 아닌 만큼 깊게 들어가지는 않겠다. 하지만 아주 적은 노력으로 엄청난 효과를 볼 수 있음을 명심하자.

이 책의 스타일대로, 테스트 기법도 예시 중심으로 소개하겠다. 나는 코드를 작성할 때 테스트도 동시에 작성한다. 하지만 간혹 테스트가 갖춰지지 않은 코드를 리팩터링해야 할 때도 있다. 그럴 때는 곧바로 리팩터링하지 않고, 먼저 자가 테스트 코드부터 작성한다.

- [목차](https://github.com/wonder13662/refactoring-v2/blob/writing)
- [3 코드에서 나는 악취](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter03)
- [3.24 주석(Comments)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter03/3-24.md)
- [4 테스트 구축하기](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter04)
- [4.2 테스트할 샘플 코드(Sample Code to Test)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter04/4-2.md)