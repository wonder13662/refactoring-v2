# 6.8 매개변수 객체 만들기(Introduce Parameter Object)
``` diff
-function amountInvoiced(startDate, endDate) {...}
-function amountReceived(startDate, endDate) {...}
-function amountOverdue(startDate, endDate) {...}
+function amountInvoiced(aDateRange) {...}
+function amountReceived(aDateRange) {...}
+function amountOverdue(aDateRange) {...}
```

## 배경
- 데이터 뭉치를 데이터 구조로 묶으면 데이터 사이의 관계가 명확해진다는 이점을 얻는다. 게다가 함수가 이 데이터 구조를 받게 하면 매개변수가 줄어든다. 같은 데이터 구조를 사용하는 모든 함수가 원소를 참조할 때 항상 똑같은 이름을 사용하기 때문에 일관성도 높여준다.
- 이 리팩터링의 진정한 힘은 코드를 더 근본적으로 바꿔준다는 데 있다. 나는 이런 데이터 구조를 새로 발견하면 이 데이터 구조를 활용하는 형태로 프로그램 동작을 재구성한다.데이터 구조에 담길 데이터에 공통으로 적용되는 동작을 추출해서 함수로 만드는 것이다(공용 함수를 나열하는 식으로 작성할 수도 있고, 이 함수들과 데이터를 합쳐서 클래스로 만들 수도 있다).
- 이 과정에서 새로 만든 데이터 구조가 문제 영역을 훨씬 간결하게 표현하는 새로운 추상 개념으로 격상되면서, 코드의 개념적인 그림을 다시 그릴 수도 있다. 그러면 놀라울 정도로 강력한 효과를 낸다. 하지만 이 모든 것의 시작은 매개변수 객체 만들기부터다.
## 절차
1. 적당한 데이터 구조가 아직 마련되어 있지 않다면 새로 만든다
  - 개인적으로 클래스로 만드는 걸 선호한다. 나중에 동작까지 함께 묶기 좋기 때문이다. 나는 주로 데이터 구조를 값 객체(Value Object)로 만든다
2. 테스트한다.
3. [6.5 함수 선언 바꾸기(Change Function Declaration)]()로 새 데이터 구조를 매개변수로 추가한다.
4. 테스트한다.
5. 함수 호출 시 새로운 데이터 구조 인스턴스를 넘기도록 수정한다. 하나씩 수정할 때마다 테스트한다.
6. 기존 매개변수를 사용하던 코드를 새 데이터 구조의 원소를 사용하도록 바꾼다.
7. 다 바꿨다면 기존 매개변수를 제거하고 테스트한다.
## 예시
``` javascript
// 온도 측정값을 표현하는 데이터
const station = {
  name: "ZB1",
  readings: [
    { temp: 47, time: "2016-11-10 09:10" },
    { temp: 53, time: "2016-11-10 09:20" },
    { temp: 58, time: "2016-11-10 09:30" },
    { temp: 53, time: "2016-11-10 09:40" },
    { temp: 51, time: "2016-11-10 09:50" },
  ],
}
// 정상 범위를 벗어난 측정값을 찾는 함수
function readingsOutsideRange(station, min, max) {
  return station.readings.filter(r => r.temp < min || r.temp > max);
}
// 호출문
alert = readingsOutsideRange(
  station, 
  operatingPlan.temperatureFloor, // 최저 온도
  operatingPlan.temperatureCeiling, // 최고 온도
)
```
- 호출 코드를 보면 operatingPlan의 데이터 항목 두 개를 쌍으로 가져와서 `readingOutsideRange()`로 전달한다. 그리고 operatingPlan은 범위의 시작과 끝 이름을 `readingOutsideRange()`와 다르게 표현한다. 이와 같은 범위(Range)라는 개념은 객체 하나로 묶어 표현하는 게 나은 대표적인 예다
### STEP 1
```diff
+class NumberRange {
+ constructor(min, max) {
+   this._data = { min: min, max: max };    
+ }
+ get min() { return this._data.min; }
+ get max() { return this._data.max; }
+}
```
- (1)묶을 데이터를 표현하는 클래스부터 선언하자.
- 값 객체로 만들 가능성이 높기 때문에 setter는 만들지 않는다.
### STEP 2
```diff
// 정상 범위를 벗어난 측정값을 찾는 함수
-function readingsOutsideRange(station, min, max) {
+function readingsOutsideRange(station, min, max, range) {  
  return station.readings.filter(r => r.temp < min || r.temp > max);
}
// 호출문
alert = readingsOutsideRange(
  station, 
  operatingPlan.temperatureFloor, // 최저 온도
  operatingPlan.temperatureCeiling, // 최고 온도
+ null,  
)
```
- (3)새로 만든 객체를 `readingsOutsideRange()`의 매개변수로 추가하도록 [6.5 함수 선언 바꾸기(Change Function Declaration)]()
- 새 매개변수 자리에 null을 적어둔다.
- (4)아직까지 동작은 하나도 바꾸지 않았으니 테스트는 통과할 것이다.
### STEP 3
```diff
// 호출문
+const range = new NumberRange(operatingPlan.temperatureFloor, operatingPlan.temperatureCeiling);
alert = readingsOutsideRange(
  station, 
  operatingPlan.temperatureFloor, // 최저 온도
  operatingPlan.temperatureCeiling, // 최고 온도
- null,
+ range,
)
```
- (5)이제 온도 범위를 객체 형태로 전달하도록 호출문을 하나씩 바꾼다.
- 이번에도 테스트를 무난히 통과한다.
### STEP 4
```diff
-function readingsOutsideRange(station, min, max, range) {  
+function readingsOutsideRange(station, min, range) {
- return station.readings.filter(r => r.temp < min || r.temp > max);
+ return station.readings.filter(r => r.temp < min || r.temp > range.max);
}

// 호출문
const range = new NumberRange(operatingPlan.temperatureFloor, operatingPlan.temperatureCeiling);
alert = readingsOutsideRange(
  station, 
  operatingPlan.temperatureFloor, // 최저 온도
- operatingPlan.temperatureCeiling, // 최고 온도
  range,
)
```
- (6)이제 기존 매개변수를 사용하는 부분을 변경한다. 최대값부터 바꿔보자.
### STEP 5
``` diff
-function readingsOutsideRange(station, min, range) {
+function readingsOutsideRange(station, range) {
- return station.readings.filter(r => r.temp < min || r.temp > range.max);
+ return station.readings.filter(r => r.temp < range.min || r.temp > range.max);
}

// 호출문
const range = new NumberRange(operatingPlan.temperatureFloor, operatingPlan.temperatureCeiling);
alert = readingsOutsideRange(
  station, 
- operatingPlan.temperatureFloor, // 최저 온도
  range,
)
```
- 다음 매개변수도 제거한다.
### STEP 6
``` diff
function readingsOutsideRange(station, range) {
- return station.readings.filter(r => r.temp < range.min || r.temp > range.max);  
+ return station.readings.filter(r => !range.contains(r.temp));
}

class NumberRange {
  constructor(min, max) {
    this._data = { min: min, max: max };    
  }
  get min() { return this._data.min; }
  get max() { return this._data.max; }
+ contains(arg) { return (arg >= this.main && arg <= this.max); }
}
```
- 클래스로 만들어두면 관련 동작들을 이 클래스로 옮길 수 있다는 이점이 생긴다.이 예에서는 온도가 허용 범위 안에 있는지 검사하는 메서드를 클래스에 추가할 수 있다. 지금까지 한 작업은 여러 가지 유용한 동작을 갖춘 범위(Range) 클래스를 생성하기 위한 첫 단계다.