# 3.23 상속 포기(Refused Bequest)
서브클래스는 부모로부터 메서드와 데이터를 물려받는다. 하지만 부모의 유산을 원치않거나 필요없다면 어떻게 해야 할까? 수많은 유산 중에서 관심 있는 몇 개만 받고 끝내려는 경우는 얼마든지 있을 수 있다.

예전에는 계층구조를 잘못 설계했기 때문으로 봤다. 이 관점에서의 해법은, 먼저 같은 계층에 서브클래스를 하나 새로 만들고, [12.4 메서드 내리기(Push Down Method)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-4.md)와 [12.5 필드 내리기(Push Down Field)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-5.md)를 활용해서 물려받지 않을 부모 코드를 모조리 새로 만든 서브 클래스로 넘긴다. 그러면 부모에는 공통된 부분만 남는다. 한 걸음 더 나아가서 부모 클래스는 모두 추상 클래스여야 한다고 말하는 사람도 많다.

앞에서는 '예전에는'이라고 한 데서 눈치챘겠지만, 우리는 이 방식을 권하지 않는다. 아니, 항상 이렇게 해야 한다는 입장은 아니다. 일부 동작을 재활용하기 위한 목적으로 상속을 활용하기도 하는데, 실무 관점에서 아주 유용한 방식이다. 솔직히 냄새를 풍기지만, 보통은 참을 만한 경우가 많다. 그래서 상속을 포기할 시 혼란과 문제가 생긴다면 앞에서 설명한 예전 방식을 따른다. 단, 무조건 이래야 한다는 생각은 버리자. 열에 아홉은 냄새가 미미해서 굳이 씻어내지 않아도 된다.

상속 포기 냄새는 서브클래스가 부모의 동작은 필요로 하지만 인터페이스는 따르고 싶지 않을 때 특히 심하게 난다. 구현을 따르지 않는 것은 이해할 수 있지만 인터페이스를 따르지 않는다는 것은 상당히 무례한 태도다. 이럴 때는 [12.10 서브클래스를 위임으로 바꾸기(Replace Subclass with Delegate)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-10.md)나 [12.11 슈퍼클래스를 위임으로 바꾸기(Replace Superclass with Delegate)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-11.md)를 활용해서 아예 상속 매커니즘에서 벗어나보자.

- [3.22 데이터 클래스(Data Class)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter03/3-22.md)
- [3.24 주석(Comments)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter03/3-24.md)