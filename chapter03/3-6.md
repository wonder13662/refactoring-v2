# 3.6 가변 데이터(Mutable Data)
데이터를 변경했더니 예상치 못한 결과나 골치 아픈 버그로 이어지는 경우가 종종 있다. 코드의 다른 곳에서는 다른 값을 기대한다는 사실을 인식하지 못한 채 수정해버리면 프로그램이 오작동한다. 특히 이 문제가 아주 드문 조건에서만 발생한다면 원인을 알아내기가 매우 어렵다. 이런 이유로 함수형 프로그래밍에서는 데이터는 절대 변하지 않고, 데이터를 변경하려면 반드시 (원래 데이터는 그대로 둔 채) 변경하려는 값에 해당하는 복사본을 만들어서 반환한다는 개념을 기본으로 삼고 있다.

하지만 함수형 언어가 프로그래밍에서 차지하는 비중은 여전히 적고 변수 값을 바꿀 수 있는 언어를 사용하는 프로그래머가 더 많다. 그렇다고 해서 불변셩이 주는 장점을 포기할 필요는 없다. 무분별한 데이터 수정에 따른 위험을 줄이는 방법은 얼마든지 있다.

가령 [6.6 변수 캡슐화하기(Encapsulate Variable)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-6.md)를 적용하여 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 하면 값이 어떻게 수정되는지 감시하거나 코드를 개선하기 쉽다. 하나의 변수에 용도가 다른 값들을 저장하느라 값을 갱신하는 경우라면 [9.1 변수 쪼개기(Split Variable)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter09/9-1.md)를 이용하여 용도별로 독립 변수에 저장하게 하여 값 갱신이 문제를 일으킬 여지를 없앤다. 갱신 로직은 다른 코드와 떨어뜨려 놓는 것이 좋다. 그러기 위해 [8.6 문장 슬라이드하기(Slide Statements)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-6.md)와 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md)를 이용해서 무언가를 갱신하는 코드로부터 부작용이 없는 코드를 분리한다. API를 만들 때는 [11.1 질의 함수와 변경 함수 분리하기(Separate Query from Modifier)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-1.md)를 활용해서 꼭 필요한 경우가 아니라면 부작용이 있는 코드를 호출할 수 없게 한다. 우리는 가능한 한 [11.7 세터 제거하기(Remove Setting Method)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-7.md)도 적용한다. 간혹 세터(setter)를 호출하는 클라이언트를 찾는 것만으로도 변수의 유효범위를 줄이는 데 도움될 때가 있다.

값을 다른 곳에서 설정할 수 있는 가변 데이터가 풍기는 악취는 특히 고약하다. 혼동과 버그와 야근을 부를 뿐만 아니라, 쓸데없는 코드이기도 하다. 이럴 때는 [9.3 파생 변수를 질의 함수로 바꾸기(Replace Derived Variable with Query)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter09/9-3.md)에 식초 농축액을 섞어서 코드 전체에 골고루 뿌려준다.

변수의 유효범위가 단 몇 줄이라면 가변 데이터라 해도 문제를 일으킬 일이 별로 없다. 하지만 나중에 유효범위가 넓어질 수 있고, 그러면 위험도 덩달아 커진다. 따라서 [6.9 여러 함수를 클래스로 묶기(Combine Functions into Class)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-9.md)나 [6.10 여러 함수를 변환 함수로 묶기(Combine Functions into Transform)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-10.md)를 활용해서 변수를 갱신하는 코드들의 유효범위를 (클래스나 변환(transform)으로) 제한한다. 구조체처럼 내부 필드에 데이터를 담고 있는 변수라면, 일반적으로 [9.4 참조를 값으로 바꾸기(Change Reference to Value)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter09/9-4.md)를 적용하여, 내부 필드를 직접 수정하지 말고 구조체를 통째로 교체하는 편이 낫다.

- [목차](https://github.com/wonder13662/refactoring-v2/blob/writing)
- [3 코드에서 나는 악취](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter03)
- [3.5 전역 데이터(Global Data)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter03/3-5.md)
- [3.7 뒤엉킨 변경(Divergent Change)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter03/3-7.md)