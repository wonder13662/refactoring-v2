# 3.8 산탄총 수술(Shotgun Surgery)
산탄총 수술은 [3.7 뒤엉킨 변경(Divergent Change)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter03/3-7.md)과 비슷하면서도 정반대다. 

이 냄새는 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 풍긴다. 변경할 부분이 코드 전반에 퍼져 있다면 찾기도 어렵고 꼭 수정해야 할 곳을 지나치기 쉽다.

이럴 때는 함께 변경되는 대상들을 [8.1 함수 옮기기(Move Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-1.md)와 [8.2 필드 옮기기(Move Field)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-2.md)로 모두 한 모듈에 묶어두면 좋다. 비슷한 데이터를 다루는 함수가 많다면 [6.9 여러 함수를 클래스로 묶기(Combine Functions into Class)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-9.md)를 적용한다. 이렇게 묶은 함수들의 출력 결과를 묶어서 다음 단계의 로직으로 전달할 수 있다면 [6.11 단계 쪼개기(Split Phase)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-11.md)를 적용한다.

어설프게 분리된 로직을 [6.2 함수 인라인하기(Inline Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-2.md)나 [7.6 클래스 인라인하기(Inline Class)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-6.md) 같은 인라인 리팩터링으로 하나로 합치는 것도 산탄총 수술에 대처하는 좋은 방법이다. 메서드나 클래스가 비대해지지만, 나중에 추출하기 리팩터링으로 더 좋은 형태로 분리할 수도 있다. 사실 우리는 작은 함수와 클래스에 지나칠 정도로 집착하지만, 코드를 재구성하는 중간 과정에서는 큰 덩어리로 뭉쳐지는데 개의치 않는다.

- [3.7 뒤엉킨 변경(Divergent Change)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter03/3-7.md)
- [3.9 기능 편애(Feature Envy)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter03/3-9.md)