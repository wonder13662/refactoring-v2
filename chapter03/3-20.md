# 3.20 거대한 클래스(Large Class)
한 클래스가 너무 많은 일을 하려다 보면 필드 수가 상당히 늘어난다. 그리고 클래스에 필드가 너무 많으면 중복 코드가 생기기 쉽다.

이럴 때는 [7.5 클래스 추출하기(Extract Class)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-5.md)로 필드들 일부를 따로 묶는다. 같은 컴포넌트에 모아두는 것이 합당해 보이는 필드들을 선택하면 된다. 가령 `depositAmount`와 `depositCurrency` 필드는 같은 컴포넌트에 두는 것이 좋을 것이다. 더 일반적으로는, 한 클래스 안에서 접두어나 접미어가 같은 필드들이 함께 추출할 후보들이다. 이렇게 분리할 컴포넌트를 원래 클래스와 상속 관계로 만드는 게 좋다면 (클래스 추출하기보다는) [12.8 슈퍼클래스 추출하기(Extract Subclasses)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-8.md)나 (실질적으로 서브클래스 추출하기에 해당하는)[12.6 타입 코드를 서브클래스로 바꾸기(Replace Type Code with Subclasses)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-6.md)를 적용하는 편이 더 쉬울 것이다.

클래스가 항시 모든 필드를 사용하지는 않을 수도 있다. 이럴 때는 앞에서 언급한 추출 기법들을 여러 차례 수행해야 할지도 모른다.

필드가 너무 많은 클래스와 마찬가지로 코드량이 너무 많은 클래스도 중복 코드와 혼동을 일으킬 여지가 크다. 가장 간단한 해법은 그 클래스 안에서 자체적으로 중복을 제거하는 것이다(참고로 우리는 간단한 해결책을 좋아한다). 가령 부분부분 상당량의 로직이 똑같은 100줄짜리 메서드 다섯 개가 있다면 각각의 공통 부분을 작은 메서드들로 뽑아내자. 그러면 원래의 다섯 메서드들에는 작은 메서드들을 호출하는 코드 10줄만 남게 될지도 모른다.

클라이언트들이 거대 클래스를 이용하는지 패턴을 파악하여 그 클래스를 어떻게 쪼갤지 단서를 얻을 수도 있다. 먼저 클라이언트들이 거대 클래스의 특정 기능 그룹만 주로 사용하는지 살핀다. 이때 각각의 기능 그룹이 개별 클래스로 추출될 후보다. 유용한 기능 그룹을 찾았다면 [7.5 클래스 추출하기(Extract Class)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-5.md), [12.8 슈퍼클래스 추출하기(Extract Subclasses)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-8.md), [12.6 타입 코드를 서브클래스로 바꾸기(Replace Type Code with Subclasses)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter12/12-6.md) 등을 활용해서 여러 클래스로 분리한다.

- [목차](https://github.com/wonder13662/refactoring-v2/blob/writing/README.md)
- [3 코드에서 나는 악취](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter03)
- [3.19 내부자 거래(Insider Trading)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter03/3-19.md)
- [3.21 서로 다른 인터페이스의 대안 클래스들(Alternative Classes with Different Interaces)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter03/3-21.md)