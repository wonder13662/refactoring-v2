# 3.9 기능 편애(Feature Envy)
프로그램을 모듈화할 때는 코드를 여러 영역으로 나눈 뒤 영역 안에서 이뤄지는 상호작용은 최대한 늘리고 영역 사이에서 이뤄지는 상호작용은 최소로 줄이는 데 주력한다. 기능 편애는 흔히 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용 할 일이 더 많을 때 풍기는 냄새다. 우리는 실행 과정에서 외부 객체의 게터 메서드 대여섯 개를 호출하도록 작성된 함수를 수없이 봤다. 다행히 해결하기는 쉽다. 이 함수가 데이터와 가까이 있고 싶어 한다는 의중이 뚜렷이 드러나므로 소원대로 데이터 근처로 옮겨주면 된다([8.1 함수 옮기기(Move Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-1.md)). 때로는 함수의 일부에서만 기능을 편애할 수 있다. 이럴 때는 그 부분만 독립 함수로 빼낸 다음([6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md)) 원하는 모듈로 보내준다([8.1 함수 옮기기(Move Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-1.md)).

물론 어디로 옮길지가 명확하게 드러나지 않을 때도 있다. 예컨대 함수가 사용하는 모듈이 다양하다면 어느 모듈로 옮겨야 할까? 이럴 때 우리는 가장 많은 데이터를 포함한 모듈로 옮긴다. [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md)로 함수를 여러 조각으로 나눈 후 각각을 적합한 모듈로 옮기면 더 쉽게 해결되는 경우도 많다.

한편, 앞의 두 문단에서 설명한 규칙을 거스르는 복잡한 패턴도 있다. 당장 떠오르는 것으로는 "디자인 패턴" 중 전략 패턴(Strategy Pattern)과 방문자 패턴(Visitor Pattern)이 있다. [켄트 벡의 자기 위임(Self-Delegation)](https://www.amazon.com/Smalltalk-Best-Practice-Patterns-Kent/dp/013476904X)도 여기 속한다. 이들은 모두 뒤엉킨 변경 냄새를 없앨 때 활용하는 패턴들로, 가장 기본이 되는 원칙은 '함께 변경할 대상을 한데 모으는 것'이다. 데이터와 이를 활용하는 동작은 함께 변경해야 할 때가 많지만, 예외가 있다. 그럴 때는 같은 데이터를 다루는 코드를 한 곳에서 변경할 수 있도록 옮긴다. 전략 패턴과 방문자 패턴을 적용하면 오버라이드해야 할 소량의 동작 코드를 각각의 클래스로 격리해주므로 수정하기가 쉬워진다(대신 간접 호출이 늘어난다).

- [목차](https://github.com/wonder13662/refactoring-v2/blob/writing/README.md)
- [3 코드에서 나는 악취](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter03)
- [3.8 산탄총 수술(Shotgun Surgery)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter03/3-8.md)
- [3.10 데이터 뭉치(Data Clumps)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter03/3-10.md)