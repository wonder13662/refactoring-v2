## Chapter 03 코드에서 나는 악취
> #### 냄새나면 당장 갈아라
> 켄트 벡 할머니의 육아 원칙

### 3.1 기이한 이름(Myserious Name)
- 코드를 명료하게 표현하는 데 가장 중요한 요소 하나는 바로 '이름'이다. 그래서 함수, 모듈, 변수, 클래스 등은 그 이름만 보고도 각각이 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 엄청나게 신경 써서 이름을 지어야 한다.
- 가장 많이 사용하는 리팩터링도 **함수 선언 바꾸기**, **변수 이름 바꾸기**, **필드 이름 바꾸기**처럼 이름을 바꾸는 리팩터링들이다.
- 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다.

### 3.2 중복 코드(Duplicated Code)
- 한 클래스에 딸린 두 메서드가 똑같은 표현식을 사용하면, **함수 추출하기**로 양쪽 모두 추출된 메서드를 호출하도록 한다
- 코드가 비슷하긴 한데 완전히 똑같지는 않다면, **문장 슬라이드하기**로 비슷한 부분을 한 곳에 모다 함수 추출하기를 더 쉽게 적용할 수 있는지 살펴본다
- 같은 부모로부터 파생된 서브 클래스들에 코드가 중복되어 있다면, 각자 따로 호출되지 않도록 **메서드 올리기**를 적용해 부모로 옮긴다

### 3.3 긴 함수(Long Function)
- 오랜 기간 잘 활용되는 프로그램들은 짧은 함수로 구성됨
- 코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나오는 것이다
- 코드를 읽는 사람 입장에서는 함수가 하는 일을 파악하기 위해 왔다 갔다 해야하므로 부담
- 그래서 함수 이름을 잘 지어두면 본문 코드를 볼 이유가 사라진다
- 주석을 달아야 할 부분은 무조건 함수로 만든다
- 함수의 이름은 동작 방식이 아닌 '의도(intention)'가 드러나게 만든다
- **함수 추출하기** 함수 본문에서 따로 묶어 빼내면 좋은 코드 덩어리를 찾아 새로운 함수로 만드는 것
- 함수가 매개변수와 임시 변수를 많이 사용한다면 추출 작업에 방해가 됨
  - **임시 변수를 질의 함수로 바꾸기**로 임시 변수의 수를 줄인다
  - **매개변수 객체 만들기**와 **객체 통째로 넘기기**로 매개변수의 수를 줄인다
  - 여전히 임시변수와 매개변수가 너무 많다면 **함수를 명령으로 바꾸기**를 고려
- 추출할 코드 덩어리는 어떻게 찾아낼까?
  - 주석을 찾자. 주석이 설명하는 코드와 함께 함수로 빼냄. 함수 이름은 주석 내용을 토대로 지음
  - 코드가 단 한 줄이어도 따로 설명할 필요가 있다면 함수로 추출하는 게 좋다
  - 조건문이나 반복문도 추출 대상의 실마리를 준다
    - 조건문은 **조건문 분해하기**
    - 거대한 switch문을 구성하는 case문마다 **함수 추출하기** 적용, 각 case 본문을 함수 호출문 하나로 바꾼다
    - 같은 조건을 기준으로 나뉘는 switch문이 여러 개라면 **조건문을 다형성으로 바꾸기**를 적용한다
    - 반복문도 그 안의 코드와 함께 추출, 독립된 함수로 만든다
      - 추출한 반복문 코드에 적절한 이름이 떠오르지 않는다면 성격이 다른 두 가지 작업이 섞여 있기 때문
      - **반복문 쪼개기**를 적용해서 작업을 분리

### 3.4 긴 매개변수 목록(Long Parameter List)
- 매개변수 목록이 길어지면 그 자체로 이해하기 어려울 때가 많음
- 다른 매개변수에서 값을 얻어올 수 있는 매개변수가 있을 수 있음. 이런 매개변수는 **매개변수를 질의함수로 바꾸기**로 제거할 수 있다
- 사용 중인 데이터 구조에서 값들을 뽑아 각각을 별개의 매개변수로 전달하는 코드라면 **객체 통째로 넘기기**를 적용해서 원본 데이터 구조를 그대로 전달
- 항상 함께 전달되는 매개변수들은 **매개변수 객체 만들기**로 하나로 묶음
- 함수의 동작 방식을 정하는 플래그 역할의 매개변수는 **플래그 인수 제거하기**로 없앰
- 클래스는 매개변수 목록을 줄이는 데 효과적인 수단. **여러 함수를 클래스로 묶기**를 이용, 공통 값들을 클래스의 필드로 정의한다

### 3.5 전역 데이터(Global Data)
- 전역 데이터의 대표적인 형태는 전역 변수지만, 클래스 변수와 싱글톤(singleton)에서도 같은 문제가 발생한다
- 이를 방지하기 위해, **변수 캡슐화하기**를 하자. 다른 코드에서 오염시킬 가능성이 있는 데이터를 발견할 때마다 이 기법을 가장 먼저 적용한다.
  - 이런 데이터를 함수로 감싸는 것만으로도 데이터를 수정하는 부분을 쉽게 찾을 수 있고, 접근을 통제할 수 있다.
  - 더 나아가 접근자 함수들을 클래스나 모듈에 집어넣고 그 안에서만 사용할 수 있도록 접근 범위를 최소로 줄이는 것도 좋음
- 전역 데이터가 가변(mutable)이라면 다루기 까다로움. 전역 데이터가 아주 조금이더라도 캡슐화해라

### 3.6 가변 데이터(Mutable Data)
- 데이터를 변경하면 버그로 이어지는 경우가 많음. 특히 아주 드문 조건에서만 발생한다면 원인을 찾기 매우 어려움
- 이런 이유로 함수형 프로그래밍에서는 데이터는 절대 변하지 않고, 데이터를 변경하려면 반드시(원래 데이터는 그대로 둔 채) 변경하려는 값에 해당하는 복사본을 만들어서 반환한다는 개념을 기본으로 삼음
- 무분별한 데이터 수정에 따른 위험을 줄이는 방법은 얼마든지 있다
  - **변수 캡슐화하기**를 적용, 정해놓은 삼후를 거쳐야만 값을 수정할 수 있도록 하면 값이 어떻게 수정되는지 감시하거나 코드를 개선하기 쉽다
  - 하나의 변수에 용도가 다른 값들을 저장하느라 값을 갱신하는 경우라면 **변수 쪼개기**를 이용하여 용도별로 독립 변수에 저장하게 하여 값 갱신이 문제를 일으킬 여지를 없앤다
  - 갱신 로직은 다른 코드와 떨어뜨려 놓는 것이 좋다
    - **문장 슬라이드하기**와 **함수 추출하기**를 이용해서 무언가를 갱신하는 코드들로부터 부작용이 없는 코드를 분리한다
    - API를 만들 때는 **질의 함수와 변경 함수 분리하기**를 활용해서 꼭 필요한 경우가 아니라면 부작용이 있는 코드를 호출할 수 없게 한다
    - 가능하다면 **세터 제거하기**도 적용한다. 세터(setter)를 호출하는 클라이언트를 찾는 것만으로도 변수의 유효범위를 줄이는 데 도움이 될 때가 있다