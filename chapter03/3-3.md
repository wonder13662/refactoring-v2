# 3.3 긴 함수(Long Function)
우리의 경험에 비춰보면 오랜 기간 잘 활용되는 프로그램들은 하나같이 짧은 함수로 구성됐다. 짧은 함수들로 구성된 코드베이스를 얼핏 훑으면 연산하는 부분이 하나도 없어 보인다. 코드가 끝없이 위임하는 방식으로 작성되어 있기 때문이다. 하지만 이런 프로그램을 수년 동안 다루다 보면 이 짧은 함수들이 얼마나 중요한지 깨닫게 된다. 간접 호출(indirection)의 효과, 즉 코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나오는 것이다.

프로그래밍 초창기부터 사람들은 함수가 길수록 이해하기 어렵다는 사실을 깨달았다. 예전 언어는 서브루틴을 호출하는 비용이 컸기 때문에 짧은 함수를 꺼렸다. 하지만 요즘 언어는 프로세스 안에서의 함수 호출 비용을 거의 없애 버렸다. 물론 코드를 읽는 사람 입장에서는 함수가 하는 일을 파악하기 위해 왔다 갔다 해야 하므로 여전히 부담이 된다. 다행히 함수 호출부와 선언부 사이를 빠르게 이동하거나 호출과 선언을 동시에 보여주는 개발 환경을 활용하면 이 부담이 줄어들지만, 짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 좋은 이름이다. 함수 이름을 잘 지어두면 본문 코드를 볼 이유가 사라진다.

그러기 위해서는 훨씬 적극적으로 함수를 쪼개야 한다. 우리는 주석을 달아야 할 만한 부분은 무조건 함수로 만든다. 그 함수 본문에는 원래 주석으로 설명하려던 코드가 담기고, 함수 이름은 동작 방식이 아닌 '의도(intention)'가 드러나게 짓는다. 이렇게 함수로 묶는 코드는 여러 줄일 수도 있고 단 한 줄일 수도 있다. 심지어 원래 코드보다 길어지더라도 함수로 뽑는다. 단, 함수 이름에 코드의 목적을 드러내야 한다. 여기서 핵심은 함수의 길이가 아닌, 함수의 목적(의도)과 구현 코드의 괴라가 얼마나 큰가다. 즉, '무엇을 하는지'를 코드가 잘 설명해주지 못할수록 함수로 만드느 게 유리하다.

함수를 짧게 만드는 작업의 99%는 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md)가 차지한다. 함수 본문에서 따로 묶어 빼내면 좋은 코드 덩어리를 찾아 새로운 함수로 만드는 것이다.

함수가 매개변수와 임시 변수를 많이 사용한다면 추출 작업에 방해가 된다. 이런 상황에서 함수를 추출하다 보면 추출된 함수에도 매개변수가 너무 많아져서 리팩터링 전보다 난해해질 수 있다. 그렇다면 [7.4 임시 변수를 질의 함수로 바꾸기(Replace Temp with Query)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-4.md)로 임시 변수의 수를, [6.8 매개변수 객체 만들기(Introduce Parameter Object)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-8.md)와 [11.4 객체 통째로 넘기기(Preserve Whole Object)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-4.md)로는 매개변수의 수를 줄일 수 있을 것이다.

이 리팩터링들을 적용해도 여전히 임시 변수와 매개변수가 너무 많다면 더 큰 수술이라 할 수 있는 [11.9 함수를 명령으로 바꾸기(Replace Function with Command)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-9.md)를 고려해보자.

그렇다면 추출할 코드 덩어리는 어떻게 찾아낼까? 한 가지 좋은 방법은 주석을 참고하는 것이다. 주석은 코드만으로는 목적을 이해하기 어려운 부분에 달려 있는 경우가 많다. 이런 주석을 찾으면 주석이 설명하는 코드와 함께 함수로 빼내고, 함수 이름은 주석 내용을 토대로 짓는다. 코드가 단 한줄이어도 따로 설명할 필요가 있다면 함수로 추출하는 게 좋다.

조건문이나 반복문도 추출 대상의 실마리를 제공한다. 조건문은 [10.1 조건문 분해하기(Decompose Conditional)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-1.md)로 대응한다. 거대한 switch 문을 구성하는 case문마다 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md)를 적용해서 각 case의 본문을 함수 호출문 하나로 바꾼다. 같은 조건을 기준으로 나뉘는 switch문이 여러 개라면 [10.4 조건부 로직을 다형성으로 바꾸기(Replace Conditional with Polymorphism)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-4.md)를 적용한다.

반복문도 그 안의 코드와 함께 추출해서 독립된 함수로 만든다. 추출한 반복문 코드에 적합한 이름이 떠오르지 않는다면 성격이 다른 두 가지 작업이 섞여 있기 때문일 수 있다. 이럴 때는 과감히 [8.7 반복문 쪼개기(Split loop)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-7.md)를 적용해서 작업을 분리한다.

- [목차](https://github.com/wonder13662/refactoring-v2/blob/writing)
- [3 코드에서 나는 악취](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter03)
- [3.2 중복 코드(Duplicated Code)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter03/3-2.md)
- [3.4 긴 매개변수 목록(Long Parameter List)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter03/3-4.md)