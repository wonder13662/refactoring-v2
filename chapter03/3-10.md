# 3.10 데이터 뭉치(Data Clumps)
데이터 항목들은 어린아이 같은 면이 있다. 서로 어울려 노는 것을 좋아한다. 그래서 데이터 항목 서너 개가 여러 곳에서 항상 함께 뭉쳐 다니는 모습을 흔히 목격할 수 있다. 클래스 두어 개의 필드에서, 혹은 여러 메서드의 시그니처에서 함께 발견되기도 한다. 이렇게 몰려다니는 데이터 뭉치는 보금자리를 따로 마련해줘야 마땅하다.

가장 먼저 필드 형태의 데이터 뭉치를 찾아서 [7.5 클래스 추출하기(Extract Class)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter07/7-5.md)로 하나의 객체로 묶는다. 다음은 메서드 시그니처에 있는 데이터 뭉치 차례다. 먼저 [6.8 매개변수 객체 만들기(Introduce Parameter Object)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-8.md)나 [11.4 객체 통째로 넘기기(Preserve Whole Object)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter11/11-4.md)를 적용해서 매개변수 수를 줄여본다. 그 즉시 메서드 호출 코드가 간결해질 것이다. 데이터 뭉치가 앞에서 새로 만든 객체의 필드 중 일부만 사용하더라도 걱정할 필요가 없다. 새 객체로 뽑아낸 필드가 두 개 이상이기만 해도 확실히 예전보다 나아지기 때문이다.

데이터 뭉치인지 판별하려면 값 하나를 삭제해보자. 그랬을 때 나머지 데이터만으로는 의미가 없다면 객체로 환생하길 갈망하는 데이터 뭉치라는 뜻이다.

방금 설명에서 간단한 레코드 구조가 아닌 '클래스'로 만들기를 권했음을 눈치챘는가? 클래스를 이용하면 좋은 향기를 흩뿌릴 기회가 생기기 때문이다. 기능 편애를 없애는 과정에서 새로운 클래스를 만들었다면, 이어서 그 클래스로 옮기면 좋을 동작은 없는지 살펴보자. 이러한 연계 과정은 종종 상당한 중복을 없애고 향후 개발을 가속하는 유용한 클래스를 탄생시키는 결과로 이어지기도 한다. 데이터 뭉치가 생산성에 기여하는 정식 멤버로 등극하는 순간이다.

- [3.9 기능 편애(Feature Envy)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter03/3-9.md)
- [3.11 기본형 집착(Primitive Obsession)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter03/3-11.md)