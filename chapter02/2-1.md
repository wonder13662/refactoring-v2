
# 2.1 리팩터링 정의
수많은 다른 소프트웨어 개발 용어와 마찬가지로 '리팩터링(refactoring)'도 엔지니어들 사이에서 다소 두리뭉실한 의미로 통용된다. 하지만 나는 이 용어를 더 구체적인 의미로 사용하며, 그렇게 엄격하게 정의해야 더 유용하다고 생각한다(참고로 이 책 초판에서의 정의 그대로다). '리팩터링'이란 용어는 명사도로 쓸 수 있고, 동사도로 쓸 수 있다. 먼저 명사로 쓸 때는 다음과 같이 정의한다

> **리팩터링**: [명사]소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법

앞 장에서 본 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md)와 [10.4 조건부 로직을 다형성으로 바꾸기(Replace Conditional with Polymorphism)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter10/10-4.md)처럼 이름 붙은 리팩터링 기법들이 이 정의에 해당한다.

동사 버전의 리팩터링 정의는 다음과 같다.

> **리팩터링(하다)**: [동사]소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.

예를 들어 두 버전의 용어를 한 문장에 담으면 '앞으로 몇 시간은 리팩터링할 것 같은데 그 사이 적용하는 리팩터링은 수십 가지나 될 것 같다'처럼 표현할 수 있다.

지금껏 수많은 사람들이 코드를 정리하는 작업을 모조리 '리팩터링'이라고 표현하고 있는데, 앞에서 제시한 정의를 따르면 특정한 방식에 따라 코드를 정리하는 것만이 리팩터링이다. 리팩터링은 결국 동작을 보존하는 작은 단계들을 거쳐 코드를 수정하고, 이러한 단계들을 순차적으로 연결하여 큰 변화를 만들어내는 일이다. 개별 리팩터링은 그 자체로 아주 작을 수도 있고, 작은 단계 여러 개가 합쳐진 모습일 수도 있다. 따라서 리팩터링하는 동안에는 코드가 항상 정상 동작하기 때문에 전체 작업이 끝나지 않았더라도 언제든 멈출 수 있다.

> 누군가 "리팩터링하다가 코드가 깨져서 며칠이나 고생했다"라고 한다면, 십중팔구 리팩터링한 것이 아니다.

나는 코드베이스를 정리하거나 구조를 바꾸는 모든 작업을 '재구성(restructuring)'이라는 포괄적인 용어로 표현하고, 리팩터링은 재구성 중 특수한 형태로 본다. 한 번에 바꿀 수 있는 작업을 수많은 단계로 잘게 나눠서 작업하는 모습을 처음 접하면 리팩터링하는 것이 오히려 비효율적이라고 생각하기 쉽다. 하지만 이렇게 잘게 나눔으로써 오히려 작업을 더 빨리 처리할 수 있다. 단계들이 체계적으로 구성되어 있기도 하고, 무엇보다 디버깅하는 데 시간을 뺏기지 않기 때문이다.

앞에서 리팩터링을 정의할 때 '겉보기 동작(observable behavior)'이란 표현을 썼다. 일부러 두리뭉실하게 표현했는데, 리팩터링하기 전과 후의 코드가 똑같이 동작해야 한다는 뜻이다. 그렇다고 완전히 똑같다는 말은 아니다. 가령 [6.1 함수 추출하기(Extract function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-1.md)를 거치면 콜스택이 달라져서 성능이 변할 수 있다. 그렇다 해도 사용자 관점에서는 달라지는 점이 없어야 한다. 특히 [6.5 함수 선언 바꾸기(Change Function Declaration)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-5.md)나 [8.1 함수 옮기기(Move Function)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter08/8-1.md)같은 리팩터링을 하면 모듈의 인터페이스가 바뀔 때가 많다. 한편, 리팩터링 과정에서 발견된 버그는 리팩터링 후에도 그대로 남아 있어야 한다(단, 아무도 발견못한 숨은 버그는 수정해도 괜찮다).

리팩터링은 성능 최적화와 비슷하다. 둘 다 코드를 변경하지만 프로그램의 전반적인 기능은 그대로 유지한다. 단지 목적이 다를 뿐이다. 리팩터링의 목적은 코드를 이해하고 수정하기 쉽게 만드는 것이다. 프로그램 성능은 좋아질 수도, 나빠질 수도 있다. 반면 성능 최적화는 오로지 속도 개선에만 신경 쓴다. 그래서 목표 성능에 반드시 도달해야 한다면 코드는 다루기에 더 어렵게 바뀔 수도 있음을 각오해야 한다.

- [목차](https://github.com/wonder13662/refactoring-v2/blob/writing)
- [1 리팩터링: 첫 번째 예시](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter01)
- [1.10 마치며](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter01/1-10.md)
- [2 리팩터링 원칙](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter02)
- [2.2 두 개의 모자](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter02/2-2.md)
