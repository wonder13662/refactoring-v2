# 2.5 리팩터링 시 고려할 문제
나는 누가 특정한 기술, 도구, 아키텍처 등을 내새울 때마다 항상 문제점을 찾는다. 살다 보면 항상 화창한 날만 있는 것은 아니다. 그래서 무언가를 언제 어디에 적용할지 판단하려면 손익을 제대로 이해해야 한다. 난 리팩터링이 많은 팀에서 적극적으로 도입해야 할 중요한 기법이라 믿는다. 하지만 리팩터링에 딸려 오는 문제도 엄연히 있기에, 이런 문제가 언제 발생하고 어떻게 대처해야 할지를 반드시 알고 있어야 한다.

#### 새 기능 개발 속도 저하
앞 절을 읽었다면 제목의 주장에 대한 내 답변을 충분히 예상할 것이다. 많은 사람이 리팩터링 때문에 새 기능을 개발하는 속도가 느려진다고 여기지만, 리팩터링의 궁극적인 목적은 개발 속도를 높이는 데 있다. 하지만 리팩터링으로 인해 진행이 느려진다고 생각하는 사람이 여전히 많다. 아마도 이 점이 실전에서 리팩터링을 제대로 적용하는 데 가장 큰 걸림돌인 것 같다.

> 리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다.

그렇더라도 상황에 맞게 조율해야 한다. 예컨대 (대대적인) 리팩터링이 필요해 보이지만, 추가하려는 새 기능이 아주 작아서 기능 추가부터 하고 싶은 상황에 마주칠 수 있다. 이럴 때는 프로 개발자로서 가진 경험을 잘 발휘해서 결정한다. 이럴 때 내가 균형점을 잡는 방법을 설명하기는 쉽지 않고, 정량화하기는 더더욱 어렵다.

나는 준비를 위한 리팩터링을 하면 변경을 훨씬 쉽게 할 수 있다고 확신한다. 그래서 새 기능을 구현해넣기 편해지겠다 싶은 리팩터링이라면 주저하지 않고 리팩터링부터 한다. 한번 본 문제일 때도 리팩터링부터 하는 편이다(물론 비슷한 패턴의 지저분한 코드를 여러 차례 마주친 뒤에야 리팩터링하여 제거하기로 결정할 때도 있다). 반면 내가 직접 건드릴 일이 거의 없거나, 불편한 정도가 그리 심하지 않다고 판단되면 리팩터링하지 않는 편이다. 때로는 어떻게 개선해야 할지 확실히 떠오르지 않아서 리팩터링을 미루기도 한다. 물론 개선점이 떠오르면 시험 삼아 고쳐보고 더 나아지는지 살펴본다.

주변 동료들의 경험담을 들어보면 아직도 리팩터링을 과도하게 하는 경우보다 거의 하지 않는 경우가 훨씬 많다. 다시 말해 대부분은 리팩터링을 더 자주 하도록 노력해야 한다. 건강한 코드의 위력을 충분히 경험해보지 않고서는 코드베이스가 건강할 때와 허약할 때의 생산성 차이를 체감하기 어렵다. 코드베이스가 건강하면 기존 코드를 새로운 방식으로 조합하기 쉬워서 복잡한 새 기능을 더 빨리 추가할 수 있다.

개발 속도 저하를 이유로 리팩터링을 금하는 비생산적인 문화를 관리자 탓으로 돌리는 사람이 많지만, 나는 오히려 개발자 스스로가 그렇게 생각하는 경우도 많이 봤다. 심지어 관리자가 리팩터링에 호의적임에도 리팩터링하면 안 되는 줄 아는 사람도 있다. 개발팀을 이끌고 있다면 코드베이스가 더 건강해지는 것을 추구한다는 사실을 팀원들에게 명확히 밝혀야 한다. 앞에서 말한 리팩터링 할지 말지를 판단하는 능력은 수년에 걸친 경험을 통해서 서서히 형성된다. 리더는 리팩터링 경험이 부족한 이들이 이런 능력을 빠르게 갖추도록 개발 과정에서 많이 이끌어줘야 한다.

하지만 내가 볼 때 사람들이 빠지기 쉬운 가장 위험한 오류는 리팩터링을 '클린 코드(clean code)'나 '바람직한 엔지니어링 습관'처럼 도덕적인 이유로 정당화하는 것이다. 리팩터링의 본딜은 코드베이스를 예쁘게 꾸미는 데 있지 않다. 오로지 경제적인 이유로 하는 것이다. 리팩터링은 개발 기간을 단축하고자 하는 것이다. 기능 추가 시간을 줄이고, 버그 수정 시간을 줄여준다. 스스로 그렇게 인식하는 데 그치지 말고 다른 사람과 대화할 때도 이 점을 명심해야 한다. 리팩터링하도록 이끄는 동력은 어디까지나 경제적인 효과에 있다. 이를 명확히 이해하는 개발자, 관리자, 고객이 많아질수록 앞에서 본 소프트웨어 개발 진행 그래프에서 '좋은 설계' 곡선을 더 많이 볼 수 있다.

#### 코드 소유권
리팩터링하다 보면 모듈의 내부뿐 아니라 시스템의 다른 부분과 연동하는 방식에도 영향을 주는 경우가 많다. 함수 이름을 바꾸고 싶고 그 함수를 호출하는 곳을 모두 찾을 수 있다면, 간단히 [6.5 함수 선언 바꾸기(Change Function Declaration)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-5.md)로 선언 자체와 호출하는 곳 모두를 한 번에 바꿀 수 있다. 하지만 이렇게 간단하지 않을 때도 있다. 함수를 호출하는 코드의 소유자가 다른 팀이라서 나에게는 쓰기 권한이 없을 수 있다. 또는 바꾸려는 함수가 고객에게 API로 제공된 것이라면 누가 얼마나 쓰고 있는지는 고사하고, 실제로 쓰이거나 하는지조차 모를 수 있다. 이런 함수는 인터페이스를 누가 선언했는지에 관계없이 클라이언트가 사용하는 '공개된 인터페이스'에 속한다.

코드 소유권이 나뉘어 있으면 리팩터링에 방해가 된다. 클라이언트에 영향을 주지 않고서는 원하는 형태로 변경할 수 없기 때문이다. 그렇다고 리팩터링을 할 수 없는 건 아니다. 여전히 훌륭하게 개선할 수 있지만 제약이 따를 뿐이다. 예컨대 함수 이름을 변경할 때는 [6.5 함수 선언 바꾸기(Change Function Declaration)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-5.md)를 적용하는 한편, 기존 함수도 그대로 유지하되 함수 본문에서 새 함수를 호출하도록 수정한다. 인터페이스는 복잡해지지만 클라이언트에 영향을 주지 않기 위해서는 어쩔 수 없다. 기존 인터페이스를 폐기 대상(deprecated)으로 지정하고 시간이 흐른 뒤에 삭제할 수도 있지만, 때로는 영원히 남겨둬야 할 수도 있다.

이처럼 복잡해지기 때문에 나는 코드 소유권을 작은 단위로 나눠 엄격히 관리하는 데 반대하는 입장이다. 어떤 조직은 모든 코드의 소유권을 한 사람에게 맡기고 그 사람만 코드를 수정할 수 있게 하기도 한다. 또 세 명의 팀원 각자가 상대방에게 공개 인터페이스를 제공하는 사례도 봤다. 이렇게 하면 코드베이스에서 곧바로 수정하면 훨씬 간단한 일을 계속해서 인터페이스를 관리하느라 시달리는 결과를 초래한다. 내가 선호하는 방식은 코드의 소유권을 팀에 두는 것이다. 그래서 팀원이라면 누구나 팀이 소유한 코드를 수정할 수 있게 한다. 설사 다른 사람이 작성했더라도 말이다. 프로그래머마다 각자가 책임지는 영역이 있을 수는 있다. 이 말은 자신이 맡은 영역의 변경 사항을 관리하라는 뜻이지, 다른 사람이 수정하지 못하게 막으라는 뜻이 아니다.

이렇게 코드 소유권을 느슨하게 정하는 방식은 여러 팀으로 구성된 조직에도 적용할 수 있다. 예컨대 어떤 팀은 다른 팀 사람이 자기 팀 코드의 브랜치를 따서 수정하고 커밋을 요청하는, 흡사 오픈소스 개발 모델을 권장하기도 한다. 이렇게 하면 함수의 클라이언트도 바꿀 수 있다. 즉, 변경 사항 커밋을 클라이언트를 관리하는 쪽에서 승인하면 기존 함수를 삭제할 수 있다. 이 방식은 코드 소유권을 엄격히 제한하는 방식과 완전히 풀어서 변경을 통제하기 어려운 방식을 절충한 것으로, 대규모 시스템 개발 시 잘 어울린다.

#### 브랜치
현재 흔히 볼 수 있는 팀 단위 작업 방식은 버전 관리 시스템을 사용하여 팀원마다 코드베이스의 브랜치(branch)를 하나씩 맡아서 작업하다가, 결과물이 어느 정도 쌓이면 마스터(master) - Github은 2021년 이후로 메인(main) - 브랜치(또는 트렁크 trunk)에 통합해서 다른 팀원과 공유하는 것이다. 그런데 이렇게 하면 어떤 기능 전체를 한 브랜치에만 구현해놓고, 프로덕션 버전으로 릴리스할 때가 되서야 마스터에 통합하는 경우가 많다. 이 방식을 선호하는 이들은 작업이 끝나지 않은 코드가 마스터에 섞이지 않고, 기능이 추가될 때마다 버전을 명확히 나눌 수 있고, 기능에 문제가 생기면 이전 상태로 쉽게 되돌릴 수 있어서 좋다고 한다.

하지만 이런 기능 브랜치 방식에는 단점이 있다. 독립 브랜치로 작업하는 기간이 길어질수록 작업 결과를 마스터로 통합하기가 어려워진다. 이 고통을 줄이고자 많은 이들이 마스터를 개인 브랜치로 수시로 리베이스(rebase)하거나 머지(merge)한다. 하지만 여러 기능 브랜치에서 동시에 개발이 진행될 때는 이런 식으로는 해결할 수 없다. 나는 머지와 통합을 명확히 구분한다. 마스터 브랜치로 '머지'하는 작업은 단방향이다. 브랜치만 바뀌고 마스터는 그대로다. 반면 '통합'은 마스터를 개인 브랜치로 가져와서(pull) 작업한 결과를 다시 마스터에 올리는(push) 양방향 처리를 뜻한다. 그래서 마스터와 브랜치가 모두 변경된다. 누군가 개인 브랜치에서 작업한 내용을 마스터에 통합하기 전까지는 다른 사람이 그 내용을 볼 수 없다. 통합한 뒤에는 마스터에서 달라진 내용을 내 브랜치에 머지해야 하는데, 그러려면 상당한 노력이 들 수 있다. 특히 의미가 변한 부분을 처리하기가 만만치 않다. 최신 버전 관리 시스템은 복잡한 변경 사항을 텍스트에서 머지하는 데는 매우 뛰어나지만, 코드의 의미는 전혀 이해하지 못한다. 가령 함수 이름이 바뀌는 정도는 가볍게 통합해준다. 하지만 다른 브랜치에서 함수를 호출하는 코드를 추가했는데, 내 브랜치에서는 그 함수의 이름을 변경했다면 프로그램이 동작하지 않게 된다.

이처럼 머지가 복잡해지는 문제는 기능별 브랜치들이 독립적으로 개발되는 기간이 길어질수록 기하급수적으로 늘어난다. 4주간 작업한 브랜치들을 통합하는 노력은 2주간 작업한 브랜치들을 통합할 때보다 두 배 이상 든다. 이 때문에 기능별 브랜치의 통합 주기를 2~3일 단위로 짧게 관리해야 한다고 주장하는 사람이 많다. 한편 나와 같은 사람들은 더 짧아야 한다고 주장한다. 이 방식을 지속적 통합(CI - Continuous Integration), 또는 트렁크 기반 개발(TBD - Trunk-Based Development)이라 한다. CI에 따르면 모든 팀원이 하루에 최소 한 번은 마스터와 통합한다. 이렇게 하면 다른 브랜치들과의 차이가 크게 벌어지는 브랜치가 없어져서 머지의 복잡도를 상당히 낮출 수 있다. 하지만 CI를 적용하기 위해서는 치러야 할 대가가 있다. 마스터를 건강하게 유지하고, 거대한 기능을 잘게 쪼개는 법을 배우고, 각 기능을 끌 수 있는 기능 토글(feature toggle) 또는 기능 플래그(feature flag)를 적용하여 완료되지 않은 기능이 시스템 전체를 망치지 않도록 해야 한다.

머지의 복잡도를 줄일 수 있어서 CI를 선호하기도 하지만, 가장 큰 이유는 리팩터링과 궁합이 아주 좋기 때문이다. 리팩터링을 하다 보면 코드베이스 전반에 걸쳐 자잘하게 수정하는 부분이 많을 때가 있다. 프로그램 전체에서 자주 사용하는 함수의 이름을 바꾸는 경우가 이러한 예다. 이렇게 되면 머지 과정에서 의미 충돌이 생기기 쉽다. 특히 기능별 브랜치 방식에서는 리팩터링을 도저희 진행할 수 없을 정도로 심각한 머지 문제가 발생하기 쉽다. 켄트 벡이 CI와 리팩터링을 합쳐서 **익스트림 프로그래밍(eXtreme Programming - XP)**을 만든 이유도 바로 두 기법의 궁합이 잘 맞기 때문이다.

기능별 브랜치를 사용하면 절대 안 된다는 말은 아니다. 브랜치를 자주 통합할 수만 있다면 문제가 발생할 가능성을 크게 줄일 수 있다. 실제로 CI를 적용하는 이들도 기능별 브랜치를 많이 사용한다(단, 마스터와 통합하는 작업을 매일 한다). 잘 모르는, 그래서 믿지 못하는 프로그래머로부터 이따금 커밋이 들어오는 오픈 소스 프로젝트라면 기능별 브랜치 방식이 적합할 수 있다. 하지만 풀타임 개발팀이라면 기능별 브랜치가 가져오는 리팩터링 부담은 너무나 크다. 그래서 CI를 완벽히 적용하지는 못하더라도 통합 주기만큼은 최대한 짧게 잡아야 한다. 참고로 [CI를 적용하는 편이 소프트웨어를 배포하는 데 훨씬 효과적이라는 객관적인 증거](https://www.amazon.com/Accelerate-Software-Performing-Technology-Organizations/dp/1942788339)가 있으니 고려하기 바란다.

#### 테스팅
리팩터링의 두드러진 특성은 프로그램의 겉보기 동작은 똑같이 유지된다는 것이다. 절차를 지켜 제대로 리팩터링하면 동작이 깨지지 않아야 한다. 하지만 실수를 저지른다면? 실수하더라도 재빨리 해결하면 문제가 되지 않는다. 리팩터링은 단계별 변경 폭이 작아서 도중에 발생한 오류의 원인이 될만한 코드 범위가 넓지 않다. 원인을 못 찾더라도 버전 관리 시스템을 이용하여 가장 최근에 정상 작동하던 상태로 되돌리면 된다.

여기서 핵심은 오류를 재빨리 잡는 데 있다. 실제로 이렇게 하려면 코드의 다양한 측면을 검사하는 테스트 스위트(test suit)가 필요하다. 그리고 이를 빠르게 실행할 수 있어야 수시로 테스트하는 데 부담이 없다. 달리 말하면 리팩터링하기 위해서는 (대부분의 경우에) [자가 테스트 코드 - **self-testing code**](https://martinfowler.com/bliki/SelfTestingCode.html)를 마련해야 한다는 뜻이다.

자가 테스트 코드를 갖추기란 실현 불가능할 정도로 무리한 요구라고 생각하는 독자도 있을 것이다. 하지만 수십 년 동안 자가 테스트를 이용하여 소프트웨어를 빌드하는 팀을 많이 봤다. 물론 테스트에 어느 정도 노력을 기울여야 하는 것은 사실이지만, 효과는 상당하다. 자가 테스트 코드는 리팩터링을 할 수 있게 해줄 뿐만 아니라, 새 기능 추가도 훨씬 안전하게 진행할 수 있도록 도와준다. 실수로 만든 버그를 빠르게 찾아서 제거할 수 있기 때문이다. 이때 핵심은 테스트가 실패한다면 가장 최근에 통과한 버전에서 무엇이 달라졌는지 살펴볼 수 있다는 데 있다. 테스트 주기가 짧다면 단 몇 줄만 비교하면 되며, 문제를 일으킨 부분이 그 몇 줄 안에 있기 때문에 버그를 훨씬 쉽게 찾을 수 있다.

또한 리팩터링 과정에서 버그가 생길 위험이 아주 크다는 불안감을 해소할 수 있다. 자가 테스트 코드 없이 리팩터링할 때는 당연히 이 점을 염려해야 한다. 견고한 테스트를 마련해야 한다고 그토록 강조하는 이유도 여기 있다.

테스트 문제는 다른 방식으로도 해결할 수 있다. 뛰어난 자동 리팩터링 기능을 제공하는 환경이라면 굳이 테스트하지 않아도 오류가 생기지 않는다고 확신할 수 있다. 따라서 안전한 자동 리팩터링만을 활용한다면 테스트 없이 리팩터링해도 좋다. 그러면 활용할 수 있는 리팩터링 기법 수가 제한되지만, 자동 리팩터링들만으로도 의미 있는 효과를 보기에 충분하다. 그래도 나는 자가 테스트 코드를 마련하는 편인데, 꼭 필요해서라기보다는 갖춰두면 유용하기 때문이다.

이러한 생각 때문에 안전하다고 검증된 몇 가지 리팩터링 기법만 조합해서 사용하자는 흐름이 등장했다. 물론 각 단계를 신중하게 진행해야 하고 구체적인 방법도 언어마다 달라진다. 그렇더라도 이 방식을 적용해본 팀은 테스트 커버리지가 넓지 않은 대규모 코드베이스도 효과적으로 리팩터링할 수 있음을 확인했다. 하지만 이 책에서는 자세히 다루지 않겠다. 최근에 등장한 움직임인 데다, 언어에 따라 구체적인 방법이 달라지고, 그 방법들에 대한 설명과 이해도가 충분히 성숙하지 않았기 때문이다. (그래도 나중에 내 웹사이트에서 다뤄봤으면 하는 주제다. 간단히 맛보고 싶은 독자는 [제이 바주자(Jay Bazuzi)의 글](https://jay.bazuzi.com/Safely-extract-a-method-in-any-C++-code/)을 읽어보기 바란다. C++에서 메서드를 안전하게 추출하는 방법을 설명하고 있다).

자가 테스트 코드는 통합 과정에서 발생하는 의미 충돌을 잡는 메커니즘으로 활용할 수 있어서 자연스럽게 CI와도 밀접하게 연관된다. CI에 통합된 테스트는 XP의 권장사항이자 지속적 배포(Continuous Delivery - CD)의 핵심이기도 하다.

#### 레거시 코드
사람들 대부분은 많이 물려받을수록 좋아한다. 하지만 프로그래밍할 때는 그렇지 않다. 물려받은 레거시 코드(legacy code)는 대체로 복잡하고 테스트도 제대로 갖춰지지 않은 것이 많다. 무엇보다도 다른 사람이 작성한 것이다(생각만해도 끔찍하다).

레거시 시스템을 파악할 때 리팩터링이 굉장히 도움이 된다. 제 기능과 맞지 않은 함수 이름을 바로 잡고 어설픈 프로그램 구문을 매끄럽게 다듬어서 거친 원석 같던 프로그램을 반짝이는 보석으로 만들 수 있다. 하지만 이러한 희망찬 스토리에 테스트가 없다는 사실이 찬물을 끼얹는 때가 많다. 대규모 레거시 시스템을 테스트 코드없이 명료하게 리팩터링하기는 어렵다.

이 문제의 정답은 당연히 테스트 보강이다. 단순 노동에 가까울 수 있다는 점을 제외하면 간단히 할 수 있어 보이지만, 막상 해보면 생각보다 훨씬 까다롭다. 보통은 테스트를 염두에 두고 설계한 시스템만 쉽게 테스트할 수 있다. 물론 그런 시스템이라면 테스트를 갖추고 있을 것이라서 애초에 이런 걱정을 할 일이 없다.

쉽게 해결할 방법은 없다. 그나마 해줄 수 있는 조언은 [레거시 코드 활용 전략(에이콘, 2018)](http://www.yes24.com/Product/Goods/64586851)에 나온 지침을 충실히 따르는 것이다. (원서 기준으로) 출간된 지 오래되긴 했지만 십 년 이상 지난 지금도 그대로 적용할 수 있는 지침들이다. 주요 내용을 한 마디로 표현하면 '프로그램에서 테스트를 추가할 틈새를 찾아서 시스템을 테스트해야 한다'는 것이다. 이러한 틈새를 만들 때 리팩터링이 활용된다. 테스트 없이 진행하기 때문에 상당히 위험하지만 문제를 해결하기 위해서라면 감내해야 할 위험이다. 이럴 때 안전한 자동 리팩터링 도구가 있다면 큰 도움이 된다. 그래서 사실 상당히 어려운 작업이다. 이처럼 난감한 상황에서 빠져나오기 위한 더 쉬운 방법은 아쉽게도 없다. 내가 처음부터 자가 테스트 코드를 작성해야 한다고 그토록 강조한 이유가 바로 이 때문이다.

테스트를 갖추고 있더라도 복잡하게 얽힌 레거시 코드를 아름다운 코드로 단번에 리팩터링하는 데는 낙관적이지 않다. 내가 선호하는 방식은 서로 관련된 부분끼리 나눠서 하나씩 공략하는 것이다. 코드의 한 부분을 훑고 넘어갈 때마다 예전보다 조금이라도 개선하려고 노력한다. 역시 캠핑 규칙에 따라 처음 왔을 때보다 깨끗하게 치우는 것이다. 레거시 시스템의 규모가 크다면 자주 보는 부분을 더 많이 리팩터링한다. 코드를 훑게 되는 횟수가 많다는 말은 그 부분을 이해하기 쉽게 개선했을 때 얻는 효과도 그만큼 크다는 뜻이니 당연히 이렇게 해야 한다.

#### 데이터베이스
이 책의 초판에서 데이터베이스는 리팩터링하기 어려운 영역이라고 말했다. 하지만 초판이 출간된 지 일년도 지나지 않아서 틀린 말이 돼버렸다. 내 동료인 프라모드 사달게(Pramod Sadalage)가 개발한 [진화형 데이터베이스 설계(evolutionary database design)](https://martinfowler.com/articles/evodb.html)와 [데이터베이스 리팩터링 기법](https://martinfowler.com/books/refactoringDatabases.html)은 현재 널리 적용되고 있다. 이 기법의 핵심은 커다란 변경들을 쉽게 조합하고 다룰 수 있는 데이터 마이그레이션 스크립트를 작성하고, 접근 코드와 데이터베이스 스키마에 대한 구조적 변경을 이 스크립트로 처리하게끔 통합하는 데 있다.

간단한 예로 필드(열)의 이름을 변경하는 경우를 생각해보자. [6.5 함수 선언 바꾸기(Change Function Declaration)](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter06/6-5.md)에 따르면 데이터 구조의 원래 선언과 이 데이터 구조를 호출하는 코드를 모두 찾아서 한 번에 변경해야 한다. 그런데 예전 필드를 사용하는 데이터 모두가 새 필드를 사용하도록 변환해야 하는 부담도 따른다. 이럴 때 나는 이 변환을 수행하는 코드를 간단히 작성한 다음, 선언된 데이터 구조나 접근 루틴을 변경하는 코드와 함께 버전 관리 시스템에 저장한다. 그런 다음 데이터베이스를 다른 버전으로 이전할 때마다 현재 버전에서 원하는 버전 사이에 있는 모든 마이그레이션 스크립트를 실행한다.

다른 리팩터링과 마찬가지로 이 기법도 전체 변경 과정을 작고 독립된 단계들로 쪼개는 것이 핵심이다. 그래야 마이그레이션 후에도 정상 작동할 수 있다. 단계를 잘게 나누면 코드도 쉽게 작성할 수 있다. 그리고 여러 단계를 순차적으로 연결해서 데이터베이스의 구조와 그 안에 담긴 데이터를 큰 폭으로 변경할 수도 있다.

데이터베이스 리팩터링은 프로덕션 환경에 여러 단계로 나눠서 릴리스하는 것이 대체로 좋다는 점에서 다른 리팩터링과 다르다. 이렇게 하면 프로덕션 환경에서 문제가 생겼을 때 변경을 되돌리기 쉽다. 이를테면 필드 이름을 바꿀 때 첫 번째 커밋에서는 새로운 데이터베이스 필드를 추가만 하고 사용하지는 않는다. 그런 다음 기존 필드와 새 필드를 동시에 업데이트하도록 설정한다. 그 다음에는 데이터베이스를 읽는 클라이언트들을 새 필드를 사용하는 버전으로 조금씩 교체한다. 이 과정에서 발생하는 버그도 해결하면서 클라이언트 교체 작업을 모두 끝냈다면, 더는 필요가 없어진 예전 필드를 삭제한다. 이렇게 데이터베이스를 변경하는 방식은 [병렬 수정 - Parallel Change](https://martinfowler.com/bliki/ParallelChange.html) 또는 팽창-수축(expand-contract)의 일반적인 예다. 