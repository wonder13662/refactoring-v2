# 2.8 리팩터링과 성능
리팩터링하면 프로그램 성능이 느려질까봐 걱정하는 사람들이 많다. 나는 실제로 소프트웨어를 이해하기 쉽게 만들기 위해 속도가 느려지는 방향으로 수정하는 경우가 많다. '직관적인 설계 vs 성능'은 중요한 주제다. 내가 성능을 무시하는 이유는 설계의 순수성을 우선시하거나 조만간 더 빠른 하드웨어가 나오리라 믿기 때문이 아니다. 예전에도 너무 느린 소프트웨어는 고객이 수용해주지 않았고 빠른 하드웨어가 등장하더라도 성능 기준이 낮아지는 경우는 드물었다. 리팩터링하면 소프트웨어가 느려질 수도 있는 건 사살이다. 하지만 그와 동시에 성능을 튜닝하기는 더 쉬워진다. 하드 리얼타임(hard real-time) 시스템을 제외한 소프트웨어를 빠르게 만드는 비결은, 먼저 튜닝하기 쉽게 만들고 나서 원하는 속도가 나게끔 튜닝하는 것이다.

나는 빠른 소프트웨어를 작성하는 방법 세 가지를 경험했다. 

1. 시간 예산 분배(time budgeting) 방식
가장 엄격한 방법은으로, 하드 리얼타임 시스템에서 많이 사용한다. 이 방식에 따르면 설계를 여러 컴포넌트로 나눠서 컴포넌트마다 자원(시간과 공간) 예산을 할당한다. 컴포넌트는 할당된 자원 예산을 초과할 수 없다. 단, 주어진 자원을 서로 주고받는 매커니즘을 제공할 수는 있다. 시간 예산 분배 방식은 특히 엄격한 시간 엄수를 강조한다. 심장 박동 조율기처럼 데이터가 늦게 도착하면 안되는 시스템에서는 이러한 점이 굉장히 중요하다. 반면, 사내 정보 시스템과 같은 부류에는 맞지 않는 기법이다.

2. 끊임없이 관심을 기울이는 것
프로그래머라면 누구나 높은 성능을 유지하기 위해 무슨 일이든 한다. 직관적이어서 흔히 사용하는 방식이지만 실제 효과는 변변치 않다. 성능을 개선하기 위해 코드를 수정하다 보면 프로그램은 다루기 어려운 형태로 변하기 쉽고, 결국 개발이 더뎌진다. 결과적으로 소프트웨어가 더 빨라지면 충분한 보상을 얻겠지만 실제로 그런 경우는 별로 없다. 이 방식에서는 성능을 개선하기 위한 최적화가 프로그램 전반에 퍼지게 되는데, 각각의 개선은 프로그램의 특정 동작에만 관련될 뿐, 정작 컴파일러와 런타임과 하드웨어의 동작을 제대로 이해하지 못한 채 작성할 때도 많다.

3. 90%의 시간은 낭비
성능에 대한 흥미로운 사실은, 대부분의 프로그램은 전체 코드의 극히 일부에서 대부분의 시간을 소비한다는 것이다. 그래서 코드 전체를 고르게 최적화한다면 그 중 90%는 효과가 거의 없기 때문에 시간 낭비인 셈이다. 속도를 높이기 위한 투자한 시간(다른 관점에서 보자면 코드를 덜 명료하게 바꾸느라 투자한 시간)을 모두 날리는 행위다.

성능 개선을 위한 세번째 방법은 이 '90%의 시간은 낭비'라는 통계에서 착안한 것이다. 즉, 의도적으로 성능 최적화에 돌입하기 전까지는 성능에 신경 쓰지 않고 코드를 다루기 쉽게 만드는데 집중한다. 그러다 성능 최적화 단계가 되면 다음의 구체적인 절차를 따라 프로그램을 튜닝한다.

먼저 프로파일러로 프로그램을 분석하여 시간과 공간을 많이 잡아먹는 지점을 알아낸다. 그러면 성능에 큰 영향을 주는 작은 부분들을 찾을 수 있다. 그런 다음 전체를 고르게 최적화할 때와 마찬가지 방법으로 그 부분들을 개선한다. 이렇게 하면 성능에 큰 영향을 주는 부분만 집중해서 최적화하기 때문에 적은 노력으로 훨씬 큰 효과를 볼 수 있다. 이때도 물론 신중하게 작업해야 한다. 리팩터링할 때처럼 최적화를 위한 수정도 작은 단계로 나눠서 진행한다. 각 단계마다 컴파일과 테스트를 거치고 프로파일러를 다시 실행해본다. 성능이 개선되지 않았다면 수정 내용을 되돌린다. 이런 식으로 사용자가 만족하는 성능에 도달할 때까지 최적화 대상을 찾아서 제거하는 일을 계속한다.


프로그램을 잘 리팩터링해두면 이런 식의 최적화에 두 가지 면에서 도움이 된다. 
1. 성능 튜닝에 투입할 시간을 벌 수 있다. 리팩터링이 잘 되어 있다면 기능 추가가 빨리 끝나서 성능에 집중할 시간을 더 벌 수 있다.(또한 프로파일링을 하면 이렇게 확보한 시간을 낭비 없이 쓸 수 있다.) 
2. 리팩터링이 잘 되어 있는 프로그램은 성능을 더 세밀하게 분석할 수 있다. 프로파일러가 지적해주는 코드의 범위가 더 좁아질 것이고, 그래서 튜닝하기 쉬워진다. 코드가 깔끔하면 개선안들이 더 잘 떠오를 것이고, 그 중 어떤 튜닝이 효과가 좋을지 파악하기 쉽다.

리팩터링은 성능 좋은 소프트웨어를 만드는 데 기여한다. 단기적으로 보면 리팩터링 단계에서는 성능이 느려질 수도 있다. 하지만 최적화 단계에서 코드를 튜닝하기 훨씬 쉬워지기 때문에 결국 더 빠른 소프트웨어를 얻게 된다.

## 아무것도 안 만드는 데도 시간이 걸린다 - 론 제프리

크라이슬러 종합 보상(Chrysler Comprehensive Compensation - C3) 시스템의 지급 프로세스가 너무 느려졌다. 아직 개발 중이긴 했지만, 테스트 속도마저 떨어뜨려서 점점 거슬리기 시작했다. 나는 켄트 벡, 마틴 파울러와 함께 이 문제를 해결하기로 결심했다. 두 사람이 올 때까지 기다리는 동안 내 머릿속에 든 방대한 시스템 관련 지식을 토대로 속도가 느려진 원인을 곰곰이 생각해봤다. 다양한 가능성을 떠올려보고 필요한 수정 방안에 대해 팀원들과 의견을 교환했다. 그 결과 시스템 성능을 높일 수 있다고 생각되는 아주 멋진 아이디어들을 몇 가지 도출했다.

그리고 나서 켄트 벡의 프로파일러를 이요앟여 실제 성능을 분석해봤다. 그런데 앞서 생각한 가능성들은 모두 작금의 문제와 전혀 상관이 없었다. 대신 시스템이 날짜 인스턴스를 생성하는 데 실행 시간의 절반을 쓴다는 사실을 발견했다. 더 충격적인 점은 그 많은 인스턴스들의 값이 고작 두어 가지였다는 사실이다.

그래서 날짜 생성 로직을 분석했더니 최적화할 만한 부분이 몇 가지 눈에 띄었다. 외부에서 입력받는 것도 전혀 없는데 날짜들을 모두 문자열 변환을 거쳐 만들고 있었는데, 순전히 타이핑하기 쉽다는 이유로 모조리 문자열 변환을 거치도록 적상했던 것이다. 이 부분은 최적화할 수 있을 것 같았다.

이어서 생성된 날짜가 사용되는 부분을 살펴봤다. 그랬더니 상당수는 날짜 구간을 나타내는 인스턴스, 즉 시작 날짜와 종료 날짜를 갖는 객체를 생성하고 있었다. 좀 더 깊이 들여다보니 날짜 구간의 대다수는 텅 비어 있었다.

우리는 날짜 구간을 다룰 때 시작 날짜보다 끝나는 날짜가 빠른 기간은 모두 빈 구간으로 처리하는 관례를 따랐다. 그런데 이 관례를 적용하고 나서 얼마 지나지 않아, 종료 후에 시작하는 구간을 생성하는 코드는 남들이 보기에 명료하지 않다는 사실을 깨달았다. 그래서 이 동작을 뽑아내어 빈 날자 구간을 만들어주는 팩터리 메서드를 만들었다.

코드를 깔끔하게 정리하고자 한 이 수정이 전혀 예상치 못한 혜택을 안겨주었다. 우리는 팩터리 메서드가 빈 날짜 구간 객체를 매번 생성하지 않고 미리 만들어둔 객체를 반환하게 했다. 그랬더니 시스템이 두 배로 빨라져서 테스트를 수행하기 충분해졌다. 이 작업은 대략 5분밖에 걸리지 않았다.

나는 가장 먼저 여러 팀원과 함께 우리가 잘 알고 있는 코드에서 잘못될 만한 부분이 없는지를 집중적으로 살펴봤었다(켄트와 마틴은 이 과정에 참여하지 않았다). 심지어 개선안의 설계를 그려보기까지 했다. 실제로 무슨 일이 벌어지고 있는지 측정해보지도 않고서 말이다.

완전히 잘못 접근한 것이다. 팀원들과 흥미진진하게 토론한 것 말고는 결국 아무런 소득이 없었다. 이 일의 교훈은 간단하다. 시스템에 대해 잘 알더라도 섣불리 추측하지 말고 성능을 측정해봐야 한다. 그러면 새로운 사실을 배우게 되는데, 십중팔구 내가 잘못 알고 있었음을 깨닫게 된다.

- [목차](https://github.com/wonder13662/refactoring-v2/blob/writing/README.md)
- [2 리팩터링 원칙](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter02)
- [2.7 리팩터링과 소프트웨어 개발 프로세스](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter02/2-7.md)
- [2.9 리팩터링의 유래](https://github.com/wonder13662/refactoring-v2/blob/writing/chapter02/2-9.md)